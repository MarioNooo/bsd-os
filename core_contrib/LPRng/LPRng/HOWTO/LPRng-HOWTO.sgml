<!-- LPRng-HOWTO SGML format -->
<!doctype linuxdoc system>
<article>
<!-- must be matched by / article at end -->
<title> LPRng-HOWTO
<author> Patrick Powell <tt><htmlurl url="mailto:papowell@astart.com"
    name="papowell@astart.com"></tt>
<!--VERSION-->
<date> 18 Apr 2000 (For LPRng-3.6.14beta28)
<abstract>
The LPRng software is an enhanced, extended, and portable implementation
of the Berkeley LPR print spooler functionality. While providing the same
interface and meeting RFC1179 requirements, the implementation is completely
independent and provides support for the following features: lightweight (no databases
needed) lpr, lpc, and lprm programs; dynamic redirection of print queues;
automatic job holding; highly verbose diagnostics; multiple printers serving
a single queue; client programs do not need to run SETUID root; greatly enhanced
security checks; load balancing across multiple printers;
and a greatly improved permission and authorization mechanism.

The source software compiles and runs on a wide variety of UNIX systems,
and is compatible with other print spoolers and network printers that use
the LPR interface and meet RFC1179 requirements.

The companion ifhp print filter is used with the LPRng to provide
hardware level support for PostScript, PCL, text, and other printers.
The ifhp filter also provides diagnostic and error information as well as
accounting information.
The LPRng distribution also has a set of easily customizable programs to
produce banner pages for job identification.

The SVR4 lp and lpstat functionality is provided by a set of emulator
programs,
and LPRng can be easily integrated with the Samba SMB support package.

For users that require secure and/or authenticated printing support,
LPRng supports Kerberos 5,
MIT Kerberos 4 extensions to LPR,
PGP,
and simple MD5 based authentication.
Additional authentication support is extremely simple to add.
</abstract>
<toc>
<sect>Introduction
<p>
Printing is one of the essential services provided by computer systems.
Users want reliable and easy to use methods of printing
that require a minimum amount of effort to used and understand.
On single user systems with a directly attached printer they
perceive that the printing process is simply a matter of
<it/storing/
or
<it/spooling/
a file,
and then transferring it to the printer in a timely manner.
In the classical
<it/multi-user/ systems,
each user expects to share a common printer with one or more users;
the print
<it/spooling/
system provides arbitration and sharing of the printer among the various users.
In a <it/network/
based multi-user system,
there may be one or more printers shared by multiple users on many different
systems.
The print <it/spoolers/ will need to cooperate to provide print services to
the users in a simple an predictable manner.
<p>
The LPRng print spooler software was developed to a flexible and scalable
approach to each of these printing problems.
It has been used since 1988 in extremely demanding
academic printing environments such as University of Minnesota, MIT,
and Rutgers,
commercial companies such as Dow Jones and Abbot Pharmaceuticals,
as well as being distributed with Linux, FreeBSD, and other systems.
Each of these environments has a unique set of problems,
demanding various configuration and administrative capabilities.
For example,
the simple single user system with a single or limited number of printers
requires easy configuration and simple diagnostic procedures,
while the network based printing system requires highly robust
error logging,
authentication,
and failover support.
<p>
This document
is structured to first provide an overview of the LPRng printing system,
and then a
<em/quickstart/ guide for single user systems with a simple printer.
This includes printer hardware and Operating System  specific setup descriptions.
Next,
more complex configurations are described,
and their management and configuration are outlined.
Next,
an extremely detailed description of the LPRng print spooling components
and their functionality is provided.
Finally,
an index to the various features and functions of LPRng is provided.
<sect1>What is LPRng?
<label id="secfeatures">
<p>
LPRng is a print spooling system. It was designed to mimic the
Berkeley (University of California - Berkeley) Line Printers (LPR)
package, first found on Berkeley derivatives of the Unix operating
system.
LPRng will print a document with little or no knowledge of the content
or special processing required to print the document on a stand-alone machine
or in a distributed printing environment.
New (as compared to Berkeley LPR) features
include: lightweight <tt>lpr</tt>, <tt>lpc</tt> and <tt>lprm</tt>
programs, dynamic redirection of print queues, automatic job holding,
highly verbose diagnostics, load balancing queues; enhanced
security (SUID not required in most environments),
and easy configuration.
<p>
LPRng started life at the University of Waterloo in 1986
as PLP (Public Line Printer), a replacement for the original BSD LPD code.
This was a one-shot effort by the author,
Patrick Powell,
to develop code that could be freely redistributed
without the restrictions of the BSD/AT&amp;T license
and would allow non-license sites to fix and patch problems that they were
having with print spooling.
From 1988 to 1992,
various individuals and groups added features, hacked, slashed, and modified the
PLP code, coordinated largely by Justin Mason (<tt>&lt;jmason@iona.ie&gt</tt>),
who started the LPRng mailing list (see <ref id="maillist" name="More Information">).
<p>
In 1992 while at San Diego State University
Prof. Powell redesigned and reimplemented the PLP code
and named the result LPRng.
The goals of the LPRng project were to build a server system that was as
close to user abuse proof as possible,
that would provide services limited only by the inherent capacities of the
support system,
RFC1179 compliant,
and with extensive debugging capabilities to allow
quick and easy diagnostics of problems.
Over the period from 1994-2000,
LPRng users have suggested extensions,
provided patches,
and added facilities.
<p>
In early 1999
the code base for LPRng was reorganized in order to provide a common
method for running on non-UNIX platforms such as Microsoft Windows NT,
Apple Rhapsody, and embedded systems.
<p>
As a side effect of this work,
many security problems that could develop were identified and steps
taken to ensure that they were not present in LPRng.
For example,
LPRng clients such as lpr, lprm, lpc, and lpq run as
ordinary users programs,
and even the lpd server can run as a user once a network port has
been opened.
Bounds checking is performed on all input and formatting (for example,
snprintf() rather
than sprintf() is used),
as well as other preventive measures where appropriate.
<p>
<sect1>More Information
<label id="maillist">
<p>
The main LPRng documentation is the LPRng-HOWTO,
which is available in text, HTML, info, and PostScript format.
Information
about LPRng and the latest release
can be found on the LPRng web page
<htmlurl url="http://www.astart.com/LPRng.html" name="http://www.astart.com/LPRng.html">
<p>
There is also a mailing list at
<htmlurl url="mailto:lprng-request@lprng.com?subject=subscribe" name="lprng@lprng.com">.
To post to the list you must subscribe by sending send an email to
<htmlurl url="mailto:lprng-request@lprng.com?subject=subscribe" name="lprng-request@lprng.com">,
with the message subject or body containing the word `subscribe' or `help'.
<p>
Several presentations of LPRng and print spooling software have been made
at the Large Scale Installation Administrator (LISA) conferences and
are in the LPRng distribution and available on web sites.
<htmlurl url="http://www.astart.com/LPRng.html"
name="LPRng - An Enhanced Printer Spooler System">
was presented at the LISA95 conference,
and is in the LPRng distribution as LPRng_DOC/LPRng-LISA95.ps.
The slides for the
<htmlurl url="http://www.astart.com/LPRng.html"
name="LISA97">
and
<htmlurl url="http://www.astart.com/LPRng.html"
name="LISA98">
tutorials on <it/Network Printing and Print Spooling/ are also
available in the LPRng documentation package.
<p>
<sect1>Frequently Asked Questions
<p>
There is a list of Frequently Asked Questions that appear regularly
on the LPRng mailing list.
For your convenience, see
<ref id="FAQ" name="The Most Frequently Asked Questions">.
<sect1>License, Copyright, and Disclaimer
<p>
The LPRng Print Spooler and the associated ifhp print filter software
are distributed under the
<htmlurl url="license.txt" name="Gnu Public License (GPL) and the Artistic License">.
Users can choose to redistribute or use the software under a license
that is appropriate for their purpose.
Other licenses and distribution agreements are available by contacting
<htmlurl url="http://www.astart.com" name="AStArt Technologies">
for information.
<p>
Material included in this document from the LPRng distribution is
Copyright Patrick Powell 1988-2000.
The rights to distribute this document complete or in part are hereby
granted for non-commercial purposes.
Partial reproductions must acknowledge the Copyright and source.
Permission to distribute this file together with LPRng and `derived
works' (as defined in the LPRng license) is explicitly granted. This
is allowed independent of the license under which the software is
distributed.
Citing the document is allowed as long as the source is acknowledged.
<p>
<bf>THE MATERIAL IN THESE SOFTWARE PACKAGES IS PROVIDED WITHOUT FEE AND AS-IS WITH NO
WARRANTY REGARDING FITNESS OF USE FOR ANY PURPOSE. THE AUTHOR AND ALL
CONTRIBUTORS ARE NOT LIABLE FOR ANY DAMAGES, DIRECT OR INDIRECT,
RESULTING FROM THE USE OF INFORMATION PROVIDED IN THIS DOCUMENT.</bf>
<sect1>Commercial Support
<p>
<htmlurl url="http://www.astart.com" name="AStArt Technologies">
provides commercial support and enhancements for
the LPRng and other network software.
AStArt provides network and system consulting services for UNIX and NT
systems, as well as real time and network software.
<sect1>Web Site
<p>
Web Page:
<htmlurl url="http://www.astart.com/lprng.html" name="http://www.astart.com/lprng.html">
<p>
<sect1>FTP Sites
<label id="secftp">
<p>
The software may be obtained from
<htmlurl url="ftp://ftp.astart.com/pub/LPRng" name="ftp://ftp.astart.com/pub/LPRng">(Main site)
<p>
Mirrors:<newline>
<htmlurl url="ftp://ftp.sage-au.org.au/pub/printing/spooler/lprng" name="ftp://ftp.sage-au.org.au/pub/printing/spooler/lprng"> (AU)<newline>
<htmlurl
url=
"ftp://sunsite.ualberta.ca/pub/Mirror/LPRng/"
name=
"ftp://sunsite.ualberta.ca/pub/Mirror/LPRng/"
> (CA)<newline>
<htmlurl url="ftp://ftp.informatik.uni-hamburg.de/pub/os/unix/utils/LPRng" name="ftp://ftp.informatik.uni-hamburg.de/pub/os/unix/utils/LPRng"> (DE)<newline>
<htmlurl url="ftp://ftp.uni-paderborn.de/pub/unix/printer/plp/LPRng" name="ftp://ftp.uni-paderborn.de/pub/unix/printer/plp/LPRng"> (DE)<newline>
<htmlurl url="ftp://ftp.chembio.ntnu.no/pub/mirrors/LPRng" name="ftp://ftp.chembio.ntnu.no/pub/mirrors/LPRng"> (NO)<newline>
<htmlurl url="ftp://ftp.mono.org/pub/LPRng" name="ftp://ftp.mono.org/pub/LPRng"> (UK)<newline>
<htmlurl url="ftp://ftp.cs.columbia.edu/pub/archives/pkg/LPRng" name="ftp://ftp.cs.columbia.edu/pub/archives/pkg/LPRng"> (US)<newline>
<htmlurl url="ftp://ftp.cs.umn.edu/pub/LPRng" name="ftp://ftp.cs.umn.edu/pub/LPRng"> (US)<newline>
<htmlurl url="ftp://uiarchive.uiuc.edu/pub/packages/LPRng" name="ftp://uiarchive.uiuc.edu/pub/packages/LPRng"> (US)<newline>
<htmlurl url="ftp://uabgate.uab.ericsson.se/pub/unix/LPRng" name="ftp://uabgate.uab.ericsson.se/pub/unix/LPRng">(SE)<newline>
<sect1>Mailing List
<p>
To join the LPRng mailing list, please send mail to
<htmlurl url="mailto: lprng-request@lprng.org" name="lprng-request@lprng.org">
with the word 'subscribe' in the BODY.
<p>The LPRng mailing list is archived on
<newline>
<htmlurl
url="http://www.findmail.com/list/lprng"
name="http://www.findmail.com/list/lprng"
>
<sect1>PGP Public Key
<label id="faqref">
<p>
The LPRng distributions have an MD5 checksum calculated,
which is then signed with a PGP public key.
Here is the key for validating the checksums:
<tscreen>
<verb>
Type Bits/KeyID    Date       User ID
pub  1024/00D95C9D 1997/01/31 Patrick A. Powell <papowell@astart.com>

-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: 2.6.3i

mQCNAzLygTQAAAEEANBW5fPYjN3wSAnP9xWOUc3CvsMUxjip0cN2sY5qrdoJyIhn
qbAspBopR+tGQfyp5T7C21yfWRRnfXmoJ3FVtgToAsJUYmzoSFY08eDx+rmSqCLe
rdJjX8aG8jVXpGipEo9U4QsUK+OKzx3/y/OaK4cizoWqKvy1l4lEzDsA2VydAAUT
tCdQYXRyaWNrIEEuIFBvd2VsbCA8cGFwb3dlbGxAYXN0YXJ0LmNvbT6JAJUDBRA0
XonoiUTMOwDZXJ0BAQ2cBAC7zU9Fn3sC3x0USJ+3vjhg/qA+Gjb5Fi1dJd4solc4
vJvtf0UL/1/rGipbR+A0XHpHzJUMP9ZfJzKZjaK/d0ZBNlS3i+JnypypeQiAqo9t
FV0OyUCwDfWybgAORuAa2V6UJnAhvj/7TpxMmCApolaIb4yFyKunHa8aBxN+17Ro
rrQlUGF0cmljayBBLiBQb3dlbGwgPHBhcG93ZWxsQHNkc3UuZWR1PokAlQMFEDLy
gTSJRMw7ANlcnQEBYBYD/0zTeoiDNnI+NjaIei6+6z6oakqO70qFVx0FG3aP3kRH
WlDhdtFaAuaMRh+RItHfFfcHhw5K7jiJdgKiTgGfj5Vt3OdHYkeeh/sddqgf9YnS
tpj0u5NfrotPTUw39n6YTgS5/aW0PQfO9dx7jVUcGeod1TGXTe9mIhDMwDJI4J14
=3Zbp
-----END PGP PUBLIC KEY BLOCK-----
</verb>
</tscreen>
<sect1>References and Standards
<p>
The following references and standards have been used
in the development of the LPRng software.
<sect2>Requests For Comments
<p>
During the development of the Internet,
the developers did not want to go through the laborious process of
developing formal standards and applying to a standards body such as the
EIA, IEEE, or ISO.
Instead,
they called the standards documents they developed
<it/Requests for Comments/.
These soon became <it/de facto/ standards,
and with the formal acceptance of the TCP/IP protocol as a
network standard,
<it/de jure/ as well.
<p>
You can get copies of the RFCs from literally
hundreds of network sites.  The most well known are
The USC Information Sciences Institute
(<htmlurl url="http://www.isi.edu" name="http://www.isi.edu">),
(<htmlurl url="http://www.faqs.org/rfcs" name="http://www.faqs.org/rfcs">),
or by using FTP from one of
<htmlurl url="ftp://NIS.NSF.NET" name="NIS.NSF.NET">,
<htmlurl url="ftp://RFC.JVNC.NET" name="RFC.JVNC.NET">,
or
<htmlurl url="ftp://FTP.ISI.EDU" name="FTP.ISI.EDU">.
<p>
The <it/RFC1179 - Line Printer Daemon Protocol/
describes the protocol used to transfer jobs from client program to
print server.
See
<ref id="rfc1179ref" name="RFC1179">
for more a discussion of this protocol and more details about the RFC.
The <htmlurl url="rfc1179.txt" name="rfc1179.txt"> file is also included
in the LPRng distribution.
<sect2>PostScript
<label id="postscript">
<p>
PostScript is one of the <it>de facto</it>
standards for print jobs.
The
Adobe Corporation
(<htmlurl url="http://www.adobe.com" name="http://www.adobe.com">)
provides an execellent set of references for the PostScript language.
They have made many of these available for downloading from their
web sites or have published them in book form.
<p>
The <it>PostScript Language Reference Manual</it>
contains a great deal of technical information about the PostScript Language,
and is the language reference manual.
<p>
The <it>PostScript Language Tutorial and Cookbook</it>
is a very nice and easy to read introduction to PostScript programming,
and has some very useful utilities.
Combined with
<ref id="ghostscript" name="GhostScript">
and the
<ref id="gv" name="gv">
display program
you can very easily learn to write your own small PostScript programs,
and more importantly,
can learn to understand the contents of PostScript files.
<p> The <it>PostScript Language Program Design</it>
is the companion to the
<it>PostScript Language Tutorial and Cookbook</it>,
and has more complex examples of PostScript programs.
More importantly,
it also introduces,
although without explanation,
the PostScript Document Structuring Conventions described in Appendix G
of the
The <it>PostScript Language Reference Manual</it>.
This alone makes it useful.
<sect2>HP PCL 5
<label id="pcl">
<p>
The Hewlett-Packard (HP) PCL Printer Language is the second de-facto
standard for print jobs.
Currently,
Hewlett-Packard
makes documentation for PCL available through their
<it>Developer Program</it>.
You will need to register and then search their site for the
<it>PCL 5 Printer Language Reference Manual</it>.
<sect2>HP PJL
<label id="pjl">
<p>
The Hewlett-Packard (HP) Printer Job Language is used
to control various features of HP printers.
The <it>Printer Job Language Reference Manual</it>
is also available from
Hewlett-Packard
(<htmlurl url="http://www.hp.com" name="http://www.hp.com">)
through their
<it>Developer Program</it>.
<sect2>PDF
<p>
The Portable Document Format (<it/pdf/) was developed by Adobe to be
a more useful method of distributing documentation for view
by online systems and software.
The
<it>Portable Document Format Reference Manual</it>
is available from
Adobe
(<htmlurl url="http://www.adobe.com" name="http://www.adobe.com">).
While <it/pdf/ is not used directly as a print job language,
it is one of the more common formats for files that need to be printed.
It can be converted to PostScript by most <tt/pdf/ viewers such
as GhostScript and
Adobe Acrobat.
<sect>Installation
<label id="installingprograms">
<label id="installation">
<p>
The basic components of the LPRng system are the executables
and the database files.
This section deals with generating and installing the executable
files.
<sect1>Getting Source Code and Support Programs
<p>
<enum>
<item>
Obtain the latest or stable version of the LPRng source code from a
<ref id="secftp" name="LPRng FTP Site">.
<item>
Obtain the latest or stable version of the <tt/ifhp/ filter source code from a
<ref id="secftp" name="LPRng FTP Site">.
This filter is used to support
PostScript,
PCL,
and text printers.
<item>
Obtain the following GNU programs from one of the many
<htmlurl url="http://www.gnu.org" name="GNU Software Mirror Sites">
and install them.
See the directions in the GNU Zip distribution for details.
<descrip>
<tag>gzip/gunzip file compression utility</tag>
Used to decompress many files in the LPRng and other distributions.
<p>
<tag>GNU tar file archive utility</tag>
This is version of tar supports native Gzip compression and decompression
and is used to generate the LPRng distribution.
<p>
<tag>GNU make</tag>
LPRng assumes that GNU make (<tt/gmake/) will be used during
the configuration and installation process.
<p>
<tag>GNU gcc Compiler</tag>
If you do not have an ANSI C compiler,
then please use the GCC compiler.
</descrip>
<item>
LPRng requires and ANSI C compiler.
If you do not have one on your system
then please obtain and use the <tt/gcc/ compiler.
<item>
Solaris Sparc and X86 Binaries for GCC and Make  can be obtained from
<htmlurl url="http://sunfreeware.com/" name="http://sunfreeware.com/">.
<item>
While the following are not essential,
they are useful to have.
<descrip>
<tag>file(1) utility</tag>
The Open Source utility by Ian F. Darwin
can be obtained from
<htmlurl url="ftp://ftp.astron.com/pub/file" name="ftp://ftp.astron.com/pub/file">.
This is a greatly improved version of the original UNIX file utility and
may be used by the <tt/ifhp/ filter to do file recognition.
<tag>GhostScript</tag>
<label id="ghostscript">
GhostScript
can be obtained from
<htmlurl url="http://www.cs.wisc.edu/~ghost/" name="http://www.cs.wisc.edu/~ghost/">
or
<htmlurl url="http://www.ghostscript.com" name="http://www.ghostscript.com">.
GhostScript is a PostScript interpreter that allows you to translate
PostScript to various printer compatible formats such as PCL,
as well as displaying the code on a terminal.
You might also want to get the PDF extensions that allows GhostScript to
read and print PDF files.
<tag>gv (GhostView)</tag>
<label id="gv">
Of course you will want to get the <tt/gv/ program that
uses GhostScript to display PostScript on an X terminal.
It can be obtained from
<htmlurl url="http://wwwthep.physik.uni-mainz.de/~plass/gv/"
name="http://wwwthep.physik.uni-mainz.de/~plass/gv/" >
</descrip>
</enum>
<sect1>Set PATH and Check Utilities
<p>
If make sure that you have
<tt>/usr/local/bin</tt>
in your path if you have installed
the GNU tools in the (standard) <tt>/usr/local/bin</tt>
directory.
This should be one of the first entries in the shell search PATH.
<p>
If you are compiling on a Solaris system
make sure that you have
<tt>/usr/ccs/bin</tt>
in your search path as well.
The <tt>/usr/local/bin</tt> entry must be before <tt>/usr/ccs/bin</tt>.
<p>
After doing this,
check to see that the GNU <tt/make/ utility
and not the default OS make is being used by default.
Use <tt/make -v/ to determine what version you have,
and if you have GNU <tt/make/.
<tscreen>
<verb>
% make -v
GNU Make version 3.75, by Richard Stallman and Roland McGrath.
Copyright (C) 1988, 89, 90, 91, 92, 93, 94, 95, 96
</verb>
</tscreen>
<sect1>Setting Up Daemon User
<label id="group">
<label id="user">
<p>
By default,
the <tt/lpd/ server is started at system initialization time
and runs as ROOT (uid 0).
In order to provide a higher level of security,
LPRng will perform file operations as the non-privileged user
<tt/daemon/ and group <tt/daemon/.
<p>
Use the appropriate system administration tools to
create a user and group <tt/daemon/.
Most UNIX systems already have such a user.
User <tt/daemon/ must <bf/not/ have login capability.
<sect1>Configuration
<p>
The LPRng package consists of:
<itemize>
<item> <em><tt>lpd</tt></em> - the LPD print <bf/server/ program
<item>
<em><tt>lpr</tt></em>,
<em><tt>lpq</tt></em>,
<em><tt>lprm</tt></em>,
<em><tt>lpc</tt></em> -
and
<em><tt>lpstat</tt></em>,
<bf/client/ programs for printing,
status queries, job removal, server configuration,
and System V <tt/lpstat/ emulation respectively.
<item>
<em><tt>printcap</tt></em> print queue database file
which is used by all the server and client programs
<item>
<em><tt>lpd.conf</tt></em> LPRng configuration options
which is used by all the server and client programs
<item>
<em><tt>lpd.perms</tt></em> permission information
which is used by the <tt/lpd/ server to control user actions.
</itemize>
<p>
LPRng uses the <tt/configure/ facility
for configuration and installation.
Configure generates a set of Makefiles which are used
by the <tt/make/ program to compile and install software.
The following Makefile variables and values are set by <tt/configure/
to specify the location of the LPRng software:
<tscreen>
<verb>
Directories:
  Variable        Value               Default
  $&lcub;prefix&rcub;                           (/usr/local)
  $&lcub;exec_prefix&rcub;  $&lcub;prefix&rcub;           (/usr/local)
  $&lcub;bindir&rcub;       $&lcub;exec_prefix&rcub;/bin  (/usr/local/bin)
  $&lcub;sbindir&rcub;      $&lcub;exec_prefix&rcub;/sbin (/usr/local/sbin)
  $&lcub;libexecdir&rcub;   $&lcub;exec_prefix&rcub;/libexec (/usr/local/libexec)
  $&lcub;sysconfdir&rcub;   $&lcub;prefix&rcub;/etc       (/usr/local/etc)
  $&lcub;mandir&rcub;       $&lcub;prefix&rcub;/man       (/usr/local/man)
</verb>
</tscreen>
<p>
These are used for the following files:
<tscreen>
<verb>
Variable                 Files
$&lcub;bindir&rcub;               lpr, lprm, lpq, lpstat
$&lcub;sbindir&rcub;              lpc, checkpc, lpd
$&lcub;libexecdir&rcub;/filters   lpf, pclbanner, psbanner, lpbanner
$&lcub;sysconfdir&rcub;           lpd.conf, lpd.perms, printcap
$&lcub;mandir&rcub;/man[1-9]  man pages
</verb>
</tscreen>
<p>
You can set explicit values for the
<tt/prefix/
<tt/bindir/
<tt/sbindir/
<tt/libexecdir/
and
<tt/mandir/ variables using the <tt/--name=PATH/
option.
For example:
<tscreen>
<verb>
./configure --prefix=/usr --sysconfdir=/etc --mandir=/usr/share/man
Variable              Value           Files
$&lcub;bindir&rcub;             /usr/bin        /usr/bin/&lcub;lpr,lprm,lpq,lpstat&rcub;
$&lcub;sbindir&rcub;            /usr/sbin       /usr/sbin/&lcub;lpc,checkpc,lpd&rcub;
$&lcub;libexecdir&rcub;/filters /usr/libexec/filters   \
              /usr/libexec/filters&lcub;lpf, pclbanner, psbanner, lpbanner&rcub;
$&lcub;sysconfdir&rcub;         /etc            /etc/&lcub;lpd.conf,lpd.perms,printcap&rcub;
$&lcub;mandir&rcub;/man[1-9]  /usr/share/man/man[1-9]/&lcub;man pages&rcub;
</verb>
</tscreen>
<p>
In addition to these general purpose options
<tt/configure/ has the following options to control
various system requirements.
<descrip>
<tag><tt>
--disable-setuid
</tt></tag>
Install the executables without setuid ROOT permissions.
Non-setuid clients and programs are inherently more secure than SETUID programs,
and system administrators would be well advised to install them without
SETUID root permissions.
Please see <ref id="setuid" name="Security Considerations">
for more details about this option.
<tag><tt>
--disable-strip
</tt></tag>
Do not strip the executables before installing.
For debugging and diagnostic purposes.
<tag><tt>
--enable-priv_ports.
</tt></tag>
Require connections to the <tt/lpd/ server
to come from a privileged port (range 1-1023).
By default
LPRng will allow connections from any port.
Please see <ref id="setuid" name="Security Considerations">
for more details about this option.
<tag><tt> --disable-force_localhost.  </tt></tag>
The default LPRng configuration assumes that all printing will be done
via a <tt/lpd/ print spooler running on the local host system.
However,
many larger sites prefer that all users do their printing via a
few central servers,
and do not run
<tt/lpd/ servers on user systems.
The
<tt/--disable-force_localhost/
configuration sets the default value of the <tt/force_localhost/
value to <tt/false/,
by default allowing the LPRng clients to connect directly to <tt/lpd/ servers
on remote hosts.
<tag><tt/--disable-require_configfiles/</tag>
By default, the
<tt/lpr/,
<tt/lpq/,
<tt/lpc/, ...
clients require the <tt/lpd.conf/ and <tt/printcap/ files
to be present on the localhost.
The
<tt/--disable-require_configfiles/
option removes this requirement.
<tag><tt> --disable-kerberos</tt></tag>
Do not include support for Kerberos 5 authenticated transfers.
<tag><tt> --with-lpddir=DIR.  </tt></tag>
lpd executable directory (default $&lcub;sbindir&rcub;).
For historical configuration compatibility.
<tag><tt> --with-filterdir=DIR.  </tt></tag>
Filter directory (default $&lcub;libexecdir&rcub;/filters).
For historical configuration compatibility.
<tag><tt> --with-lpd_conf_path=PATH.  </tt></tag>
Path of <tt/lpd.conf/ file.
For historical configuration compatibility.
<tag><tt> --with-lpd_perms_path=PATH </tt></tag>
Path of <tt/lpd.perms/ file.
For historical configuration compatibility.
<tag><tt> --with-printcap_path=PATH </tt></tag>
Path of <tt/printcap/ file.
For historical configuration compatibility.
</descrip>
<p>
It is recommended that you use one of the following
configurations:
<enum>
<item>
If you already have a print spooling system installed and
want to install LPRng for testing purposes or as an alternative
to the existing system, use:
<tscreen>
<verb>
./configure

 use all configure's defaults,
   /usr/local/&lcub;bin,sbin,libexec/filters,man&rcub;
 requires a server to run on the local host
 everything installed setuid ROOT
</verb>
</tscreen>
<item>
If you want to replace your existing print spooling system
and run an LPD server on your local host, use:
<tscreen>
<verb>
./configure --prefix=/usr --sysconfdir=/etc \
  --mandir=/usr/share/man

   executables and files in
     /usr/&lcub;bin,sbin,libexec/filters&rcub;
     /usr/share/man/man[0-9]
   requires a server to run on the local host
   everything installed setuid ROOT
</verb>
</tscreen>
<item>
If you want to replace your existing print spooling system
and have all jobs sent to a remote host which runs a server
(lightweight operation), use:
<tscreen>
<verb>
./configure --prefix=/usr --sysconfdir=/etc \
   --mandir=/usr/share/man --disable-force_localhost

   executables and files in
     /usr/&lcub;bin,sbin,libexec/filters&rcub;
     /usr/share/man/man[0-9]
   clients will connect to a remote server
</verb>
</tscreen>
</enum>
<sect1>Compilation and Install
<p>
Once you have decided on the configuration you want,
you can now compile and install the software as follows:
<tscreen>
<verb>
gunzip -c LPRng-<version>.tgz | tar xvf -
 OR with GNU tar
tar -zxvf LPRng-<version>.tgz
cd LPRng-<version>

./configure  [ .... configuration options ]
gmake clean all
su   # you must do the following commands as root
gmake install

# if  you have not installed LPRng before,
# install default lpd.perms and lpd.conf file in /etc
if [ ! -f /etc/lpd.perms ]; then
    make default;
fi;
# update permissions,  create files needed for LPRng, check
# /etc/printcap file for problems.  Do as root:
checkpc -f
</verb>
</tscreen>
<sect1>IFHP Compilation and Install
<p>
If you are planning on using the <tt/ifhp/ filter,
then now would be a good time to
download it and install it as well.
Configure will install executables and files
in the following locations,
depending on the variable values
<tscreen>
<verb>
Variable                 Files
$&lcub;libexecdir&rcub;/filters   ifhp,textps
$&lcub;sysconfdir&rcub;           ifhp.conf
$&lcub;mandir&rcub;/man[1-9]  man pages
</verb>
</tscreen>
<p>
Use the same directory location options
for <tt/configure/
as you did for the LPRng install.
<tscreen>
<verb>
gunzip -c ifhp-<version>.tgz | tar xvf -
 OR with GNU tar
tar -zxvf ifhp-<version>.tgz
cd ifhp-<version>

./configure  [ .... configuration options ]
gmake clean all
su   # you must do the following commands as root
gmake install
</verb>
</tscreen>
<p>
<sect1>Installation Problems
<p>
The <tt/configure/
script will determine the type of system and establish a set of defaults
for compilation and installation.
It is most unlikely that you will encounter problems with
configure.
If you do,
please send your problems to the LPRng mailing list at
<htmlurl url="mailto:lprng-request@lprng.com?subject=subscribe" name="lprng@lprng.com">.
You will need to subscribe to the list first before you can post it.
<p>
If you have problems compiling the package, you can try these things:
<enum>
<item>Compiler complains about missing files or has a large number of
errors.
Use <tt>gcc</tt> instead of your vendor's C compiler.
<tscreen>
<verb>
CC=gcc ./configure
   OR
configure --with-cc=gcc
</verb>
</tscreen>

<item>
Missing libraries or include files.
<newline>
Usually this is caused when include files are in
<tt>/usr/local/include</tt>
and libraries are in
<tt>/usr/local/include</tt>
and these paths are not searched or used by the compiler.
This can be fixed by setting the
<tt/CPPFLAGS/ and <tt/LDFLAGS/ environment variables,
or using the
<tt/--with-cppopts=/
and
<tt/--with-ldopts=/
configure options.
<tscreen>
<verb>
CPPFLAGS="-I/usr/local/include -I/usr/include/kerberosIV" \
  LDFLAGS="-L/usr/local/lib -L/usr/lib/kerberosIV" \
  ./configure
   OR
configure --with-cppopts="-I/usr/local/include -I/usr/include/kerberosIV" \
  --with-ldopts="-L/usr/local/lib -L/usr/lib/kerberosIV"
</verb>
</tscreen>
</enum>
<p>
The <tt>configure</tt> and <tt>make</tt> steps must be run on
the target host,
especially if the target host has a different version of the operating system.
This is extremely important for SunOS or Solaris,
where
there tend to be changes in the system's include files between
versions
as well as support libraries.
<p>
Read the notes for your OS in section
<ref id="sysdep" name="System-dependent notes">
for specific installation help (if any).

<sect1>Printcap, lpd.conf, and lpd.perms files
<label id="requireconfig">
<p>
The <tt>printcap</tt> file contains the definitions of print queues
and other information used by LPRng,
and is located in the directory specified by the
configuration <tt/${sysconfdir}/ value.
If your system does not have an existing <tt>printcap</tt> file,
then the following is suitable for initial testing and configuration:
<tscreen>
<verb>
# test printcap file
lp:cm=Test Printcap Entry:
 :lp=/dev/null
 :sd=/usr/spool/lpd/lp
</verb>
</tscreen>
<p>
The <tt>lpd.conf</tt>
is located in the <tt/${sysconfdir}/ directory
and provides configuration settings for both the LPRng client and server
programs.
During installation the
<tt>lpd.conf.template</tt> file
is installed in the
<tt>${sysconfdir}/lpd.conf.template</tt>
and if there is not an existing <tt/lpd.conf/ file
is copied to
<tt>${sysconfdir}/lpd.conf</tt>
as well.
<p>
The <tt>lpd.perms</tt>
is located in the <tt/${sysconfdir}/ directory
and is used by the <tt/lpd/ program to determine user permissions
for printing activities.
During installation the
<tt>lpd.perms.template</tt> file
is installed in the
<tt>${sysconfdir}/lpd.perms.template</tt>
and if there is not an existing <tt/lpd.perms/ file
is copied to
<tt>${sysconfdir}/lpd.perms</tt>
as well.
<p>
The client programs
<tt/lpr/,
<tt/lpq/,
etc. will check for a <tt/lpd.conf/ and <tt/printcap/
file.
You can relax this requirement by setting
using the configuration option <tt/--disable-require_configfile/.
If these files are not going to be used,
then simply create empty files to satisfy the program requirements.
<sect1>Checking System Installation with Checkpc
<p>
The
<tt/checkpc/
program is used to make sure that
the spool directories and files used by LPRng have the correct permissions
and are in place.
By default,
<tt/checkpc/ will check permissions and report if there are any problems.
You should run this as <tt/root/.
For example:
<tscreen>
<verb>
% astart > su
#>cd LPRng/src
#>./checkpc
Warning - No configuration file '/usr/local/etc/lpd.conf'
Warning - No lpd only printcap file found in '/usr/local/lpd_printcap'
Warning -  ** cannot open '/var/run/lpd.printer' - 'Permission denied'
Warning -  bad directory - /var/spool/lpd/lp
Warning -   Printer_DYN 'lp' spool dir '/var/spool/lpd/lp' needs fixing
</verb>
</tscreen>
<p>
In the above example,
<tt/checkpc/ has discovered that the <tt>lpd.conf</tt>
file is missing.
This is a serious problem and indicates that the
software was incorrectly installed.
<p>
The <it/lpd only printcap/
message is usually of concern to administrators who wish to use some of
LPRng's more exotic configuration options.
It is possible to have separate printcap databases for client and server programs.
This is useful when printcap files get extremely large and cuts down
substantially on system management problems.
<p>
The permission denied message for <tt>/var/run/lpd.printer</tt> is serious,
as the <tt/lpd/ server uses this as a lock file.
<p>
The <it/bad directory/ message about the spool directory is usually caused by
wrong permissions or a missing directory.
<p>The <tt/checkpc -f/ (fix) option causes <tt/checkpc/ to take action to rectify errors.
The <tt/checkpc -f -V/ (verbose) option causes the fixup activity to be displayed a well:
<tscreen>
<verb>
% astart > su
h4# checkpc -f -V
LPRng version LPRng-3.6.14
Checking for configuration files '/usr/local/etc/lpd.conf'
  found '/usr/local/etc/lpd.conf', mod 0100644
Checking for printcap files '/usr/local/etc/printcap'
  found '/usr/local/etc/printcap', mod 0100644
Checking for lpd only printcap files '/usr/local/etc/lpd_printcap'
 DaemonUID 1, DaemonGID 1
Using Config file '/usr/local/etc/lpd.conf'
LPD lockfile '/var/run/lpd.printer'
 Checking directory: '/var/run'
   directory '/var'
   directory '/var/run'
  checking '/var/run/lpd.printer' file

Printcap Information
lp
 :force_localhost
 :lp=/var/tmp/lp
 :sd=/var/spool/%P
Checking printcap info
Checking printer 'lp'
 Checking directory: '/var/spool/lp'
   directory '/var'
   directory '/var/spool'
   directory '/var/spool/lp'
  file 'control.lp', zero length file unchanged in 1 hours
  file 'status.lp', zero length file unchanged in 1 hours
  file 'status', zero length file unchanged in 1 hours
  file 'log', zero length file unchanged in 1 hours
  file 'acct', zero length file unchanged in 1 hours
  checking 'control.lp' file
  checking 'status.lp' file
  checking 'status' file
  cleaning 'status' file, 0K bytes: no truncation
  checking 'log' file
  cleaning 'log' file, 0K bytes: no truncation
  checking 'acct' file
  cleaning 'acct' file, 0K bytes: no truncation
</verb>
</tscreen>
<p>
As you can see, <tt/checkpc/ can not only print detailed information about your
printing system,  but it also fixes up the various problems.
<sect1>Removing Existing Print Spooler Software and Updating Startup Scripts
<p>
Before running LPRng, you should shut down and remove the existing print
spooler and associated client programs.
Unfortunately,
this process is fairly system dependent,
and requires a small amount of system expertise.
In addition to these general directions,
you should see the
<ref id="sysdep" name="System specific notes"> for your system.
<p>
While it appears that this should be done <bf>before</bf>
you install the LPRng print software,
in practice it turns out to be easier to do
<bf>after</bf>
you have installed it.
<p>
On most systems you need only remove or rename executable files,
and should not remove and configuration or data files.
<sect2> SunOS and BSD Derived Systems
<p>
This section provides instructions for  systems that use the
<tt/lpd/ print services,
such as SunOS,
BSD derived systems,
and Linux based systems.
These systems use an <tt/lpd/ print server,
as does LPRng.
By convention,
most of the executable programs are in the
<tt>/usr/bin</tt>,
<tt>/usr/sbin</tt>,
<tt>/usr/libexec</tt>,
and
<tt>/usr/ucb</tt>.
<p>
At initialization time these systems run
a <tt>rc</tt> startup script that starts the <tt/lpd/
print server.
Unfortunately,
this startup script can a single line in a file
or be a small shell script.
You should first locate the startup script as follows.
<enum>
<item>
Execute the following commands to see if there is a
startup command in a file in a file in the <tt>/etc</tt>
directory.
The commands a typical result on a system are shown.
<tscreen>
<verb>
# cd /etc
# find . -type f -exec grep -l lpd {} \; -print
./rc.local
</verb>
</tscreen>
<item>
Examine each of the files and check to see they code to
start the <tt/lpd/ print spooler.
If they do, then simply comment out the line and
one which contains the path to the LPRng print spooler.
<tscreen>
<verb>
# /etc/rc.local
if [ -f /etc/printcap  -a -f /usr/libexec/lpd ] ; then
  /usr/libexec/lpd ;
fi

--- change this to
if [ -f /etc/printcap  -a -f /usr/local/sbin/lpd ] ; then
  /usr/local/sbin/lpd ;
fi
</verb>
</tscreen>
<item>
If you have an existing <tt/printcap/ file,
then you should either copy this to the location used by LPRng
or make a symbolic link to it.
</enum>
<p>
Next we kill the currently running <tt/lpd/ process.
<tscreen>
<verb>
# most BSD Systems
ps -auxw |grep lpd
# Kill it twice
kill (pid of lpd server)
#  This should report an error - if not then lpd did not terminate
kill (pid of lpd server)
#

Example:
astart % ps -axuw |grep lpd
papowell 23932  0.0  0.3  224  184  p3  S+  10:40AM  0:00.01 grep lpd
daemon  17763  0.0  0.2  448  120  ??  IWs  29Mar99  0:01.35 (lpd)
astart % kill 135
astart % kill 135
135: No such process
</verb>
</tscreen>
<p>
Next,
you should remove or rename the existing print system executables.
The following example shows how to use the
<tt/find/ utility to track down candidates.
<tscreen>
<verb>
astart# find /usr -type f -name lp\*  -print >/tmp/candidates
astart# find /sbin -type f -name lp\*  -print >>/tmp/candidates
astart# cat /tmp/candidates
/usr/bin/lpunlock
/usr/bin/lpqall.faces
/usr/bin/lpq             <---- old
/usr/bin/lpr             <---- old
/usr/bin/lprm            <---- old
/usr/bin/lptest
/usr/doc/samba-1.9.18p10/examples/printer-accounting/lp-acct
/usr/man/man1/lpq.1
/usr/man/man1/lpr.1
/usr/man/man1/lprm.1
/usr/man/man1/lptest.1
/usr/man/man4/lp.4
/usr/man/man8/lpc.8
/usr/man/man8/lpd.8
/usr/sbin/lpc            <--- old
/usr/sbin/lpd            <--- old
/usr/sbin/lpf            <--- old
/usr/local/bin/lpc    <-- LPRng
/usr/local/bin/lpq    <-- LPRng
/usr/local/bin/lpr    <-- LPRng
/usr/local/bin/lprm   <-- LPRng
/usr/local/sbin/lpd   <-- LPRng
astart # mv /usr/bin/lpq  /usr/bin/lpq.old
astart # mv /usr/bin/lpr  /usr/bin/lpr.old
astart # mv /usr/bin/lprm /usr/bin/lprm.old
astart # mv /usr/sbin/lpc /usr/sbin/lpc.old
astart # mv /usr/sbin/lpd /usr/sbin/lpd.old
astart # mv /usr/sbin/lpf /usr/sbin/lpf.old
...
</verb>
</tscreen>
<p>
After all this,
you should now run <tt/checkpc -f/
(as root) to make sure that the LPRng configuration is present and
correctly set up,
and then start <tt/lpd/ by hand.
You should try to use <tt/lpq/ to see if the spool queues are present
and set up correctly and the system is functional.

<tscreen>
<verb>
# checkpc -f
# lpd
# lpq
Printer: lw4@h2  'Hp : Laserwriter'
 Queue: no printable jobs in queue
 Status: job 'root@h2+884' removed at 11:27:25.864
 Filter_status: done at 11:27:25.766
# lpr /etc/motd
# lpq
Printer: lw4@h2  'Hp : Laserwriter'
 Queue: no printable jobs in queue
 Status: job 'root@h2+888' removed at 11:27:25.864
 Filter_status: done at 11:33:17.020
</verb>
</tscreen>
<p>
Finally,
you should reboot your machine and make sure that the <tt/lpd/
print server starts correctly.
<sect2> Solaris, HP, AIX, and SysVR4 Derived Systems
<label id="solarisinstall">
<p>
The original SysVR4 and other related systems did not have
any support for RFC1179 network printing (Berkeley LPD).
Support for this was added by various manufacture specific methods.
Unfortunately,
there are a wide range of different installation types.
<p>
The <tt/lpsched/ process (<tt>/usr/lib/lp/lpsched/</tt>)
process performs many of the functions of the LPRng and BSD
<tt/lpd/
server.
On Solaris systems,
it also stats the
<tt/lpNet/
server that provides network print services.
Unfortunately,
no <it/simple/ and reliable method of shutting down a running <tt/lpsched/
process
and the associated network services has been found.
However,
it turns out to be very simple to <em/prevent/ the services from
being started.
<p>
First,
you will need to locate the <tt>/etc/rc</tt> startup files
that start system services.
During system startup,
a set of shell scripts stored in the <tt>/etc/rc.d</tt>
directories are executed.
The individual startupfile files are usually links to a
common one in the <tt>/etc/init.d</tt> directory.
You first need to find the files containing the startup commands.
This is done as shown below:
<tscreen>
<verb>
SUN # cd /
SUN # find . -type f -exec grep -l lpsched {} \; -print >/tmp/files
SUN # cat /tmp/files
/etc/rc0.d/K20lp
/etc/rc2.d/K20lp
/etc/rc2.d/S80lp
/etc/init.d/lp
># ls -l ` cat /tmp/files `
lrwxrwxr-x 1 root bin 1 Dec 29 23:39 /etc/rc0.d/K20lp -> ../../init.d/lp
lrwxrwxr-x 1 root bin 1 Dec 29 23:39 /etc/rc2.d/K20lp -> ../../init.d/lp
lrwxrwxr-x 1 root bin 1 Dec 29 23:39 /etc/rc2.d/S80lp -> ../../init.d/lp
-rwxr--r-- 5 root sys 460 Sep 1 1998 /etc/rcS.d/K39lp
</verb>
</tscreen>
<p>
Here is the contents of the typical script file,  with the
indicated modifications that should be made for testing
<tscreen>
<verb>
#!/sbin/sh
case "$1" in
'start')
    [ -f /usr/lib/lpsched ] && /usr/lib/lpsched ;;
'stop' )
    [ -f /usr/lib/lpshut ] && /usr/lib/lpshut ;;
*)
    echo "Usage: $0 &lcub; start | stop &rcub;"
    exit 1
esac
exit 0
</verb>
</tscreen>
<p>
You should stop the <tt/lpsched/ server by using the following:
<tscreen>
<verb>
sh /etc/rd.c/init.d/lp stop
<verb>
<tscreen>
<p>
We next modify the startup by replacing the start and stop entries
as show below.
We will modify these later to start the LPRng <tt/lpd/ server.
<tscreen>
<verb>
#!/sbin/sh
case "$1" in
'start')
    # [ -f /usr/lib/lpsched ] && /usr/lib/lpsched ;;
    #[ -f /usr/sbin/lpd ] && /usr/sbin/lpd ;;
'stop' )
    # [ -f /usr/lib/lpshut ] && /usr/lib/lpshut ;;
    #kill -2 `cat /var/run/lpd*` >/dev/null 2>1;
*)
    echo "Usage: $0 &lcub; start | stop &rcub;"
    exit 1
esac
exit 0
</verb>
</tscreen>
<p>
Next,
as for the BSD installation,
we will find all of the printing related commands and rename them.
You can either rename them one by one,
or use the script method shown below.
The minimum of the indicated files should be renamed.
<tscreen>
<verb>
SUN # find /usr -type f -name lp\* -print >/etc/printingfiles
SUN # cat /tmp/printingfiles
/usr/bin/lp          <---
/usr/bin/lpstat      <---
/usr/lib/lp/bin/lp.cat
/usr/lib/lp/bin/lp.set
/usr/lib/lp/bin/lp.tell
/usr/lib/lp/lpNet    <---
/usr/lib/lp/lpsched  <---
/usr/lib/lp/lpdata   <---
/usr/sbin/lpadmin    <---
/usr/sbin/lpfilter   <---
/usr/sbin/lpforms    <---
/usr/sbin/lpmove     <---
/usr/sbin/lpshut     <---
/usr/sbin/lpsystem   <---
/usr/sbin/lpusers    <---
/usr/ucb/lpc         <---
/usr/ucb/lpq         <---
/usr/ucb/lpr         <---
/usr/ucb/lprm        <---
/usr/ucb/lptest
SUN # for i in ` cat /tmp/printingfiles ` ; do
>  mv $i $i.old
>  done
</verb>
</tscreen>
<p>
Next, you find if there is a <it/cron/ job scheduled
by the file
<tt>/var/spool/cron/crontabs/lp</tt>
to periodically update and roll over error logs.
If there is, you should
(after having saved the file)
remove it.
<tscreen>
<verb>
cp /var/spool/cron/crontabs/lp /etc/cron.crontabs.lp
</verb>
</tscreen>
<p>
Check the <tt>/etc/inetd.conf</tt> file for a line like:
<tscreen>
<verb>
printer stream tcp nowait root /usr/lib/print/in.lpd in.lpd
</verb>
</tscreen>
<p>
Comment out this line.
This line is not present on all systems.
<p>
Now we must <em/reboot/  the machine.  You can use
<tt/reboot/ if you are in a rush,
and <tt/shutdown/ if you are not.
<tscreen>
<verb>
SUN # reboot
or
SUN # shutdown -y "Whooga! Whooga! Dive! Dive! System going down."
</verb>
</tscreen>
<p>
When the system reboots,
check to make sure that the
<tt/lpd/ server is not listening on port 515.
<tscreen>
<verb>
SUN # telnet localhost 515
Trying 127.0.0.1...
telnet: Unable to connect to remote host: Connection refused
</verb>
</tscreen>
<p>
If you do get a connection established
then you must use <tt/nlsadmin/ to force the
<it/tcpip listener/ to release the port, as illustrated below.
<tscreen>
<verb>
SUN # nlsadmin -v tcp
lpd  \x00020203000000000000000000000000  ENABLED  \
  NORPC  root  NOMODULES  /var/spool/lp/fifos/listenBSD  #
0  \x00020ACE000000000000000000000000  ENABLED    \
  NORPC  root  NOMODULES  /usr/lib/saf/nlps_server  #
lp  NOADDR  ENABLED  NORPC  root  NOMODULES \
  /var/spool/lp/fifos/listenS5  #
SUN # nlsadmin -r lpd tcp
SUN # nlsadmin -r lp tcp
</verb>
</tscreen>
<p>
You might also want to run
<tt>pmadm -l</tt> and if you see anything other than zsmon stuff (e.g. lp
stuff is there), then use <tt>pmadm -r </tt>to remove it.
See the man page for details.
<p>
Once you disable the listener,
reboot the system and try to connect to port 515.
If you can still do this then there is some other unknown problem
beyond these instructions and you should consult Sun Microsystems.
<p>
Finally we enable the <tt/lpd/ server.
Edit the startup script as shown below:
<tscreen>
<verb>
#!/sbin/sh
case "$1" in
'start')
    # [ -f /usr/lib/lpsched ] && /usr/lib/lpsched ;;
    [ -f /usr/sbin/lpd ] && /usr/sbin/lpd ;;
'stop' )
    # [ -f /usr/lib/lpshut ] && /usr/lib/lpshut ;;
    kill -2 `cat /var/run/lpd*` >/dev/null 2>1;
*)
    echo "Usage: $0 &lcub; start | stop &rcub;"
    exit 1
esac
exit 0
</verb>
</tscreen>
<p>
Now try starting and stopping the server:
<tscreen>
<verb>
# sh -x /etc/rc.d/init.d/lp start
# lpq
# lpq
Printer: lw4@h2  'Hp : Laserwriter'
 Queue: no printable jobs in queue
 Status: job 'root@h2+884' removed at 11:27:25.864
 Filter_status: done at 11:27:25.766
</verb>
</tscreen>
<sect1>Post Installation System Testing
<p>
The following are a series of tests you might need to do
if LPRng is installed correctly,
but printing does not work.
<p>
These tests run <tt/lpd/ executable in the
<tt/foreground/ and <tt/test/ mode,
and are used to make sure that our system configuration is
correct.
It is best to do this with two screens or windows,
as you will want to observe the output.
<p>
First,
you need to kill the running <tt/lpd/ process.
The method is left as an exercise for the system administrator.
Next,
you run <tt/lpd/ in forground mode:
<tscreen>
<verb>
# > /usr/local/bin/lpd -F
Fatal error - Another print spooler is using TCP printer port
# > /usr/local/bin/lpd -F -D1
...
1999-04-05-10:02:37.755 astart10 [28903] lpd  Read_file_and_split: \
  cannot open file '/etc/lpd.perms' - No such file or directory
1999-04-05-10:02:37.758 astart10 [28903] lpd  Read_file_and_split: \
  cannot open file '/usr/etc/lpd.perms' - No such file or directory
1999-04-05-10:02:37.759 astart10 [28903] lpd  Build_printcap_info: \
  list->count 0, raw->count 3
1999-04-05-10:02:37.777 astart10 [28903] lpd  lpd: listening socket fd -6
Fatal error - Another print spooler is using TCP printer port
1999-04-05-10:02:37.782 astart10 [28903] lpd  Get_max_fd: getrlimit returns 64
1999-04-05-10:02:37.783 astart10 [28903] lpd  Get_max_fd: returning 64
1999-04-05-10:02:37.786 astart10 [28903] lpd  cleanup: done, doing killpg \
   then exit(0)
</verb>
</tscreen>
<p>
If you get the above error message,
then you have either not killed off other the running <tt/lpd/ server
or you are not starting the <tt/lpd/ server as ROOT.
This is the most common error during setup.
Correct the problem and then restart the server if necessary.
You should see the output indicated below:
<tscreen>
<verb>
# > /usr/local/bin/lpd -F -D1
1999-04-05-14:35:14.023 astart27 [2667] Waiting  lpd: LOOP START
1999-04-05-14:35:14.024 astart27 [2667] Waiting  Get_max_servers: getrlimit returns 256
1999-04-05-14:35:14.024 astart27 [2667] Waiting  Get_max_servers: returning 128
1999-04-05-14:35:14.025 astart27 [2667] Waiting  lpd: max_servers 128, active 0
1999-04-05-14:35:14.025 astart27 [2667] Waiting  lpd: starting select timeout 'yes', 600 sec
</verb>
</tscreen>
<p>
Now from another window do the following commands:
<tscreen>
<verb>
# > lpq -Plp@localhost
Printer: lp@astart
 Queue: no printable jobs in queue
# > lpq
Printer: lp@astart
 Queue: no printable jobs in queue
</verb>
</tscreen>
<p>
At this point your LPRng software has been installed and tested.
You still need to set up
<it/Startup Scripts/
to automatically start it at boot time,
and
<tt>/etc/printcap</tt>
entries for your printers.
<sect1>Replacing UNIX SystemV lp, lpstat Printing Services
<label id="lpsimulation">
<p>
Many UNIX utilities in the Solaris and HP UNIX environment use the
UNIX System V <tt>lp</tt> and <tt>lpstat</tt>
programs.
It is almost impossible to modify the programs themselves,
as many are <em/vintage/ software that is unsupported or which would
be too costly to update.
<p>
In order to support these applications,
LPRng provides simulation for the
<tt/lp/,
<tt/lpstat/,
and
<tt/clean/
commands.
<p>
The LPRng <tt/lpstat/ command is a modified version of the
<tt/lpq/ command,
and accepts the <tt/lpstat/ command line options and tries to return
status in an <tt/lpstat/ format.
<p>
If the <tt/lpr/ program is invoked with the name <tt/lp/,
it will simulate the <tt/lp/ options.
Finally, if the <tt/lprm/ program is invoked with the name <tt/cancel/,
it will simulate the <tt/lp/ options.
This can be done by using symbolic links or copying the programs.
<p>
Note that many of the <tt/vintage/ applications have fully qualified
paths to the <tt/lp/ and <tt/lpstat/ executables,
so it will be necessary to copy them to the
execution directory or make symbolic links from the
directories to the programs.  In the example below
the executables are assumed to be installed in the
<tt>/usr/local/bin</tt> directory:
<tscreen>
<verb>
# original - /usr/bin/lp
# original - /usr/bin/lpstat
cd /usr/local/bin
cp lpr /usr/bin/lp
cp lpstat /usr/bin/lpstat
cp lprm /usr/bin/cancel

OR

cd /usr/bin
ln -s /usr/local/bin/lpr lp
cp /usr/local/bin/lpstat .
ln -s /usr/local/bin/lprm cancel
</verb>
</tscreen>
<p>
See the man pages for lp, lpstat, and cancel in the LPRng/man directory.
Not all the functions of the original
programs are supported and
these man pages should be installed to replace the original
lp, etc, man pages.
<sect1>SAMBA and LPRng
<label id="smb">
<label id="samba">
<p>
The SMB network protocol
is used by many Microsoft Operatings Systems
to implement file and printer sharing.
SAMBA is a UNIX package that implements the SMB protocol and provides
a simple and easy way to import and export file systems and printer
facilities.
The web site for SAMBA is
<htmlurl url="http://www.samba.org" name="http://www.samba.org">.
The SAMBA code is extremely easy to install
and the <tt/SWAT/ (Samba Web Administration Tool)
makes configuruation almost trivial.
<p>
The
See the SAMBA
<tt>doc/text/Printing.txt</tt> and related documentation for details on
printing.
In the
<tt/samba.conf/ file <tt/[global]/ section
or in the SWAT page for printing configuration
you need to specify the that you want to have
Samba handle printing,
the
<tt/print/, <tt/lpq/, and <tt/lprm/ commands to be used when a user
prints a job,
asks for status,
or removes a job,
and a temporary directory to hold print jobs when they are submitted.
<tscreen>
<verb>
[printers]
    path = /usr/spool/lpd/samba
    #  ---  do not use the Samba default path = /tmp
    guest ok = no
    print ok = yes
    printing = lprng
    load printers = yes
    printcap name = /etc/printcap
    print command = /usr/local/bin/lpr  -P%p -r %s
    lpq command   = /usr/local/bin/lpq  -P%p
    lprm command  = /usr/local/bin/lprm -P%p %j
    lppause command = lpc hold %p %j
    lpresume command = lpc release %p %j
    queuepause command = lpc -P%p stop
    queueresume command = lpc -P%p start
    #
    # alternative to allow userid to be specified as well
    #
    # You will have to add the samba UID to the 'allow_user_setting'
    #   option in the /etc/lpd.conf file.
    # WARNING: the %U is the name the user requests.  If you have
    # 'guest' printer use,  then you should be aware that this
    # will allow anybody to impersonate a another user,  and they will
    # be able to execute the various LPRng commands as that user.
    #
    #   print command = /usr/local/bin/lpr -U%U -P%p -r %s
    #   lprm command  = /usr/local/bin/lprm -P%p -U%U %j
    #   lppause command = lpc -U%U hold %p %j
    #   lpresume command = lpc -U%U release %p %j
    #   queuepause command = lpc -U%U -P%p stop
    #   queueresume command = lpc -U%U -P%p start
</verb>
</tscreen>
<p>
Please use the following guidelines in your setup.
<enum>
<item>
You should specify the print method as <tt/printing = lprng/.
In newer versions of Samba this will allow Samba to use the
LPRng <tt/printcap/ file.
<item>
You must put all of the printers which Samba has access to
in the <tt/printcap/ file.
In later versions of Samba you can use the following printcap entry
to specify the printers.
In fact, this can be the <bf/only/
entry in the printcap file if you are using lightweight print clients.
<tscreen>
<verb>
all:all=pr1,pr2,pr3,...
</verb>
</tscreen>
<item>
The <tt/lpr -U%U/ option shown in the example above is part of
LPRng's support for Samba.
This causes the <tt/lpr/ and other clients to use the user name specified
with the <tt/-U/ option
as the originator of the command,
instead of the userid that Samba is operating with.
This makes jobs appear to be spooled by the user
and commands appear to originate with the user.
See the <ref id="allowusersetting" name="allow_user_setting">
configuration option for details.
<item>
When printing a file,
Samba first puts the file in the directory specified by the
<tt/path/ option.
This should NOT be the <tt/tmp/ directory,
but should be in a file system able to handle extremely large print files.
For example,
if your LPRng spool queue directory is <tt>/var/spool/lpd</tt>,
then a good location would be <tt>/var/spool/lpd/samba</tt>.
</enum>
<sect1>Security Concerns
<label id="setuid">
<p>
While the LPRng software has been written with security as the primary goal
there is always the problem with undetected errors in the LPRng
software that
when exploited
could cause severe system problems.
The most serious concern is that of gaining ROOT (UID 0) permissions.
<p>
One way to avoid this is to run
<it/client/
programs without root permission.
This operation is possible for LPRng
in contrast to other print spooling software.
<p>
A serious concern when LPRng runs as a nonprivileged
user (daemon) is the fact that the RFC protocol specifies
that connections are made to port 515
and
<tt/lpd/
requires root permissions to open and bind to port 515.
One option is to have the <tt/lpd/ server drop root permissions
soon after binding to this port and before accepting any user
commands.
However,
in order to fully compatible with RFC1179,
<tt/lpd/ must originate connections from a <it/reserved/
port in the range 721-731,
although in practice port 1-1023 seems to be acceptable.
<p>
If inter-operability with non-LPRng print spoolers is not desired,
then it is <it/trivial/
to configure LPRng using the <tt/lpd.conf/
file or by modifying the compile time
<tt/lpd_port/
value in the file or the <tt>LPRng/src/vars.c</tt>
so that all the software will run
as client programs.
For example,
in the <tt>/etc/lpd.conf</tt> file,
you only need to change the indicated lines:
<tscreen>
<verb>
# Purpose: lpd port
#   default lpd_port=printer
lpd_port=2000
</verb>
</tscreen>
<p>Now all the LPRng software will use port 2000 to transfer jobs and
commands.
You can also use this facility to establish a
<it/private/ set of print spoolers which can be used for testing.
<sect>System Specific Notes
<label id="sysdep">
<p>
The following are a set of suggestions and recommendations for
specific systems.
<sect1>Solaris 2.4, 2.5, 2.6, 2.7, 2.8
<p>
The Sun Solaris operating system is derived from the System V UNIX baseline.
Please see the
<ref id="solarisinstall" name="Solaris">
installation information for a detailed description of how
to install LPRng and remove the Solaris Print Services.
<sect1>Linux
<p>
As of March 17, 2000,
there is no universal way to install LPRng cleanly on all of the different
Linux systems.
The major difficulty is the fragmentation in the various libraries,
location of files,
and so forth.
<p>
However,
the good news is that most of the printcap files that are produced by the
GUI interface tools are compatible with LPRng.
The bad news is that the directory and file permissions that they generate
are erroneous.
<p>
Here is an outline of how to install LPRng on most of the major LINUX systems.
<enum>
<item>
Check the LPRng web site
<htmlurl url="http://www.astart.com/LPRng.html" name="http://www.astart.com/LPRng.html">
and see if there is a Linux Release specific version RPM or other distribution
media for your version of Linux.
If there is not,
then you will have to do a source install.
<item>
Obtain the source code and do a source code level install.
I strongly recommend using the following configuration options
which will match all the currently know Linux distribution configurations.
<tscreen>
<verb>
./configure --prefix=/usr --sysconfdir=/etc --mandir=/usr/share/man
</verb>
</tscreen>
<item>
After doing the <tt/make install/,
run <tt/checkpc -f/ and make sure that you eliminate the errors.
<item>
If you have an existing printcap,
then check to see if it has filter entries and modify them as shown
below:
<tscreen>
<verb>
lp:\
  :if=/usr/local/libexec/lpr/hplaserjet3:\
  :bk:\      <<<< added to the printcap by hand
  :...
</verb>
</tscreen>
<item>
Test the configuration and see if it works by sending a file to the queue.
<item>
If this does not work,
then you will have to determine if the problem is in the print spooling
software or in the filter.
See the section on <tt/ifhp/ for directions on how to replace the vendor
supplied filters with <tt/ifhp/.
</enum>
<sect1>AIX
<p>
This information was supplied by
<htmlurl url="mailto:nitschke@math.unihamburg.de" name="Dirk Nitschke">,
as of August 1997,
and describes how to install the LPRng package on a workstation
running AIX 4.1.x and possibly 3.x.x as well.
Dirk would be interested in any comments or corrections.
<p>
Printing on AIX systems is different. AIX provides a general
queueing facility and printing is only one way to use it. You submit a
print job to a print queue using one of the commands
<tt>qprt</tt>, <tt>enq</tt>. You can use the BSD or
System V printing commands <tt>lpr</tt> or <tt>lp</tt>, too. The
qdaemon watches all (general) queues and knows how to handle your
job. A (general) queue is defined in the file
<tt>/etc/qconfig</tt>. The format of this file is different from
the <tt>printcap</tt> format.
<p>
OK, how to replace the AIX printing system? There is no group
<tt>daemon</tt> on AIX. Therefore you have to change the default
group for file ownership and process permissions. We decided to use
the <tt>printq</tt> group. The user <tt>daemon</tt> exists on
AIX but we have chosen <tt>lpd</tt> as the user who runs
<tt>lpd</tt> and all filters and owns the spooling directories.
You can change the values for <tt>group</tt>
and <tt>user</tt> in your
<tt>lpd.conf</tt> file or in the sources
<tt>src/common/vars.c</tt>. This is an example for
<tt>lpd.conf</tt>:
<tscreen>
<verb>
# Purpose: group to run SUID ROOT programs
#   default group=daemon
group=printq
# Purpose: server user for SUID purposes
#   default user=daemon
user=lpd
</verb>
</tscreen>
Compile and install the LPRng package. Create your
<tt>printcap</tt>, spooling directories, accounting and logfiles
and so on.
Don't forget to use
<ref id="checkpc" name="checkpc"> to make sure that all the
permissions are set correctly and the necessary files
are created.
<p>
Then stop all print queues defined on your workstation. Use
<tscreen>
<verb>
# chque -q queuename -a "up = FALSE"
</verb>
</tscreen>
for this (yes, blanks around <tt>=</tt> are needed).
<p>
If you have local printers attached to your system you will have an
<tt>lpd</tt> running. Stop this daemon using SMIT (Print Spooling,
Manage Print Server, Stop the Print Server Subsystem). Choosing
<tt>both</tt> also removes <tt>lpd</tt> from
<tt>/etc/inittab</tt>. Maybe it's faster to do this by hand:
<tscreen>
<verb>
# stopsrc -p'pid of /usr/sbin/lpd'
# rmitab "lpd"
</verb>
</tscreen>
<p>
Now delete all print queues (managed by qdaemon) defined on your
system. You can use SMIT for this or the commands
<tt>&lcub;mk,ch,rm&rcub;que</tt>, <tt>&lcub;mk,ch,rm&rcub;quedev</tt>,
<tt>&lcub;mk,ch,rm&rcub;virprt</tt>. The SMIT fast path is <tt>smit
rmpq</tt>.
<p>
To start the new <tt>lpd</tt> at system startup you have to add
an entry to <tt>/etc/inittab</tt>:
<tscreen>
<verb>
# mkitab "lpd:2:once:/full/path/lpd"
</verb>
</tscreen>
<p>
Some work has to be done if have have a local printer attached to
your workstation. You have to create a device file like
<tt>/dev/lp0</tt>. The SMIT fast path for this is <tt>smit
mkdev</tt>. Choose <tt>Printer/Plotter</tt> and then
<tt>Printer/Plotter Devices</tt>. Now <tt>Add a
Printer/Plotter</tt>. To create a parallel
printer device select the following:
<tscreen>
<verb>
Plotter type:              opp Other parallel printer
Printer/Plotter Interface: parallel
Parent Adapter:            ppa0 Available
</verb>
</tscreen>
Now define the characteristics of the device:
<tscreen>
<verb>
Port Number: p
</verb>
</tscreen>
(<tt>p</tt> is for parallel).
Go to the field
<tscreen>
<verb>
Send all characters to printer UNMODIFIED   no
</verb>
</tscreen>
and select <tt>yes</tt>! We have had a lot of trouble with
<tt>no</tt>.  This is very important! Expect erroneous output if
you choose <tt>no</tt>. If you have already created a device
file, change the characteristics! SMIT's fast path is <tt>smit
chdev</tt>.
<p>
Finally remove all AIX printing commands like <tt>qprt</tt>,
<tt>lp</tt>, <tt>cancel</tt>, <tt>lpr</tt>,
<tt>lprm</tt>. You will find a lot of them in
<tt>/usr/bin</tt>. Do not remove <tt>enq</tt> and friends if
you want to use the general queueing facility.
<p>
Now you can start your new <tt>lpd</tt>.
<sect1>AppleTalk Support
<label id=appletalk>
<p>
Netatalk is used to communicate from TCP/IP to
AppleTalk printers and vice versa.
The Netatalk distribution FAQ is at:
<htmlurl url="http://www.umich.edu/~rsug/netatalk" name="http://www.umich.edu/~rsug/netatalk">.
Also,
The University of Melbourne web site
<htmlurl
url="http://www.cs.mu.oz.au/appletalk/"
name="http://www.cs.mu.oz.au/appletalk/"
>
has additional tutorial and installation information.
In addition,
Anders Brownworth's Web page
<htmlurl
url="http://thehamptons.com/anders/netatalk/"
name="http://thehamptons.com/anders/netatalk/"
>
has a useful collection of information for Linux users.
<p>
After you have installed and gotten netatalk working,
you can use the following AppleTalk configuration file to print
from a Macintosh to an LPRng printer.
<tscreen>
<verb>
Your 32 Character Printer Name:\
        :pr=|/your/path/to/lpr -Pprintername:\
		:op=username.for.printing:\
        :ppd=/your/path/to/ppd/files/yourprinter.ppd:

Examples:

Student Printers:\
        :pr=|/usr/bin/lpr -Pstudent:\
        :op=root:\
        :pd=/var/spool/lpd/student/HP4000.PPD:
HP 2500c:\
        :pr=|/usr/bin/lpr -Php2500c:\
        :op=root:\
        :pd=/var/spool/lpd/hp2500c/HP2500.PPD:
</verb>
</tscreen>
<sect>Print Spooling Tutorial
<label id="overview">
<p>
A print spooler is a program that accepts
<it/print jobs/
(which are usually one or more files)
from a program or network interface,
stores them in a
<it/spool queue/,
and then sends them to a printer or another
print spooler.
Usually there are facilities to submit jobs,
check on the current job status,
remove jobs from spool queues,
and perform administrative functions such as starting or
stopping printing.
<p>
A print spooler is a client/server application.
The client programs are used to submit jobs to the print spooler
program which performs the actual printing operations.
In order to carry out these operations,
the server may need to use other programs to convert print job files
into a format acceptable to a printer,
or perform various accounting or administrative functions.
<sect1>Overview
<p>
<!--PICTURE1-->
<tscreen>
<verb>
+---------+    +-----+    +-----+     +--------+    +---------+
| program | -> | lpr | -> | lpd |  -> | filter | -> | printer |
+---------+    +-----+  * +-----+     +--------+    +---------+
                  *    *     |
               printcap      V
                          +-----+     +--------+    +---------+
                          | lpd |  -> | filter | -> | printer |
                          +-----+     +--------+    +---------+

                           Figure 1
</verb>
</tscreen>
<!--PICTURE1-->
<p>
Figure 1 shows the flow of data between the individual components of the
LPRng print spooling system.
A program (or user) will use the <tt/lpr/ program to send a file
to the <tt/lpd/ server over a TCP/IP connection.
The <tt/lpd/ server will store the file temporarily in a
spool queue directory.
The information needed by the <tt/lpr/ and <tt/lpd/ programs to carry
out this activity is stored in the
<tt/printcap/  (usually called the <tt>/etc/printcap</tt>) database file.
<p>
The <tt/lpd/ server sorts the queue entries and determines the print order.
It will select a job to be printed,
open a connection to the printer,
and then use a <it/filter/ program to convert the file contents into a
format suitable for the printer.
If the file does not need conversion,
then the <tt/lpd/ server will send the file directly to the printer.
<p>
The <tt/lpd/ server can also <tt/forward/ jobs to another print server
over a network connection,
optionally sending them through a filter as well.
The destination server can in turn forward the job or send it to a printer.
<p>
The protocol or commands used to do this job forward and transfer are
specified by
<ref id="rfc1179ref" name="RFC1179">.
This protocol specifies how the <tt/lpr/ client program sends a job
to the <tt/lpd/ server,
as well as how the <tt/lpd/ server forwards jobs to another server.
In addition to job submission,
RFC1179 specifies commands to obtain queue status,
to remove jobs from the queue,
and to start and stop print queues.
<sect1>Sample Printcap Entry
<p>
As described in the
<ref id="overview" name="Print Spooling Overview">,
the information in the <tt/printcap/ database is used control printing
operations.
While there is no RFC specifying its format or content,
there is a strong <it/de facto/ standard for its format.
For a complete description of the <tt/printcap/ database see
<ref name="Using the Printcap Database" id="printcapref">.
For a list of all of the <tt/printcap/ and configuration options see
<ref id="index" name="Index To All The Configuration and Printcap Options">.
<p>
Here is a sample printcap suitable for use by the LPRng clients:
<tscreen>
<verb>
# LPRng
lp:lp=psqueue@printserver.astart.com
# Classical BSD
lp:rp=psqueue:rm=printserver.astart.com
</verb>
</tscreen>
<p>
The printcap information tells the <it/client/ programs
that jobs for the <tt/lp/ printer
are sent to the
<tt/psqueue/ print queue queue on host <tt/printerserver.astart.com/.
The classical BSD printcap is also shown.
The <tt/rp/ value is the <it/remote printer/ (actually a spool queue)
and the <tt/rm/ value is the server.
When both
<tt>lp</tt> and the
<tt>rp/rm</tt> are present the <tt/lp/ value has precedence.
<p>
On the printserver
the following is a sample printcap entry
suitable for the <tt/lpd/ server:
<tscreen>
<verb>
psqueue:server
  :lp=/dev/lp0
  :sd=/var/spool/lpd/psqueue
  :if=/usr/local/libexec/filters/ifhp
</verb>
</tscreen>
<p>
The <tt/sd/ (spool queue directory) entry specifies the directory where
print jobs received from the <tt/lpr/ program will be placed.
The <tt/lp/ value is the output device
the <tt/lpd/ server will use to print the job.
The <tt/if/ (input file filter) is a program that
translates the input file to a format compatible with the printer.
If there is not need for a conversion filter then
this entry is left out.
<sect1>Print Server Configuration
<p>
The previous sections have given a very high level view of printing
operations.
In order to do printing the following programs and information must
be established:
<enum>
<item>
The printer itself,
and the interface to the printer.
<item>
Client programs for use by users or other programs to send jobs
to the print server and perform administrative functions.
<item>
A server program that runs on a host that accepts jobs for printing.
<item>
Printcap information to control the printing operations.
<item>
Filters that convert print jobs into formats compatible with printers.
<item>
System facilities such as spool queues or storage areas for jobs.
</enum>
<p>
The following sections will cover each of these topics in turn.
The initial sections assume that most users are setting up printers
on small systems and require an extremely simple print capability.
Later sections explore the various configurations that can be used
to support large networks of print spoolers as would be found in
large academic institutions or businesses.
<sect1>Tutorial Configuration
<p>
In order to simplify operation and not waste lots of paper,
we will use a very simple printcap entry during this tutorial.
During the tutorial we will also show how to modify the printcap
to add additional capabilities.
You should run these tests as a nonprivileged (non-ROOT) user
except where specifically noted.
<p>
By default,
the LPRng system uses the printcap file in
<tt>/etc/printcap</tt>
or
<tt>/usr/local/etc/printcap</tt>.
Save the existing file and then create a new printcap file
as shown below.
<tscreen>
<verb>
#  -- obtain root permissions.  You will need to entry the password
su
cd /etc    OR    cd /usr/local/etc
mv printcap printcap.orig
vi printcap
#  -- put the following lines into the printcap file:
lp:sd=/var/spool/lpd/%P
  :force_localhost
  :lp=/var/tmp/lp
lp2:sd=/var/spool/lpd/%P
  :force_localhost
  :lp=/var/tmp/lp2
#  -- save the printcap file and set permissions so programs
#     can read it
chmod 644 printcap
</verb>
</tscreen>
<p>
First,
we use the <tt/su/ command to get SuperUser (ROOT) privileges.
We then save the original printcap  file,
and create a new simple one.
<p>
This printcap file has two entries: <tt/lp/ and <tt/lp2/.
Each print queue on the server needs a spool file to hold print jobs,
jobs,
and the <tt/:sd/ value specifies its location.
The <tt/%P/ value is replaced with the name of the printer
when it is used.
<p>
The <tt/force_localhost/
is a very powerful option used by LPRng to provide
<it>classical BSD</it>
or
<it>lightweight</it>
operation.
In classical BSD operation
each host has an <tt/lpd/ print spooler running on the local host
(we use localhost in this manual for simplicity).
Files were copied to spool directories on the localhost and then then
print spooler would send them to the destination,
which could be another print spooler.
This meant that each localhost machine had to have a print spooler
and spool queue directory structure.
Management of this becomes very difficult in large organizations.
<p>
The LPRng <it>lightweight</it> operation allows the client programs
to communicate directly with an <tt/lpd/ server that is not
running on the localhost.
While this would appear to be the most desirable default mode of
operation,
it turns out in practice that all existing UNIX documentation
for print spooler configuration
assumes the
<it>classical BSD</it>
configuration.
When the behavior of LPRng is different
new users become extremely frustrated.
In this tutorial we will show how to use both
modes and the advantages and disadvantages of both modes.
<p>
The print device (<tt/:lp=/) will be a file
so that we can see what is happening during these tests
(and also to save trees).
<tscreen>
<verb>
#  -- create the dummy printing devices
cp /dev/null /var/tmp/lp
cp /dev/null /var/tmp/lp2
chown daemon /var/tmp/lp /var/tmp/lp2
chgrp daemon /var/tmp/lp /var/tmp/lp2
#  we want to read and write the dummy device
chmod 666  /var/tmp/lp /var/tmp/lp2
echo hi >/tmp/hi
echo there >/tmp/there
</verb>
</tscreen>
<p>
Next we create the files that will act as our printing devices.
We give them world read and write permissions so we can observe their
contents.
We also create a couple of files containing some information to
print.
<tscreen>
<verb>
#  we modify the lpd.perms to allow an ordinary user to control
#  the print queues
mv lpd.perms lpd.perms.orig
vi lpd.perms
# put the following into the lpd.perms file:
DEFAULT ACCEPT
</verb>
</tscreen>
<p>
The next set of commands
creates a permissions database that will allow all actions by default.
This is useful for testing,
but dangerous in a working environment.
<tscreen>
<verb>
#  -- checkpc create directories and files for the print queue
#     as well as make sure permissions are correct
checkpc -f -V
# -- output will contain information similar to:
#  Checking printer 'lp'
#   Checking directory: '/var/spool/lp'
#     directory '/var'
#     directory '/var/spool'
#     directory '/var/spool/lp'
#  Warning -   changing ownership '/var/spool/lp' to 1/1
#    checking 'control.lp' file
#    checking 'status.lp' file
#    checking 'status' file
#    cleaning 'status' file, 0K bytes: no truncation
#    checking 'log' file
#    cleaning 'log' file, 0K bytes: no truncation
#    checking 'acct' file
#    cleaning 'acct' file, 0K bytes: no truncation
#  Checking printer 'lp2'
#   Checking directory: '/var/spool/lp2'
#     directory '/var'
#   ....

#  -- signal the lpd server to use the new configuration
lpc reread

#  -- if no server was running you can start the server
lpd

#  -- do the next steps as ordinary user
#     we first exit from su
exit
#  -- check to see if the server is active and the queue is
#     present
lpq
#  example of output:
#  Printer: lp@h4
#    Queue: no printable jobs in queue
#  -- check to see that the reread command is accepted
lpc reread
</verb>
</tscreen>
<p>
The
<tt><ref id="checkpc" name="checkpc"></tt>
performs consistency checks on the printcap file and spool queue entries.
The
<tt/checkpc -f/ (fix) option will change permissions and create
directories and can only be executed by ROOT.
The
<tt><ref id="checkpc" name="checkpc"></tt>
has other functions as well - you can view printcap information,
see default configuration values,
and
remove junk files from spool queues with it.
<p>
The <tt/lpc reread/
command sends a request to the LPD server to reread the configuration
and printcap information.
The <tt/lpd/ command is added as insurance in case your <tt/lpd/
server is not running.
The <tt/exit/ command restores ordinary user privileges,
and the <tt/lpq/ command is used to check that the server is running.
Finally,
we check to see that the <tt/lpc reread/ command is accepted
from an ordinary user.
<sect1>Restoring Original Configuration
<p>
To restore the original configuration,
you simply need to restore the original <tt/printcap/
and <tt/lpd.perms/ file and then restart the <tt/lpd/ server.
<tscreen>
<verb>
<tscreen>
<verb>
#  -- obtain root permissions.  You will need to entry the password
su
cd /etc    OR    cd /usr/local/etc
mv printcap.orig printcap
mv lpd.perms.orig lpd.perms
checkpc -f
lpc reread
rm -rf /var/spool/lpd/lp /var/spool/lpd/lp2
rm -f /var/tmp/lp /var/tmp/lp2
exit
</verb>
</tscreen>
<sect1> Printing a File and Checking Status
<p>
Try the following commands.  The commands appear after the prompt,
and sample output that you might see is shown.
<tscreen>
<verb>
h4: {168} % lpr -V /tmp/hi
Version LPRng-3.6.14
sending job 'papowell@h4+238' to lp@localhost
connecting to 'localhost', attempt 1
connected to 'localhost'
requesting printer lp@localhost
sending control file 'cfA238h4.private' to lp@localhost
completed sending 'cfA238h4.private' to lp@localhost
sending data file 'dfA238h4.private' to lp@localhost
completed sending 'dfA238h4.private' to lp@localhost
done job 'papowell@h4+238' transfer to lp@localhost
</verb>
</tscreen>
<p>
The <tt/lpr -V/ (Verbose) option causes LPR to print
status output.
As you can see from the above lines,
it first tries to connect to the <tt/lpd/ server on host
<tt/localhost/,
then sends a print prequest (which is accepted),
then sends a <it/control/ file
containing information about the job
and a <tt/data/ file or files which are copies of the files to be
printed.
<p>
If you check the <tt>/var/tmp/lp</tt> file
and you will find that a copy of <tt>/tmp/hi</tt>
has been written to it.
By default,
the <tt/lpd/ print spooler acts as a store and forward system,
accepting files to be printed,
holding them in the print queue,
and then forwarding them to the destination system or output device.
<p>
You can use the <tt/lpq/ command to view the status of the print job.
<tscreen>
<verb>
h4: {169} % lpq
Printer: lp@h4
 Queue: no printable jobs in queue
 Status: job 'papowell@h4+238' removed at 09:39:03.256
</verb>
</tscreen>
<p>
If you want to see more status information,
use <tt/lpq -l/, <tt/lpq -ll/, or even <tt/lpq -L/.
The <tt/-L/ provides <tt/alL/ the status.
<tscreen>
<verb>
h4: {170} % lpq -l
Printer: lp@h4
 Queue: no printable jobs in queue
 Status: lp@h4.private: job 'papowell@h4+238' printed at 09:39:03.112
 Status: job 'papowell@h4+238' removed at 09:39:03.256
h4: {171} % lpq -ll
Printer: lp@h4
 Queue: no printable jobs in queue
 Status: finished 'papowell@h4+238', status 'JSUCC' at 09:39:03.108
 Status: subserver pid 8240 exit status 'JSUCC' at 09:39:03.110
 Status: lp@h4.private: job 'papowell@h4+238' printed at 09:39:03.112
 Status: job 'papowell@h4+238' removed at 09:39:03.256
h4: {172} % lpq -L
Printer: lp@h4
 Queue: no printable jobs in queue
 Status: subserver pid 8240 starting at 09:39:03.105
 Status: accounting at start at 09:39:03.105
 Status: opening device '/var/tmp/lp' at 09:39:03.105
 Status: printing job 'papowell@h4+238' at 09:39:03.106
 Status: no banner at 09:39:03.107
 Status: printing data file 'dfA238h4.private', size 3 at 09:39:03.107
 Status: printing done 'papowell@h4+238' at 09:39:03.107
 Status: accounting at end at 09:39:03.108
 Status: finished 'papowell@h4+238', status 'JSUCC' at 09:39:03.108
 Status: subserver pid 8240 exit status 'JSUCC' at 09:39:03.110
 Status: lp@h4.private: job 'papowell@h4+238' printed at 09:39:03.112
 Status: job 'papowell@h4+238' removed at 09:39:03.256
</verb>
</tscreen>
<p>
There are different status formats available as well.
The <tt/lpq -s/ (summary) produces a single line of status per spool queue,
while the <tt/lpq -v/ (verbose)
produces output that is very suitable for processing with
programs such as <tt/Perl/ or <tt/awk/:
<tscreen>
<verb>
h4: {173} % lpq -s
lp@h4  0 jobs
h4: {174} % lpq -v
Printer: lp@h4
 Printing: no
 Aborted: no
 Spooling: no
 Queue: no printable jobs in queue
 SPOOLCONTROL=
 Status: subserver pid 8240 starting at 09:39:03.105
 Status: accounting at start at 09:39:03.105
 Status: opening device '/var/tmp/lp' at 09:39:03.105
 Status: printing job 'papowell@h4+238' at 09:39:03.106
 Status: no banner at 09:39:03.107
 Status: printing data file 'dfA238h4.private', size 3 at 09:39:03.107
 Status: printing done 'papowell@h4+238' at 09:39:03.107
 Status: accounting at end at 09:39:03.108
 Status: finished 'papowell@h4+238', status 'JSUCC' at 09:39:03.108
 Status: subserver pid 8240 exit status 'JSUCC' at 09:39:03.110
 Status: lp@h4.private: job 'papowell@h4+238' printed at 09:39:03.112
 Status: job 'papowell@h4+238' removed at 09:39:03.256
</verb>
</tscreen>
<p>
If you check the <tt>/var/tmp/lp</tt> file
and you will find that a copy of <tt>/tmp/hi</tt>
has been written to it.
By default,
the <tt/lpd/ print spooler acts as a store and forward system,
accepting files to be printed,
holding them in the print queue,
and then forwarding them to the destination system or output device.
<sect1>Selecting the Print Queue
<p>
In the previous section we used the <tt/default/ print queue.
How does LPRng determine what print queue to use?
First,
you can explicitly specify the printer using the  <tt/lpq -Pprintqueue/
option
and the <tt/lpq -a/ or <tt/lpq -Pall/ to select all print queues:
<tscreen>
<verb>
h4: {160} % lpq -Plp
Printer: lp@h4
 Queue: no printable jobs in queue
h4: {161} % lpq -Plp2
Printer: lp2@h4
 Queue: no printable jobs in queue
h4: {162} % lpq -a
Printer: lp@h4
 Queue: no printable jobs in queue
Printer: lp2@h4
 Queue: no printable jobs in queue
</verb>
</tscreen>
<p>
You can combine the <tt/lpq -a/ with the <tt/lpq -s/ option for a summary listing:
<tscreen>
<verb>
h4: {162} % lpq -a
Printer: lp@h4
 Queue: no printable jobs in queue
Printer: lp2@h4
 Queue: no printable jobs in queue
h4: {163} % lpq -s -a
lp@h4  0 jobs
lp2@h4  0 jobs
</verb>
</tscreen>
<p>
There is another way to explicitly specify the printqueues
listed by <tt/lpq -a/;
see the
<ref id="allpc" name="ALL Printcap Entry">
for details.
<p>
Users can set their default printer by using the
<tt/PRINTER/ (highest priority),
<tt/LPDEST/ (next),
and
<tt/NGPRINTER/ (lowest priority),
environment variables.
For example:
<tscreen>
<verb>
h4: {164} % setenv PRINTER lp2
h4: {165} % lpq
Printer: lp2@h4
 Queue: no printable jobs in queue
h4: {164} % unsetenv PRINTER
h4: {165} % lpq
Printer: lp@h4
 Queue: no printable jobs in queue
</verb>
</tscreen>
<p>
Finally,
if you do not use the <tt/-P printqueue/ or have an environment variable set,
then the default printer chosen by the system administrator will be used.
Please see
<ref id="printerenv" name="Printer Name and Server IP Address">
for details.
<sect1>Controlling the Print Queue
<p>
You can control the input and output functions of the print queue.
The
<tt/lpc enable/ and
<tt/lpc disable/ commands
control spooling to the print queue and the
<tt/lpc stop/ and
<tt/lpc start/ commands
control printing (or transfers) from the print queue.
There is also a <tt/lpc status/
command that displays administrative status for a print queue.
<p>
Let's look at the status displayed when we use these commands:
<tscreen>
<verb>
h4: {30} % lpc disable
Printer: lp@h4
lp@h4.private: disabled
h4: {31} % lpq
Printer: lp@h4  (spooling disabled)
 Queue: no printable jobs in queue
h4: {32} % lpc enable
Printer: lp@h4
lp@h4.private: enabled
h4: {33} % lpq
Printer: lp@h4
 Queue: no printable jobs in queue
h4: {34} % lpc stop
Printer: lp@h4
lp@h4.private: stopped
h4: {35} % lpq
Printer: lp@h4  (printing disabled)
 Queue: no printable jobs in queue
h4: {36} % lpc start
Printer: lp@h4
lp@h4.private: started
h4: {37} % lpq
Printer: lp@h4
 Queue: no printable jobs in queue
h4: {38} % lpc status
 Printer           Printing Spooling Jobs  Server Subserver Redirect Status/(Debug)
lp@h4               enabled  enabled    0    none    none
</verb>
</tscreen>
<p>
Let's see what happens when we print to a stopped queue:
<tscreen>
<verb>
h4: {79} % lpc stop
Printer: lp@h4
lp@h4.private: stopped
h4: {80} % lpr /tmp/hi
h4: {81} % lpr /tmp/hi /tmp/there
h4: {82} % lpq
Printer: lp@h4  (printing disabled)
 Queue: 2 printable jobs
 Server: no server active
 Rank   Owner/ID                  Class Job Files                 Size Time
1      papowell@h4+17920            A 17920 /tmp/hi                 3 18:14:22
2      papowell@h4+17922            A 17922 /tmp/hi,/tmp/there      9 18:14:30
h4: {83} % lpc status
 Printer           Printing Spooling Jobs  Server Subserver Redirect Status/(Debug)
lp@h4               disable  enabled    2    none    none
</verb>
</tscreen>
<p>
The status shows that we have two jobs spooled.
The <tt/Rank/ field shows the order,
the <tt>Owner/ID</tt> shows the unique job ID that is assigned to the
job
and
the <tt/Class/ field is the job class (this may be changed with the <tt/lpr -C class/
option).
The <tt/Job/ field shows the <it/job number/ assigned to this job in this
particular spool queue.
While the <tt/ID/ value never changes as a job moves through the LPRng system,
the <it/job number/ is specific to a particular spool queue and may change
if a job is <it/forwarded/ to another spool queue that has a job with the
same job number.
The <tt/Size/ field is the total number of printable bytes in the job,
and the <tt/Time/ field shows the timestamp associated with the job.
<p>
The <tt/lpq -s/ output is very succinct, and does not show the state of the spool queue:
<tscreen>
<verb>
h4: {51} % lpq -s
lp@h4  2 jobs
</verb>
</tscreen>
<p>
Now let's start the print queue and watch what happens.
<tscreen>
<verb>
h4: {83} % lpc start
Printer: lp@h4
lp@h4.private: started
h4: {84} % lpq
Printer: lp@h4
 Queue: 2 printable jobs
 Server: pid 17928 active
 Unspooler: pid 17929 active
 Status: opening device '/var/tmp/lp' at 18:14:43.921
 Rank   Owner/ID                  Class Job Files                 Size Time
active papowell@h4+17920            A 17920 /tmp/hi                 3 18:14:22
2      papowell@h4+17922            A 17922 /tmp/hi,/tmp/there      9 18:14:30
h4: {85} % lpq -ll
Printer: lp@h4
 Queue: 2 printable jobs
 Server: pid 17928 active
 Unspooler: pid 17929 active
 Status: printing job 'papowell@h4+17920' at 18:14:43.921
 Status: no banner at 18:14:43.921
 Status: printing data file 'dfA017920h4.private', size 57 at 18:14:43.922
 Rank   Owner/ID                  Class Job Files                 Size Time
active papowell@h4+17920            A 17920 /tmp/hi                 3 18:14:22
2      papowell@h4+17922            A 17922 /tmp/hi,/tmp/there      9 18:14:30
</verb>
</tscreen>
<p>
The <tt/Rank/ value of the first job has been changed to <tt/active/
and there is new <tt/Status/
information.
If we use <tt/lpq -ll/  we can see the times that the various print operations
are carried out,
and details of their success or failure.
<p>
We can also use the <tt/lpq/ command to see the status of a particular job.
We can select jobs by the user name, the ID, or the job number.
For example:
<tscreen>
<verb>
h4: {88} % lpc stop
Printer: lp@h4
lp@h4.private: stopped
h4: {89} % echo hi |lpr
h4: {90} % echo there | lpr
h4: {91} % echo test |lpr
h4: {92} % lpq
Printer: lp@h4  (printing disabled)
 Queue: 3 printable jobs
 Server: no server active
 Status: job 'papowell@h4+17922' removed at 18:15:13.981
 Rank   Owner/ID                  Class Job Files                 Size Time
1      papowell@h4+17959            A 17959 (stdin)                  3 18:23:24
2      papowell@h4+17962            A 17962 (stdin)                  6 18:23:30
3      papowell@h4+17970            A 17970 (stdin)                  5 18:23:35
h4: {93} % lpq 17970
Printer: lp@h4  (printing disabled)
 Queue: 3 printable jobs
 Server: no server active
 Status: job 'papowell@h4+17922' removed at 18:15:13.981
 Rank   Owner/ID                  Class Job Files                 Size Time
3      papowell@h4+17970            A 17970 (stdin)                  5 18:23:35
h4: {94} % lpq papowell
Printer: lp@h4  (printing disabled)
 Queue: 3 printable jobs
 Server: no server active
 Status: job 'papowell@h4+17922' removed at 18:15:13.981
 Rank   Owner/ID                  Class Job Files                 Size Time
1      papowell@h4+17959            A 17959 (stdin)                  3 18:23:24
2      papowell@h4+17962            A 17962 (stdin)                  6 18:23:30
3      papowell@h4+17970            A 17970 (stdin)                  5 18:23:35
h4: {94} % lpq -s 17970
lp@h4  1 jobs
h4: {95} % lpq -s papowell
lp@h4  3 jobs
h4: {96} % lpq -s nobody
lp@h4  0 jobs
</verb>
</tscreen>
<p>
Just as we used the <tt/lpq -Pqueuename/ to select a specific
print queue,
and the <tt/lpq -a/ or <tt/lpq -Pall/ to select all queues:
<tscreen>
<verb>
h4: {167} % lpc -a stop
Printer: lp@h4
lp@h4.private: stopped
Printer: lp2@h4
lp2@h4.private: stopped
h4: {168} % lpc -Pall start
Printer: lp@h4
lp@h4.private: started
Printer: lp2@h4
lp2@h4.private: started
</verb>
</tscreen>
<p>
Finally,
you can use the <tt/lpc/ command in <it/interactive/ mode:
<tscreen>
<verb>
h4: {170} % lpc
lpc>status
 Printer           Printing Spooling Jobs  Server Subserver Redirect Status/(Debug)
lp@h4               enabled  enabled    0    none    none
lpc>status all
 Printer           Printing Spooling Jobs  Server Subserver Redirect Status/(Debug)
lp@h4               enabled  enabled    0    none    none
lp2@h4              enabled  enabled    0    none    none
lpc>stop lp
Printer: lp@h4
lp@h4.private: stopped
lpc>start lp
Printer: lp@h4
lp@h4.private: started
lpc>quit
</verb>
</tscreen>
<p>
In the interactive or <it/extended/ command mode,
command syntax has the form <bf/operation/ <bf/[/<it/printqueue/<bf/]/ <it/operands/.
This syntax can also be used on command lines,
but is less common:
<tscreen>
<verb>
h4: {171} % lpc stop all
Printer: lp@h4
lp@h4.private: stopped
Printer: lp2@h4
lp2@h4.private: stopped
</verb>
</tscreen>
<sect1>Job Removal
<p>
Occasionally we print a file
and then change our mind and want to cancel the job.
The <tt/lprm/ command allows us to do this.
<tscreen>
<verb>
h4: {126} % lpq
Printer: lp@h4  (printing disabled)
 Queue: 3 printable jobs
 Server: no server active
 Status: job 'papowell@h4+17922' removed at 18:15:13.981
 Rank   Owner/ID                  Class Job Files                 Size Time
1      papowell@h4+17959            A 17959 (stdin)                  3 18:23:24
2      papowell@h4+17962            A 17962 (stdin)                  6 18:23:30
3      papowell@h4+17970            A 17970 (stdin)                  5 18:23:35
h4: {127} % lprm
Printer lp@h4:
  checking perms 'papowell@h4+17959'
  dequeued 'papowell@h4+17959'
h4: {128} % lpq
Printer: lp@h4  (printing disabled)
 Queue: 2 printable jobs
 Server: no server active
 Status: job 'papowell@h4+17922' removed at 18:15:13.981
 Rank   Owner/ID                  Class Job Files                 Size Time
1      papowell@h4+17962            A 17962 (stdin)                  6 18:23:30
2      papowell@h4+17970            A 17970 (stdin)                  5 18:23:35
h4: {129} % lprm 17970
Printer lp@h4:
  checking perms 'papowell@h4+17970'
  dequeued 'papowell@h4+17970'
h4: {130} % lpq
Printer: lp@h4  (printing disabled)
 Queue: 1 printable job
 Server: no server active
 Status: job 'papowell@h4+17922' removed at 18:15:13.981
 Rank   Owner/ID                  Class Job Files                 Size Time
1      papowell@h4+17962            A 17962 (stdin)                  6 18:23:30
</verb>
</tscreen>
<p>By default,
the <tt/lprm/
command removes the first job in the queue that the user has permission to
remove.
Also,
as shown in the example,
you can remove a job by specifying the job ID or the job number.
If you specify a user name,
you remove <bf>all</bf> of the user's jobs.
This can be dangerous:
<tscreen>
<verb>
h4: {137} % lpq
Printer: lp@h4  (printing disabled)
 Queue: 3 printable jobs
 Server: no server active
 Status: job 'papowell@h4+17922' removed at 18:15:13.981
 Rank   Owner/ID                  Class Job Files                 Size Time
1      papowell@h4+17962            A 17962 (stdin)                  6 18:23:30
2      papowell@h4+18499            A 18499 /tmp/hi                  3 18:56:00
3      papowell@h4+18501            A 18501 /tmp/there               6 18:56:02
h4: {138} % lprm papowell
Printer lp@h4:
  checking perms 'papowell@h4+17962'
  dequeued 'papowell@h4+17962'
  checking perms 'papowell@h4+18499'
  dequeued 'papowell@h4+18499'
  checking perms 'papowell@h4+18501'
  dequeued 'papowell@h4+18501'
h4: {139} % lpq
Printer: lp@h4  (printing disabled)
 Queue: no printable jobs in queue
 Status: job 'papowell@h4+17922' removed at 18:15:13.981
</verb>
</tscreen>
<p>
The special user <tt/all/ matches all jobs in a print queue.
Clearly you should be careful not to specify <tt/lprm all/ by accident.
Even more dangerous is the following command:
<tscreen>
<verb>
h4: {139} % lprm -a all
</verb>
</tscreen>
<p>
As you might surmise,
this removes <bf/all/ print jobs in <bf/all/ queues,
which is an excellent way to purge print queues of all jobs.
<sect1>Basic Filter Configuration
<p>
A printer usually understands one or more
<it>Print Job Languages</it>.
Files sent to this printer must be in one of these languages
and have the appropriate
<it/job format/,
<it/control characters/,
or other information.
The most common Print Job Languages are
<ref id="postscript" name="PostScript">
and
<ref id="pcl" name="PCL">.
<p>
In order for a printer to reliably print a job,
it needs to be reset to a known configuration.
This is usually done by sending it a special
<it/start of job/
and
<it/end of job/
command.
These commands differ from printer to printer,
and even depend on the type of print job language that the print
job is in.
Some <it/vintage/ line printers also have a set of
proprietary <it/escape sequences/
that are used to set up margins,
form size,
and other printing characteristics.
Usually a
<it/setup string/
of these escape sequences needs to be sent to the printer before
the file can be printed.
<p>
In order to handle these problems,
the LPRng system uses a <tt/filter/
program to provide the set of escape sequences or carry
out the initialization required for a printer.
The files in a print job are assigned a
lower case letter
<it>format</it>
using the <tt/lpr/ format options;
the de<tt/f/ault format is <tt/f/.
The <tt/l/ (literal or binary) format is used to indicate
that the file should be passed directly to the printer,
or have at the most a minimal amount of processing.
See
<ref id="printjobformats" name="Print Job Formats">
for more information about formats and their use with filters.
<p>
We will set up a very simple filter and use it to demonstrate
how the <tt/lpd/ spooler uses it.
First,
set up the <tt>/var/tmp/testf</tt> file as shown below.
<tscreen>
<verb>
#!/bin/sh
# /var/tmp/testf - test filter for LPRng
PATH=/bin:/usr/bin
echo TESTF $0 "$@" >&2
while expr "$1" : '-.*' >/dev/null ;  do
    n=` expr $1 : '-\(.\).*' `;
    v=` expr $1 : '-.\(.*\)' `;
    shift;
    if [ "$n" != 'c' -a -z "$v" ] ; then
        v=$1;
        shift;
    fi
    eval "$n='$v'";
done
echo ENV
printenv
echo LEADER
/bin/cat
echo TRAILER
exit 0
</verb>
</tscreen>
<p>
Let us carefully examine the script line by line.
The first couple of lines are standard <it/boilerplate/.
You should
<bf>always</bf>
set the <tt/PATH/
value in a filter script or use full pathnames.
This is a good practice
as it ensures that only the specified directories will be
searched for commands.
<p>
The next line echos the arguments to file descriptor 2 (STDERR);
by convention the filter STDERR output is used for error messages
or important status information.
We will soon see how this information is displayed by the LPRng software.
<p>
The <tt/while/ loop is used to extract the option flags and their values.
All of these but the <tt/c/ flag have an argument.
Finally we echo <tt/LEADER/ to STDOUT,
then copy STDIN to STDOUT,
and then echo <tt/TRAILER/ to STDOUT.
We then exit with a zero result code.
<p>
Now execute the commands below to test the script:
<tscreen>
<verb>
h4: {50} % chmod 755 /var/tmp/testf
h4: {51} % echo hi |/var/tmp/testf -a1
TESTF /var/tmp/testf -a1
LEADER
hi
TRAILER
</verb>
</tscreen>
<p>
Let us put this filter into one of our printcap entries.
Edit the <tt/lp/ printcap entry so it has the following form,
use <tt/checkpc -f/ to check the printcap,
and then use <tt/lpc reread/ to restart the <tt/lpd/ server
as we did in previous exercises.
<tscreen>
<verb>
lp:sd=/var/spool/lpd/%P
  :force_localhost
  :lp=/var/tmp/lp
  :if=/var/tmp/testf
</verb>
</tscreen>
<p>
Execute the following commands
to print our <tt>/tmp/hi</tt> test file file
and see what changes have occurred in the printing process:
<tscreen>
<verb>
h4: {47} % cp /dev/null /var/tmp/lp
h4: {48} % lpr /tmp/hi
h4: {49} % lpq -llll
Printer: lp@h4
 Queue: no printable jobs in queue
 Status: lp@h4.private: job 'papowell@h4+26593' printed at 21:37:21.312
 Status: job 'papowell@h4+26593' removed at 21:37:21.323
 Status: subserver pid 26683 starting at 21:39:21.908
 Status: accounting at start at 21:39:21.908
 Status: opening device '/var/tmp/lp' at 21:39:21.909
 Status: printing job 'papowell@h4+26681' at 21:39:21.909
 Status: no banner at 21:39:21.909
 Status: printing data file 'dfA026681h4.private', size 3, IF filter 'testf' at
21:39:21.909
 Status: IF filter msg - 'TESTF /var/tmp/testf -Apapowell@h4+26681 -CA -D2000-04
-11-21:39:21.877 -Ff -Hh4.private -J/tmp/hi -Lpapowell -Plp -Qlp -aacct -b3 -d/v
ar/tmp/LPD/lp -edfA026681h4.private -f/tmp/hi -hh4.private -j026681 -kcfA026681h
4.private -l66 -npapowell -sstatus -t2000-04-11-21:39:21.000 -w80 -x0 -y0 acct'
at 21:39:21.914
 Status: IF filter finished at 21:39:22.070
 Status: printing done 'papowell@h4+26681' at 21:39:22.070
 Status: accounting at end at 21:39:22.070
 Status: finished 'papowell@h4+26681', status 'JSUCC' at 21:39:22.070
 Status: subserver pid 26683 exit status 'JSUCC' at 21:39:22.072
 Status: lp@h4.private: job 'papowell@h4+26681' printed at 21:39:22.072
 Status: job 'papowell@h4+26681' removed at 21:39:22.085
</verb>
</tscreen>
<p>
The <tt/cp/ command will clear out the <tt>/var/tmp/lp</tt>
file we are using as a dummy output device.
Next we use <tt/lpr/ to print the <tt>/tmp/hi</tt> file
and then use <tt/lpq -llll/ to see the status information.
If we look at the status,
we see that
the line containing <tt/IF filter msg/ is the output that
<tt/testf/ wrote to STDERR.
The <tt/lpd/ server captures filter STDERR
messages and puts it them in the spool queue status file.
As we see from the message,
<tt/lpd/
passes a large number of command line options to our filter.
These options and their meanings are discussed in detail in
<ref id="filtercmd" name="Filter Command Line Flags">,
but for now we will ignore them.
<p>
Sometimes we want to pass only a small subset of these options,
or provide them in a specific manner.
Modify the printcap entry to have the following form:
<tscreen>
<verb>
lp:sd=/var/spool/lpd/%P
  :force_localhost
  :lp=/var/tmp/lp
  :if= -$ /var/tmp/testf '$P' $0P -X$-P ${lp} G$%3a
</verb>
</tscreen>
<p>
If you redo the previous commands to print our test file
and examine the status,
you will discover that the options now are:
<tscreen>
<verb>
 Status: IF filter msg - 'TESTF /var/tmp/testf -Plp -P lp -Xlp \
    -Ylp /var/tmp/lp G:' at 01:20:21.560
</verb>
</tscreen>
<p>
The <tt/-$/ suppresses appending the default options to the end
of the filter command line.
You can add specific options using the <tt/$X/ format;
if the option has a non-null value then it will be expanded in the following
format:
<tscreen>
<verb>
Option    Value Expansion
$X        -X<value>
$0X       -X <value>
$-X          <value>
${name}   printcap option value
$%XX      character corresponding to 0xXX
</verb>
</tscreen>
<p>
You can group options and other values using single
or double quotes.
These are used only for grouping and will be removed
when the command is executed.
<p>
The <tt/${name}/ format is very handy for passing a filter
an option value which is set in the printcap.
For example,
you may decide to create a new printcap option called <tt/form/,
which will set the form type to be used with this spool queue.
You can pass it to the filter
which will then generate the necessary control codes for the printer
to set the form.
For example:
<tscreen>
<verb>
Example 1:
lp:sd=/var/spool/lpd/%P
  :force_localhost
  :lp=/var/tmp/lp
  :if=-$ /var/tmp/testf -F${form},
  :form=payroll
....
 Status: IF filter msg - 'TESTF /var/tmp/testf -Fpayroll, ' at 01:20:21.560
....

Example 2:
lp:sd=/var/spool/lpd/%P
  :force_localhost
  :lp=/var/tmp/lp
  :if=-$ /var/tmp/testf -F '${form}'
  :form=
....
 Status: IF filter msg - 'TESTF /var/tmp/testf -F, ' at 01:20:21.560
....
</verb>
</tscreen>
<p>
In the second example the <tt/form/
printcap option has a null value,
which is expanded to a empty string.
Notice that we have added a comma at the end of the parameter;
this will protect the parsing of command line options from failure
if the form value is null.
Clearly the <tt/testf/ filter must be ready to deal with
a comma at the end of the <tt/-F/ parameter.
<p>
Now lets look at what is in the output file:
<tscreen>
<verb>
h4: {50} % cat /var/tmp/lp
ENV
LD_LIBRARY_PATH=/lib:/usr/lib:/usr/5lib:/usr/ucblib
HOME=/home/daemon
PRINTCAP_ENTRY=lp
 :force_localhost
 :if=/var/tmp/testf
 :lp=/var/tmp/lp
 :sd=/var/tmp/LPD/lp
USER=daemon
PS1=$ 
OPTIND=1
PS2=> 
SPOOL_DIR=/var/tmp/LPD/lp
LOGNAME=daemon
CONTROL=Hh4.private
 Ppapowell
 J/tmp/hi
 CA
 Lpapowell
 Apapowell@h4+105
 D2000-04-12-15:27:26.662
 Qlp
 N/tmp/hi
 fdfA000105h4.private
 UdfA000105h4.private
PATH=/bin:/usr/bin:/usr/local/bin
SHELL=/bin/sh
LOGDIR=/home/daemon
PRINTER=lp

LEADER
hi
TRAILER
</verb>
</tscreen>
<p>
The <tt/lpd/ server sets the
<tt/PRINTER/,
<tt/PRINTCAP_ENTRY/,
and
<tt/CONTROL/
environment variables to the printer name,
printcap entry, and the control file for the print job.
This information is very useful to filters that must
make decisions based on values passed to the print server
in the control file,
and which can also use parameters in the printcap entry
to control their actions.
We will see how the 
<tt/ifhp/ filter makes use of this in a later section.
<sect1>The Jaggies - LF to CR-LF Conversion With lpf
<p>
When printing to vintage hard copy devices or to
printers that support a <it>text</it> mode,
many UNIX users discover that their output suffers from
a case of the jaggies.
<tscreen>
<verb>
Input file:

  This is
  a nice day

Output:

  This is
         a nice day
</verb>
</tscreen>
<p>
UNIX systems terminate lines with a single <tt/NL/ (new line) character.
This causes the printer to move down one line on the printing page
but does not change its horizontal position
and print the next character at the left margin.
This is done by using the <tt/CR/ (carriage return) character.
You need to convert the single <tt/NL/ to a <tt/CR-LF/
combination and the <tt/lpf/ filter supplied with LPRng does this.
<p>
First,
locate the <tt/lpf/ filter.
It is usually in <tt>/usr/local/libexec/filters</tt> directory,
but this may vary from installation to installation.
You can find it by using the command:
<tscreen>
<verb>
find / -type f -name lpf -print
</verb>
</tscreen>
<p>
We will first see what the output is like without
<tt/lpf/,
and then see what it does.
Modify the <tt/lp/ printcap entry as shown below
and then use <tt/lpc restart/
to restart the <tt/lpd/ server.
<tscreen>
<verb>
lp:sd=/var/spool/lpd/%P
  :force_localhost
  :lp=/var/tmp/lp
</verb>
</tscreen>
<p>
Print a file and view the output using the following
commands.
If you do not have the <tt/od/ (octal dump) program,
try using <tt/hexdump/ or some other appropriate program
that displays the numerical contents of the file.
<tscreen>
<verb>
h4: {134} % cp /dev/null /var/tmp/lp
h4: {135} % lpr /tmp/hi
h4: {136} % od -bc /var/tmp/lp
0000000  150 151 012
           h   i  \n
0000003
</verb>
</tscreen>
<p>
Now we will use the <tt>lpf</tt> filter.
Modify the printcap as shown below
and use <tt/lpc lpd/ to restart <tt/lpd/.
<tscreen>
<verb>
lp:sd=/var/spool/lpd/%P
  :force_localhost
  :lp=/var/tmp/lp
  # modify the path to lpf appropriately
  :if=/usr/local/libexec/filters/lpf
</verb>
</tscreen>
<p>
Now reprint the file:
<tscreen>
<verb>
h4: {141} % cp /dev/null /var/tmp/lp
h4: {142} % lpr /tmp/hi
h4: {143} % od -bc /var/tmp/lp
od -bc /var/tmp/lp
0000000  150 151 015 012
           h   i  \r  \n
0000004
</verb>
</tscreen>
<p>
As you see,
<tt/lpf/ changes the LF to a <tt/CR-LF/ sequence.
<sect1>Introducing the ifhp filter
<p>
The companion
<tt/ifhp/ print filter is used with the LPRng to provide
hardware level support for PostScript, PCL, text, and other printers.
It provides diagnostic and error information as well as
accounting information.
Obtain the latest or stable version of the <tt/ifhp/ filter source code from a
<ref id="secftp" name="LPRng FTP Site">.
Normally,
<tt/ifhp/ is installed together with the LPRng software.
<p>
The
<ref id="postscript" name="PostScript">
and
<ref id="pcl" name="PCL">
printer job languages are supported by most printer manufacturers.
However,
in order to have a job printed correctly the following steps must be taken.
<itemize>
<item>
The printer must be put into a known state by sending it the appropriate
reset strings.
<item>
If accounting is being done,
then the printer accounting information must be obtained
and recorded.
See
<ref id="accountingref" name="Accounting">
for more information on LPRng support for accounting.
<item>
The file to be printed must be checked to see if it is
compatible with the printer,
and if not,
a format conversion program invoked to convert it to
the required format.
<item>
If the user selects a set of printer specific options such
as
landscape mode,
duplex printing,
multiple copies,
or
special paper,
the <tt/ifhp/ filter sends the appropriate commands to the
printer to select these options.
<item>
The file is transferred to the printer and the printer is monitored
for any error conditions.
<item>
In order to ensure that the job prints,
the required end of job commands are sent to the printer.
<item>
If accounting is being done,
the printer accounting information must be obtained
and recorded.
</itemize>
<p>
The <tt/ifhp/ filter uses the <tt/ifhp.conf/ database file
to determine the actions and commands
appropriate for various models of printers.
See the <tt/ifhp/ documentation for details about the
format and contents of this file.
The default printer used by the
<tt/ifhp/ filter is the HP LaserJet 4M Plus,
which supports PostScript,  PCL, and PJL.
These defaults will also support a very wide variety of printers
that support both PostScript and PCL.
<p>
Now we will use the <tt>ifhp</tt> filter.
Find the path to the <tt/ifhp/ filter using the
<tt/find/ command as we did in the previous exercise.
Modify the printcap as shown below
and use <tt/lpc lpd/ to restart <tt/lpd/.
<tscreen>
<verb>
lp:sd=/var/spool/lpd/%P
  :force_localhost
  :lp=/var/tmp/lp
  # modify the path to ifhp appropriately
  :if=/usr/local/libexec/filters/ifhp
</verb>
</tscreen>
<p>
Now reprint the file,
and then display <tt>/var/tmp/lp</tt>
using a text editor such as <tt/vi/ or <tt/emacs/ that shows
control characters:
<tscreen>
<verb>
h4: {141} % cp /dev/null /var/tmp/lp
h4: {142} % lpr /tmp/hi
h4: {143} % vi /var/tmp/lp
^[%-12345X@PJL
@PJL JOB NAME = "PID 405" DISPLAY = "papowell"
@PJL RDYMSG DISPLAY = "papowell"
@PJL USTATUSOFF
@PJL USTATUS JOB = ON
@PJL USTATUS DEVICE = ON
@PJL USTATUS PAGE = ON
@PJL USTATUS TIMED = 10
@PJL ENTER LANGUAGE = PCL
^&rsqb;E^&rsqb;&amp;^&rsqb;&amp;k2G^&rsqb;&amp;s0C^&rsqb;&amp;l0O^&rsqb;9^&rsqb;(s0P^&rsqb;(s10.00H^&rsqb;(s4099Thi
^&rsqb;E^&rsqb;%-12345X@PJL
@PJL RDYMSG DISPLAY = "papowell"
@PJL EOJ NAME = "PID 405"
@PJL USTATUSOFF
@PJL USTATUS JOB = ON
@PJL USTATUS DEVICE = ON
@PJL USTATUS PAGE = ON
@PJL USTATUS TIMED = 10
@PJL RDYMSG DISPLAY = ""
^[%-12345X
</verb>
</tscreen>
<p>
The output now contains all of the control sequences and setup
codes needed to print a text file on the printer.
For details on the exact meaning of each of these entries,
see the
<ref id="pcl" name="PCL">
and
<ref id="pjl" name="PJL">
documentation.
<sect1>PostScript Printer and the ifhp filter
<p>
There are some printers that only support PostScript.
We will show how to configure the <tt/ifhp/
filter to recognize this.
First,
create the <tt>/tmp/one.ps</tt> PostScript file:
<tscreen>
<verb>
%!PS-Adobe-3.0
%% one page (i.e. - a page with a 1 on it)
/Courier
findfont 200 scalefont setfont
72 300 moveto
(1) show
showpage
</verb>
</tscreen>
<p>
This PostScript file starts with the standard PostScript
header -
<tt/%!/ or the acceptible alternative
<tt/\004%!/.
If a PostScript file does not start with either of these
two character sequences,
the printer may behave in unexpected ways.
The <tt/ifhp/ filter will check to make sure that
the file starts with these sequences.
<p>
Modify the printcap as shown below
and use <tt/lpc lpd/ to restart <tt/lpd/.
<tscreen>
<verb>
lp:sd=/var/spool/lpd/%P
  :force_localhost
  :lp=/var/tmp/lp
  # modify the path to ifhp appropriately
  :ifhp=model=ps
  :if=/usr/local/libexec/filters/ifhp
</verb>
</tscreen>
<p>
Now print the file <tt>/tmp/one.ps</tt>,
and then display the output in <tt>/var/tmp/lp</tt>
using a text editor such as <tt/vi/ or <tt/emacs/ that shows
control characters:
<tscreen>
<verb>
h4: {141} % cp /dev/null /var/tmp/lp
h4: {142} % lpr /tmp/one.ps
h4: {143} % vi /var/tmp/lp
^D%!
%!PS-Adobe-3.0
%% one page (i.e. - a page with a 1 on it)
%%/Times-Roman
/Courier
findfont 200 scalefont setfont
72 300 moveto
(1) show
showpage
^D
</verb>
</tscreen>
<p>
As you can see,
the PostScript
<tt/^D/ (Control-D or <tt>\004</tt>) End of Job characters have been
prefixed and appended to the file.
This will ensure that the job will be handled properly by
the printer.
<sect1>PCL Printer and the ifhp filter
<p>
While PostScript is the most widely support Print Job Language,
there are large number of printers that support only PCL.
The <tt/ifhp/ filter has support for a PCL only printer.
<p>
Modify the printcap as shown below
and use <tt/lpc lpd/ to restart <tt/lpd/.
<tscreen>
<verb>
lp:sd=/var/spool/lpd/%P
  :force_localhost
  :lp=/var/tmp/lp
  # modify the path to ifhp appropriately
  :ifhp=model=pclonly
  :if=/usr/local/libexec/filters/ifhp
</verb>
</tscreen>
<p>
Now print the file <tt>/tmp/hi</tt>,
and then display the output in <tt>/var/tmp/lp</tt>
using a text editor such as <tt/vi/ or <tt/emacs/ that shows
control characters:
<tscreen>
<verb>
h4: {141} % cp /dev/null /var/tmp/lp
h4: {142} % lpr /tmp/hi
h4: {143} % vi /var/tmp/lp
^&rsqb;E^&rsqb;&amp;^&rsqb;&amp;k2G^&rsqb;&amp;s0C^&rsqb;&amp;l0O^&rsqb;9^&rsqb;(s0P^&rsqb;(s10.00H^&rsqb;(s4099Thi
^&rsqb;E
</verb>
</tscreen>
<p>
The output now contains the necessary PCL
start of job,
format setup,
and 
end of job sequences
needed to print on a PCL printer.
<sect1>Using GhostScript for Format Conversion
<p>
A major cost in a low end printer printer is the
microprocessor and memory which converts PCL or PostScript
to a raster image.
Most low end printers have the rasterization done on a
users computer by a <it>print driver</it> program or utility,
and then the raster image is transferred to the printer.
The raster image is usually in a proprietary format.
<p>
If you have a PostScript file and want to print it on
one of these printers then you will need to use
<ref id="ghostscript" name="GhostScript">
or a similar program to do the conversion.
The following example shows one way to use GhostScript
with LPRng and is presented for instructional purposes.
It is <bf/not/ recommended method;
please consult the <tt/ifhp/
documentation for a more robust method that
handles text files and other non-PostScript files correctly.
<p>
Suppose that we have an HP DeskJet 660C printer
and want to print PostScript files.
Enter the following command to see what devices
your version of GhostScript is configured for.
<tscreen>
<verb>
h4: {349} % gs --help
GNU Ghostscript 5.10 (1998-12-17)
Copyright (C) 1997 Aladdin Enterprises, Menlo Park, CA.  All rights reserved.
Usage: gs [switches] [file1.ps file2.ps ...]
Most frequently used switches: (you can use # in place of =)
 -dNOPAUSE           no pause after page   | -q       `quiet', fewer messages
 -g<width>x<height>  page size in pixels   | -r<res>  pixels/inch resolution
 -sDEVICE=<devname>  select device         | -dBATCH  exit after last file
 -sOutputFile=<file> select output file: - for stdout, |command for pipe,
                                         embed %d or %ld for page #
Input formats: PostScript PostScriptLevel1 PostScriptLevel2 PDF
Available devices:
   x11 x11alpha x11cmyk x11mono sxlcrt ap3250 appledmp bj10e bj200 bjc600
   bjc800 cdeskjet cdjcolor cdjmono cdj500 cdj550 cp50 declj250 deskjet
   djet500c dnj650c epson eps9mid eps9high epsonc ibmpro imagen iwhi iwlo
   iwlq jetp3852 laserjet la50 la70 la75 la75plus lbp8 lips3 ln03 lj250
   ljet2p ljet3 ljet3d ljet4 lj4dith ljetplus lp2563 m8510 necp6 oce9050
   oki182 paintjet pj pjetxl pjxl pjxl300 r4081 sj48 st800 stcolor t4693d2
   t4693d4 t4693d8 tek4696 xes dfaxhigh dfaxlow faxg3 faxg32d faxg4 tiffcrle
   tiffg3 tiffg32d tiffg4 bmpmono bmp16 bmp256 bmp16m cgmmono cgm8 cgm24 cif
   mgrmono mgrgray2 mgrgray4 mgrgray8 mgr4 mgr8 pcxmono pcxgray pcx16 pcx256
   pcx24b psmono pbm pbmraw pgm pgmraw pgnm pgnmraw pnm pnmraw ppm ppmraw
   sgirgb tifflzw tiffpack tiff12nc tiff24nc bit bitrgb bitcmyk pngmono
   pnggray png16 png256 png16m pdfwrite nullpage
Search path:
   . : /usr/share/ghostscript/5.10 :
   /usr/share/ghostscript/fonts
For more information, see /usr/share/ghostscript/5.10/doc/use.txt.
Report bugs to ghost@aladdin.com; use the form in bug-form.txt.
</verb>
</tscreen>
<p>
Next we consult the GhostScript printer support documentation
at 
<htmlurl
url="http://www.cs.wisc.edu/~ghost/printer.html"
name="http://www.cs.wisc.edu/~ghost/printer.html"
>
or the documentation shipped with the GhostScript distribution
and find that the <tt/cd550/ driver supports
a wide range of printers:
<tscreen>
<verb>
cdj550 
  HP DeskJet 550C (3.53) 
  HP DeskJet 560C (3.53) 
  HP DeskJet 600 (5.10) black (1bit/pixel) and colour (32bit/pixel) 
  HP DeskJet 660C (3.53) 
  HP DeskJet 660C (5.10) 
  HP DeskJet 682C (4.01) Use gamma=0.3 
  HP DeskJet 683C (3.33, 4.03) 
  HP DeskJet 693C (4.03) 24bit/pixel Is this a CMY or a CMYK printer?
    Probably CMYK in which case 32bit/pixel can be used. 
  HP DeskJet 694C (5.03) Works in colour. 690C, 692C, 693C and 694C
     are all software variations. 
  HP DeskJet 695C (5.50) Works in colour. 
  HP DeskJet 850 (3.53) 300dpi CMYK (32bit/pixel) See also cdj850. 
  HP DeskJet 870Cse (4.03) (16 or 32 bits/pixel) Use ljet4 device for B/W.
     See also cdj850. 
  HP DeskJet 895Cxi (5.03, 5.50) Does not work with cdj850. 
  HP DeskJet 970 (5.50) Some pages contain small black boxes,
     lines or missing characters. 
  HP OfficeJet 590 (5.50) 
  Olivetti jp450 (5.50) 
  Xerox XJ6C (5.50) 
  May work with other HP Colour DeskJet printers that use a CMYK ink cartridge.
  Any printer that works with this device will probably work in black and white
    with djet500 and cdjmono. 
</verb>
</tscreen>
<p>
Create the <tt>/tmp/testgs</tt> file with the following contents:
<tscreen>
<verb>
#!/bin/sh
# /tmp/testgs - set the path to gs (GhostScript) appropriately
exec /usr/bin/gs -q -dSAFER -dBATCH -sDEVICE=cdj550 -sOutputFile=- -
</verb>
</tscreen>
<p>
Run the following commands to convert the <tt>/tmp/one.ps</tt>
file
and view the output with a text editor:
<tscreen>
<verb>
h4: {351} % /tmp/testgs &lt;/tmp/one.ps &gt;/tmp/out.img
h4: {352} % vi /tmp/out.img
^&lsqb;*rbC^&lsqb;*t300R^&lsqb;&amp;l2aolE^&lsqb;*o1d2Q....
</verb>
</tscreen>
<p>
Modify the <tt/lp/ printcap as shown below,
and use <tt/lpc reread/ to restart the server.
<tscreen>
<verb>
lp:sd=/var/spool/lpd/%P
  :force_localhost
  :lp=/var/tmp/lp
  :if=/tmp/testgs
</verb>
</tscreen>
<p>
Print the file <tt>/tmp/one.ps</tt>,
and then display the output in <tt>/var/tmp/lp</tt>
using a text editor such as <tt/vi/ or <tt/emacs/ that shows
control characters:
<tscreen>
<verb>
h4: {141} % cp /dev/null /var/tmp/lp
h4: {142} % lpr /tmp/one.ps
h4: {143} % vi /var/tmp/lp
^&lsqb;*rbC^&lsqb;*t300R^&lsqb;&amp;l2aolE^&lsqb;*o1d2Q....
</verb>
</tscreen>
<sect1>Using Printcap Options In Filter Scripts
<p>
In the previous section we saw how to set up a
filter shell script
so that we could convert PostScript files.
We can modify this script to extract information from the
<tt/PRINTCAP/ environment variable,
and make our script much more powerful.
<p>
Modify the <tt>/tmp/testgs</tt> script from the previous
example so that it contains:
<tscreen>
<verb>
#!/bin/sh
# /tmp/testgs - set the path to gs (GhostScript) appropriately
device=`echo $PRINTCAP_ENTRY \
  |/usr/bin/sed -n 's/.*:device=\(.*\)/\1/p' `
if [ "X$device" = "X" ] ; then device=epson; fi
# print the device value for status information
echo DEVICE $device >&2
exec /usr/bin/gs -q -dSAFER -dBATCH -sDEVICE=$device -sOutputFile=- -
</verb>
</tscreen>
<p>
Modify the <tt/lp/ printcap as shown below,
and use <tt/lpc reread/ to restart the server.
<tscreen>
<verb>
lp:sd=/var/spool/lpd/%P
  :force_localhost
  :lp=/var/tmp/lp
  :if=/tmp/testgs
</verb>
</tscreen>
<p>
Print the file <tt>/tmp/one.ps</tt>,
display the <tt/lpq/ status as shown below,
and then display the output in <tt>/var/tmp/lp</tt>
using a text editor such as <tt/vi/ or <tt/emacs/ that shows
control characters:
<tscreen>
<verb>
h4: {146} % cp /dev/null /var/tmp/lp
h4: {147} % lpr /tmp/one.ps
h4: {148} % lpq
 ....
 Status: IF filter msg - 'DEVICE cdj550' at 20:31:34.386

h4: {143} % vi /var/tmp/lp
^&lsqb;*rbC^&lsqb;*t300R^&lsqb;&amp;l2aolE^&lsqb;*o1d2Q....
</verb>
</tscreen>
<p>
Using this technique you can use one <tt/filter script/
to handle a wide variety of printers.
This is essentially the method used by the
<tt/ifhp/ filter to determine the printer type.
<sect1>GhostScript and ifhp
<label id="ghostscriptconfig">
<p>
While the previous method is useful when only PostScript files
are being printed,
it is not very robust.
The <tt/ifhp/ filter provides the
<tt/ghostscript/ printer configuration
which can be used as shown below.
The <tt/ifhp/ filter will invoke GhostScript with the
indicated options
and handle errors and setup in an appropriate manner.
The <tt/a2ps/ program is used to do text to PostScript conversion
in this configuration.
<tscreen>
<verb>
lp:sd=/var/spool/lpd/%P
  :force_localhost
  :lp=/var/tmp/lp
  :ifhp=model=ghostscript,device=epson,resolution=-r240x72
  # gs ... -sDEVICE=$device $resolution ...
  :if=/usr/local/libexec/filters/ifhp
</verb>
</tscreen>
<p>
Modify the <tt/lp/ printcap as shown below,
and use <tt/lpc reread/ to restart the server.
<tscreen>
<verb>
lp:sd=/var/spool/lpd/%P
  :force_localhost
  :lp=/var/tmp/lp
  :ifhp=model=ghostscript,device=cdj550
  :if=/usr/local/libexec/filters/ifhp
</verb>
</tscreen>
<p>
Print the file <tt>/tmp/one.ps</tt>,
display the <tt/lpq/ status as shown below,
and then display the output in <tt>/var/tmp/lp</tt>
using a text editor such as <tt/vi/ or <tt/emacs/ that shows
control characters:
<tscreen>
<verb>
h4: {146} % cp /dev/null /var/tmp/lp
h4: {147} % lpr /tmp/one.ps
h4: {148} % lpq
 ....
 Filter_status: initial job type 'POSTSCRIPT' at 03:50:38.141
 Filter_status: job type 'raw', converter '/usr/bin/gs
   -dSAFER -dBATCH -q -sDEVICE=cdj550 -sOutputFile=- - ' at 03:50:38.141
 Filter_status: started converter '/usr/bin/gs
   -dSAFER -dBATCH -q -sDEVICE=cdj550 -sOutputFile=- - ' at 03:50:38.146
 Filter_status: converter done, output 1251 bytes at 03:50:38.790

h4: {143} % vi /var/tmp/lp
^&lsqb;*rbC^&lsqb;*t300R^&lsqb;&amp;l2aolE^&lsqb;*o1d2Q....
</verb>
</tscreen>
<p>
Next, print the file <tt>/tmp/hi</tt>,
display the <tt/lpq/ status as shown below,
and then display the output in <tt>/var/tmp/lp</tt>
using a text editor such as <tt/vi/ or <tt/emacs/ that shows
control characters:
<tscreen>
<verb>
h4: {146} % cp /dev/null /var/tmp/lp
h4: {147} % lpr /tmp/hi
h4: {148} % lpq
 ....
 Filter_status: job type 'raw', converter
  '/usr/bin/a2ps -q -B -1 -M Letter --borders=no -o-
  | /usr/bin/gs -dSAFER -dBATCH -q
    -sDEVICE=cdj550 -sOutputFile=- - ' at 03:52:12.423
 Filter_status: started converter
  '/usr/bin/a2ps -q -B -1 -M Letter --borders=no -o-
  | /usr/bin/gs -dSAFER -dBATCH -q
    -sDEVICE=cdj550 -sOutputFile=- - ' at 03:52:12.426
 Filter_status: converter done, output 183 bytes at 03:52:13.206


h4: {143} % vi /var/tmp/lp
^&lsqb;*rbC^&lsqb;*t300R^&lsqb;&amp;l2aolE^&lsqb;*o1d2Q....
</verb>
</tscreen>
<p>
As shown by the <tt/lpq/ status above,
the <tt/a2ps/ program was invoked to convert a text file
into PostScript,
which was then rasterized by GhostScript.
<sect>LPRng Clients - lpr, lprm, lpq, lpc, lpstat
<label id="lprngclients">
<p>
The LPRng software is a true set of client/server applications.
The LPRng clients,
<tt/lpr, lprm, lpq,/ and <tt/lpc/ connect to a <tt/lpd/ server using a
TCP/IP connection.
This means that you must have TCP/IP networking enabled on your workstation
to use LPRng.
<p>
However,
you do not need to have an external network connection to the Internet.
For most single system users,
the <tt/lpd/ server is running on the same workstation as the client program,
and the clients will simply talk to the <tt/localhost/.
<sect1> LPC Commands
<label id="lpccommands">
<p>
The
<tt/lpc/ command is the main way that the <tt/lpd/ server
is controlled.
Here is the help information displayed by the command:
<tscreen>
<verb>
h4: {186} % lpc -=
lpc: Illegal option '='
usage: lpc [-Ddebuglevel][-Pprinter][-Shost][-Uusername][-V] [command]
 with no command, reads from stdin
  -Ddebuglevel - debug level
  -Pprinter    - printer or printer@host
  -Shost       - connect to lpd server on host
  -Uuser       - identify command as coming from user
  -V           - increase information verbosity
 commands:
 active    (printer[@host])        - check for active server
 abort     (printer[@host] | all)  - stop server
 class     printer[@host] (class | off)      - show/set class printing
 disable   (printer[@host] | all)  - disable queueing
 debug     (printer[@host] | all) debugparms - set debug level for printer
 down      (printer[@host] | all)  - disable printing and queueing
 enable    (printer[@host] | all)  - enable queueing
 hold      (printer[@host] | all) (name[@host] | job | all)*   - hold job
 holdall   (printer[@host] | all)  - hold all jobs on
 kill      (printer[@host] | all)  - stop and restart server
 lpd       (printer[@host]) - get LPD PID
 lpq       (printer[@host] | all) (name[@host] | job | all)*   - invoke LPQ
 lprm      (printer[@host] | all) (name[@host]|host|job| all)* - invoke LPRM
 msg printer message text  - set status message
 move printer (user|jobid)* target - move jobs to new queue
 noholdall (printer[@host] | all)  - hold all jobs off
 printcap  (printer[@host] | all)  - report printcap values
 quit                              - exit LPC
 redirect  (printer[@host] | all) (printer@host | off )*       - redirect jobs
 redo      (printer[@host] | all) (name[@host] | job | all)*   - release job
 release   (printer[@host] | all) (name[@host] | job | all)*   - release job
 reread    (printer[@host])        - LPD reread database information
 start     (printer[@host] | all)  - start printing
 status    (printer[@host] | all)  - status of printers
 stop      (printer[@host] | all)  - stop  printing
 topq      (printer[@host] | all) (name[@host] | job | all)*   - reorder job
 up        (printer[@host] | all) - enable printing and queueing
   diagnostic:
      defaultq               - show default queue for LPD server
      defaults               - show default configuration values
      client  (printer | all) - client config and printcap information
      server (printer | all) - server config and printcap
</verb>
</tscreen>
<p>
Most of the <tt/lpc/ command line options are common to all
<ref id="lprngclients" name="LPRng Clients">,
with the exception of the <tt/-S server/ option.
This option allows the <tt/lpd/ host to be explicitly specified.
<p>
The <tt/lpc/ commands can be classified as
<it/informational/,
<it/queue management/,
<it/problem management/,
<it/job scheduling/,
and
<it/diagnostic/.
<sect2>Informational Commands - status, active, reread
<p>
Each spool queue has a
<ref id="queue_control_file" name="Spool Control File">,
and the <tt/lpc status/ command
displays selected values from this file.
<p>
The <tt/lpc active/ command connects to the print server and
gets the Process ID of the <tt/lpd/ process.
This is useful to determine if the <tt/lpd/ server is running
on the print server.
<p>
The <tt/reread/
command connects to the <tt/lpd/ print server and requests
that the server reread the
<tt/printcap/,
<tt/lpd.conf/,
and
<tt/lpd.perms/ database files.
<sect2>Queue Management - enable, disable, up, down
<p>
The <tt/enable/ and <tt/disable/
commands enable and disable <it/queuing/ or sending jobs to the
print queue.
The <tt/up/ command combines the <tt/enable/ and <tt/start/ commands
while
the <tt/down/ command combines the <tt/disable/ and <tt/stop/ commands.
<sect2>Printing Management - start, stop, up, down
<p>
These commands are used to start and stop printing.
The <tt/up/ combines <tt/start/ and <tt/enable/
and <tt/down/ combines <tt/stop/ and <tt/disable/.
<sect2>Problem Management - abort, redo, kill
<p>
These commands are usually used when there is a problem
printing a job.
The <tt/abort/
command is used to kill off all printing activity
associated with a job.
It also has the side effect of stopping printing on the print queue.
The <tt/redo/
command  will redo or attempt to reprint a job.
The <tt/kill/ command combines the abort and redo command,
and is useful when there are problems with the job currently being printed
and it should be reprinted.
<sect2>Job Scheduling - topq, holdall, noholdall, hold, release
<p>
The <tt/topq/ command effictively puts the select job or jobs at the top
of the queue for printing.
<p>
The <tt/holdall/,
<tt/noholdall/,
and
<tt/release/
commands implement a simple holding queue for jobs.
By default,
<tt/holdall/ is disabled.
When the <tt/holdall/ command enables it,
then jobs will remain in the spool queue until explicitly released
with the <tt/release/ command.
<p>
The <tt/hold/ command can also be used to hold individual jobs
until released.
<p>
<sect2>Queue Management - class, redirect, move
<p>
The <tt/class/ command is used to restrict printing to jobs
whose class value,
set using the <tt/lpr -C class/ option,
is in the class list or matches one of the classes.
This allows the administrator to restrict printing.
For more details and an example of its use,
see Form Support.
<p>
The <tt/redirect/ command allows the administrator to accepts jobs
at this queue and then to have them forwarded or redirected
to another print queue.
This is useful when a printer temporarily is unavailable.
<p>
The <tt/move/ command allows an individual job (or jobs)
to be forwarded or redirected to another print queue.
<sect>Forwarding Jobs
<p>
Our Tutorial Printcap configuration has the following format:
<tscreen>
<verb>
lp:sd=/var/spool/lpd/%P
  :force_localhost
  :lp=/var/tmp/lp
lp2:sd=/var/spool/lpd/%P
  :force_localhost
  :lp=/var/tmp/lp2
</verb>
</tscreen>
<p>
Both of these queues cause jobs to be written to
<tt>/var/tmp/lp</tt>
and
<tt>/var/tmp/lp2</tt>
respectively.
This can be tested by trying the following commands:
<tscreen>
<verb>
cp /dev/null /var/tmp/lp
cp /dev/null /var/tmp/lp2
echo hi | lpr -Plp
echo there | lpr -Plp2
</verb>
</tscreen>
<p>
The contents of
<tt>/var/tmp/lp</tt>
and
<tt>/var/tmp/lp2</tt>
will now be <tt/hi\n/ and <tt/there\n/
respectively.
<p>
Modify the printcap so that it has the following contents,
and then execute the indicated commands:
<tscreen>
<verb>

new printcap contents

lp:sd=/var/spool/lpd/%P
  :force_localhost
  :lp=lp2@localhost
lp2:sd=/var/spool/lpd/%P
  :force_localhost
  :lp=/var/tmp/lp2

h4: {172} % checkpc -f
h4: {173} % lpc reread
</verb>
</tscreen>
<p>
The <tt/lp=lp2@localhost/
means <it>
forward any jobs sent to this queue to the spool queue q2 on localhost </it>.
To see if this is true,
execute the following commands:
<tscreen>
<verb>
h4: {181} % clearstatus
h4: {182} % cp /dev/null /var/tmp/lp
h4: {183} % cp /dev/null /var/tmp/lp2
h4: {184} % echo hi | lpr
h4: {185} % lpq -ll
Printer: lp@h4 (dest lp2@localhost)
 Queue: no printable jobs in queue
 Status: done job 'papowell@h4+19114' transfer to lp2@localhost at 23:41:44.502
 Status: subserver pid 19116 exit status 'JSUCC' at 23:41:44.524
 Status: lp@h4.private: job 'papowell@h4+19114' printed at 23:41:44.525
 Status: job 'papowell@h4+19114' removed at 23:41:44.536
Printer: lp2@h4
 Queue: 1 printable job
 Server: pid 19117 active
 Unspooler: pid 19118 active
 Status: opening device '/var/tmp/lp' at 23:41:44.557
 Status: printing job 'papowell@h4+19114' at 23:41:44.558
 Status: no banner at 23:41:44.558
 Status: printing data file 'dfA019114h4.private', size 3 at 23:41:44.558
 Rank   Owner/ID                  Class Job Files                 Size Time
active papowell@h4+19114            A 19114 (stdin)                  3 23:41:44
</verb>
</tscreen>
<p>
As you can see from the status,
the print job was forwarded from <tt/lp@h4/ to the <tt/lp2@h4/ queue.
What is a little surprising is that the <tt/lpq/ command displays status for
<bf/both/ queues.
This is because LPRng does recursive status lookups
when you specify job forwarding with the <tt/RFC1179/ protocol
This is done using the printcap entries
<tt/:lp=queue@host/ or <tt/:rp=queue:rm=host/ format.
See
<ref id="remotesupport" name="Protocol Requests and Replies">
and
<ref id="destinations" name="Dynamic Routing">
for more information on problems using recursive status lookup and
how recursive status lookup can be modified.
<sect1>Printer Name and Server IP Address
<label id="printerenv">
<label id="PRINTER">
<label id="defaulthost">
<label id="defaultprinter">
<label id="defaultprinterwhenunknown">
<p>
Options used:
<itemize>
<item> <tt>PRINTER, LPDEST, NGPRINTER</tt><em>&nbsp;&nbsp;Environment variables </em>
<item> <tt>force_localhost</tt><em>&nbsp;&nbsp;force clients to send requests to localhost </em>
<item> <tt>default_printer_when_unknown</tt>&nbsp;&nbsp; <em>used by LPD when printer name not in printcap </em>
</itemize>
<p>
When an LPRng client such as
<tt/lpr/,
<tt/lpq/,
<tt/lprm/,
or
<tt/lprc/
needs to communicate with a print server,
the only information they normally need is:
<enum>
<item>
The spool queue or <it/remote printer/
to be used in requests to the <tt/lpd/ print server.
This is sometimes referred to as the <it/printer/ or <it/print queue/ name.
<item>
The IP address or hostname of the <it/print server/ or <it/remote server/.
This is sometimes called the <it/remote host/ or simply <it/server/.
<item>
Options that control <em/how/ jobs or commands are transferred to the server host.
These options might include encryption and client side job filtering.
We will discuss these capabilities later.
</enum>
<p>
LPRng has several ways to specify the <it/printer queue/ and <it/server/ information.
<sect2>Command Line -Pprinter@host
<p>
The <tt/-P printer@host/ option specifies both the print queue and
server.
<tscreen>
<verb>
lpr -Plaser@10.0.0.1
lpq -Plp@myserver
</verb>
</tscreen>
<p>
When used as a command line option,
the printcap database will not be consulted for other options or information.
This allows LPRng clients to function without a printcap database,
and without a <tt/lpd/ print server running on their local host.
However,
options set in the <tt>/etc/lpd.conf/</tt> and the compile time defaults
will still be used.
<sect2>Command Line -Pprinter
<p>
This form will cause the LPRng clients to look in the
<tt>/etc/printcap</tt>
for a printcap entry with the name or alias <tt/printer/
and use the information in that printcap entry.
We will discuss the format of the printcap entry in a moment.
Example:
<tscreen>
<verb>
lpr -Plp
</verb>
</tscreen>
<sect2>PRINTER, LPDEST, and NGPRINTER Environment Variables
<p>
If no command line option is specified,
the LPRng clients will check for the first defined
<tt/PRINTER/,
<tt/LPDEST/,
or
<tt/NGPRINTER/
environment variable value
and will use the value as though specified as a
<tt/-P$PRINTER/ command line option.
<p>
If the value has the form
<tt/printer@host/ the print queue will be <tt/printer/ on server <tt/host/
and not consult the printcap database.
If the value has the form <tt/printer/ then the printcap will be searched
for a <tt/printer/ printcap entry.
For example:
<tscreen>
<verb>
export PRINTER=laser@10.0.0.1; lpr
export PRINTER=pr; lpr
</verb>
</tscreen>
<sect2>Default Printer From Printcap
<p>
If you do not specify a printer on the command line or in the <tt/PRINTER/
environment variable,
then LPRng will search the printcap and use the first valid printcap entry
as the printer.
<sect2>Default Printer When No Printcap
<p>
If you do not have a <tt>/etc/printcap</tt> file,
then LPRng will use the
<tt>default_printer</tt>
and
<tt>default_remote_host</tt>
<it/fallback/
values set in the <tt>/etc/lpd.conf</tt> file or by the compile time defaults.
<p>
Using the fallback values is usually not a desirable event and may indicate
that you have a misconfigured host, so the fallback values are usually set
by administrators to <tt/missingprinter@localhost/ to provoke an annoying message for users.
<sect2>LPD Default Printer
<p>
For completeness,
there is even a <tt>default_printer_when_unknown</tt> configuration
entry for use by LPD when it is given a printer name not in its printcap
database.
By default,
it will look up this name in the database and treat the job as though it was
sent to this printer.
<sect1>User Identification
<label id="allowusersetting">
<p>
Options used:
<itemize>
<item> <tt>allow_user_setting</tt><em>&nbsp;&nbsp;priviledged users </em>
</itemize>
<p>
When an client program sends a command to the <tt/lpd/ server,
it sends the name of the user who is originating the request for service.
This name is obtained by looking up the UID of the user
running the client
in the user information database and using this name;
if the name is not found the UID value is used.
<p>
The <tt>lpr -U name</tt> (and for
<tt/lpq/, <tt/lprm/, and <tt/lpc/)
option allows privileged users to
cause the client software to use the <tt/name/ value as the originator
rather than the UID information.
This allows priviledged users to <tt/impersonate/ other users.
This is most useful for programs such as Samba and PCNFS,
which need to act as proxies for users.
<p>
By default, ROOT (UID 0) is the only user that can masquerade as another
user.
The <tt/allow_user_setting=name,name.../ configuration option can be used
to specify a list of names or UIDs that can also perform masquerading.
For example,
if the Samba server was running as user <tt/samba/, then
<tt/allow_user_setting=samba/ would allow it to specify the name of print
job originator as a remote user,
and the remote user would not need a login account on the system.
<sect1> LPD Server Runnning on Localhost
<label id="forcelocalhost">
<p>
Options used:
<itemize>
<item> <tt>force_localhost</tt><em>&nbsp;&nbsp;force clients to send requests to localhost </em>
</itemize>
<p>
Workstations for personal use or in extremely simple configurations
will always run an <tt/lpd/ server on the <it/localhost/.
This is the most common situation for the majority of new
users,
and the
default LPRng installation sets the default value of the
<tt/force_localhost/ configuration parameter to <bf/TRUE/ or to 1.
The
<tt/lpr/
<tt/lpq/
<tt/lprm/
and
<tt/lpc/ will connect to <tt/localhost/ (usually IP address 127.0.0.1)
unless explicitly overridden by the command line <tt/-Pprinter@host/ argument.
<p>
Larger sites or organizations which want to use a central print server
to handle multiple printers or printer sharing
may want the clients to connect directly to the server.
This can be done either at compile time using the
<tt>./configure --disable-force_localhost</tt>
option and regenerating the software or by setting the
<tt/force_localhost/ flag off in the <tt/printcap/ or <tt/lpd.conf/ file:
<tscreen>
<verb>
# Set force_localhost off, send to
# server 10.0.0.1
lp=lp@10.0.0.1:force_localhost@
</verb>
</tscreen>
<sect>Communication With A Printer
<label id="installref">
<p>
This section describes the various was that you can communicate
with a printer
and the support that LPRng provide for them.
<sect1>Network Printers
<label id="networkprinter">
<p>
The most flexible and highest throughput printer interface is
via a network (TCP/IP) connection.
Most high performance printers have a built in network interface,
or you can attach them to a
<em/printer server/
box which provides a network interface.
The network interface usually supports multiple network printing protocols.
The most common are the LPD (RFC1179), Socket API, AppSocket, SMB,
and Novell Netware interfaces.
LPRng directly supports the LPD (RFC1179) and Socket API interfaces,
and you can use the
<tt/smbclient/ program from the
<ref id="smb" name="Samba Software Package"> for the SMB interface.
<sect1>RFC1179 (LPD) Connection
<p>
In this mode of operation the print server actually operates as a very
limited BSD print spooler.
These limitations include:
<enum>
<item>
No error messages or status capability
<item>
Limited or very primitive banner printing.
On some systems it may be <it>impossible</it>
to turn banner printing off.
<item>
On most known print servers high connection activity caused
by multiple systems attempting to get status or spool jobs
may cause catastropic failure of the printer.
</enum>
<p>
For the above reasons,
using RFC1179 to transfer jobs to a printer should be regarded as the
least desirable option.
Please see
<ref id="rfc1179ref" name="The RFC1189 Protocol">
for a detailed discussion of the RFC1179 protocol.
<p>
In order to use the RFC1179 transfer operation you must have a printcap entry
for the printer that provides:
<itemize>
<item>
The IP address or name of the printer that can be resolved to an IP address
<item>
The name of the spool queue.
In practice,
this is usually used only to determine which of several printer ports
on the printe server the job will be sent to,
or what type of processing the print server will do.
Most cards usually do not do any processing and simply pass the job
through to the printer.
</itemize>
<p>
The following is an example of a simple printcap entry that
can be used to send a job to a remote printer using the RFC1179 protocol:
<tscreen>
<verb>
# LPRng syntax
# :lp value is 'where to print the job'
lp:
  :lp=raw@10.0.0.1

# OR Vintage BSD Print Spooler Syntax
# (LPRng supports this as well)
# :rp = remote printer, :rm = remote machine or host
lp:
  :rp=raw:rm=10.0.0.1
</verb>
</tscreen>
<p>
If you wish to transfer jobs to a print spooler without using the
full LPRng <tt/lpr/ program,
the Perl <tt/cheap_lpr/ program
in the LPRng Distribution <tt/UTILS/ directory
can be used for testing and tutorial purposes.
<sect1>Socket API
<label id="socketapi">
<p>
The Socket API is a very flexible job transfer protocol.
It is widely support by most Print Server manufacturers,
with the
Hewlett Packard JetDirect setting the
<it>de facto</it> standard.
The Socket API is extremely simple.
<enum>
<item>
The user establishes a connection to TCP/IP
port on the Printer or Network Print spooler.
The HP JetDirect uses port 9100 by default,
but other ports are used as well.
This connection may be refused if the printer is busy
printing a job.
<item>
When the network connection is established to a system which
has an <it>internal printer</it> or for which the Network Print Spooler
is an integral part of the system,
the printer usually flushes all internal buffers and readies itself
to receive a new job.
However,
when you are using an external Print Server box,
you may need to send specific intialization sequences to the printer
to ensure that it is reset correctly and is ready to receive new jobs.
<item>
When the connection is made,
all bytes sent to the connection are either transferred to
and external interface to directly to a
<it>print buffer</it>
used by the printer's Print Engine.
<item>
The connection is bidirectional,
and information sent to the external port by an external printer
or error messages and status generated by the printer's Print Engine
will be transferred over the data link to the user.
<item>
The Network Print spooler will keep the connection open
until it is closed by the user.
During this period it may continue to report status or other
information such as printer On Line,
paper outages, and so forth.
<item>
If the connection to the printer is <tt/half-closed/,
that is,
the <bf/shutdown()/ network system call is used to indicate to the
remote printer that no further data will be sent,
then the printer may immediately terminate the network connection.
This means that no further network or status messages will be
sent to the user.
<item>
If the connection is to a External Print Server,
then usually the connection can be immediately re-established.
It is the responsibility of the user to ensure that a the printer
has finished its work before sending a new job.
<item>
If the connection is to an internal Print Server,
then usually the printer will not allow the connection to be made,
or will refuse all data transfers on the connection until
the printer finishes with the previous job and all internal buffers
have been cleared.
</enum>
<p>
The following is a sample printcap showing how to use the Socket API:
<tscreen>
<verb>
lp:
  # make a socket connection to port 9100
  :lp=10.0.0.2%9100
</verb>
</tscreen>
<p>
You can use the
<htmlurl url="http://www.l0pht.com/~weld/netcat/" name="netcat">
utility by Hobbit <tt>&lt;Hobbit@avian.org&gt;</tt>
to test that the Socket interface is available and working.
If <it/ellipse.ps/ is a test file, then:
The simplest and easiest way to print a file to a network printer appears
<tscreen>
<verb>
  nc printer.ip.addr 9100 &lt file
Example:
  nc 10.0.0.25 9100 &lt ellipse.ps
</verb>
</tscreen>
<sect1>AppSocket TCP/IP Protocol
<label id="appsocket">
<p>
The AppSocket interface is supported by Tektronix and some other printer
vendors.
It is similar to the Socket API,
with a couple of significant differences.
<enum>
<item>
The printer has two ports for network connections:
a TCP port 9100 for TCP/IP stream connections and a UDP port for UDP
packet connections.
<item>
When a 0 length UDP packet or a UDP packet containing only <tt>CR/LF</tt>
is sent to UDP port 9101, the printer will return a packet to the sender
containing print status information.
This information indicates the printers current status (busy, idle, printing)
and any error conditions.
<item>
The format,
reliability,
and repeatability of the UDP format and information is totally undocumented,
and the UPD port facility should be regarded as,
at best,
an advisory function of the printer.
<item>
To send a job to the printer,
a connection to TCP port is made.
This connection will be refused while the printer is busy or has a connection
to another host.
<item>
When the TCP connection is established,
the information to be printed can be sent over the TCP connection.
Bytes sent on this stream will be placed in the input buffer of the
Print Engine and processed.
<item>
An end of job (EOJ) sequence indication
in the data stream will cause the printer to terminate the connection.
This is different than the Socket API,
where the printer will keep the connection open.
This means that if the PostScript CTRL-D (end of job) character is sent in
a job,  then the connection will be terminated.
<item>
Some models of printers modify this behavior slightly and
will not terminate the connection,
but will simply ignore any data following the EOJ indication.
<item>
Some printers support bidirectional AppSocket communication,
and while the connection is open will return error indications or status
information.
<item>
Once all the data has been received and the job has finished printing,
the connection will be terminated by the printer.
</enum>
<p>
The <tt/ihfhp/ filter,
one of the helper programs for LPRng,
is used with LPRng to provide AppSocket support.
For details,
please see the <it>IFHP HOWTO</it> in the
<htmlurl url="http://www.astart.com/" name="IFHP Distribution">
and <ref id="P450" name="Tektronix P450 and Family"> for details.
The following is a typical printcap entry for
the AppSocket protocol.
The actual network connection to the printer is made by the <tt/ifhp/
filter:
<tscreen>
<verb>
lp:
  # LPRng opens a dummy connection for consistency
  :lp=/dev/null
  # we pass the ifhp filter options indicating that the
  # Tektronics printer will need the appsocket protocol
  # and to use port 35 at 10.0.0.1 to make the connection
  # The ifhp filter may open and close the connection several
  # times during the file transfer in order to ensure that
  # the printer handles the job correctly.
  :ifhp=model=tek,appsocket,dev=10.0.0.1%35
  :if=/usr/local/libexec/filters/ifhp
</verb>
</tscreen>
<sect1>Network Print Server Boxes
<label id="secnetwork">
<p>
A ``network print server'' is usually a box
(external model) or card in a printer (internal model)
which has a network connection to a TCP network and
software to implement a LPD print server.
If it is an external model,
The parallel or serial port of
the printer is connected to the box,
and the print server may support multiple printers.
If it is an internal model,
the server is usually nothing more than a Network Interface Controller
and a ROM containing software that the microprocessor in the printer
uses.
<p>
The print server may support multiple printing protocols,
such as
<ref id="rfc1179" name="RFC1179">
(TCP/IP printing using the LPD print protocol),
Novell Printer Protocols,
SMB print protocols,
and AppleTalk protocols.
One of the observed problems with Network Print servers is that while they
can usually support one protocol and one user at a time quite well,
when you try to use multiple protocols and/or multiple users try to transfer
print jobs to the printer,  the printer may behave in a very odd manner.
Usually this results in a printer failing to finish a job currently being
printed,
and unable to accept new jobs.
<p>
Several of the newer models of print servers have
Simple Network Management Protocol (SNMP) agents built into them,
and can provide detailed information about their internal functions.
By using a SNMP manager such as SunNetmanage or HP-Openview,
you can monitor your network printers activities.
<p>
I recommend that you use only a single protocol to send jobs to the printer.
If you can,  I also recommend that you use a print spooler and have only
a single host system send a job to the printer.
<p>
My best advice on connecting to network printers is not to use the
the built-in LPD server,
but to use the direct TCP/IP connection to the print engine.
Usually this is done to particular TCP/IP port on the printer.
For the HP JetDirect and other HP products, this is usually
TCP port 9100.
<p>
Once you have the direct connection,
you can now use various filters to preprocess the print job,
insert PJL and PCL commands,
or convert text to PostScript or PCL for better print quality.
<sect1>Common Print Server Boxes Configuration Information
<p>
The following is a list of print server manufacturers,
models,
and with hints on how to access these boxes with various protocols.
<p>
<table>
<tabular ca="|l|l|l|l|">
Manufacturer
|
Model
|
RFC1179 Port Name (rp=XXX)
|
Send to TCP port
@
<htmlurl url="http://www.digprod.com/" name="Digital Products Inc.">
|
NETPrint Print Server
|
<tt>PORT<it>n</it></tt>, where <it>n</it> is port on server
|
- Unknown if supported -
@
<htmlurl url="http://www.efi.com/" name="Electronics For Imaging Inc.">
|
Fiery RIP i series
|
<tt>normalq</tt> or <tt>urgentq</tt>
|
- Unknown if supported -
@
|
Fiery RIP XJ series
|
<tt>xjprint</tt>
|
- Unknown if supported -
@
|
Fiery RIP XJ+ and SI series
|
<tt>print_</tt><it>Model</it>, e.g. <tt>print_DocuColor</tt>
|
- Unknown if supported -
@
|
Fiery models ZX2100, ZX3300, X2, X2e
|
<tt>print</tt>
|
- Unknown if supported -
@
<htmlurl url="http://www.emulex.com/" name="Emulex Corp.">
|
NETJet/NETQue print server
|
<tt>PASSTHRU</tt>
|
- Unknown if supported -
@
<htmlurl url="http://www.extendsys.com/" name="Extended Systems Inc.">
|
ExtendNet Print Server
|
<tt>Printer<it>n</it></tt>, where <it>n</it> is port on server
|
- Unknown if supported -
@
<htmlurl url="http://www.hp.com/" name="Hewlett-Packard">
|
JetDirect interface card
|
<tt>raw</tt>
|
9100
@
<htmlurl url="http://www.i-data.com/" name="I-Data">
|
Easycom 10 Printserver
|
<tt>par1</tt> (parallel port 1)
|
- Unknown if supported -
@
|
Easycom 100 Printserver
|
<tt>LPDPRT1</tt>
|
- Unknown if supported -
@
<htmlurl url="http://www.printers.ibm.com/" name="IBM">
|
Network Printer 12, 17, 24, and 24PS
|
<tt>PASS</tt>
|
- Unknown if supported -
@
<htmlurl url="http://www.lantronix.com/" name="Lantronix">
|
EPS1, EPS2
|
<tt>EPS_XXXX_S1 (serial) port 1, EPS_XXXX_P1 (parallel) port 2</tt>, etc.
|
3001 (port 1), 3002 (port 2), etc.
@
<htmlurl url="http://www.qms.com/" name="QMS">
|
Various Models
|
<tt>RAW</tt>
|
35 (Appsocket)
@
<htmlurl url="http://www.tek.com/color_printers/" name="Tektronix">
|
Tektronix printer network cards
|
<tt>PS</tt> (PostScript), <tt>PCL</tt> (PCL), or <tt>AUTO</tt>
(Auto-selection between PS, PCL, or HPGL).  Not reliable.
|
9100 (Appsocket on some models)
@
<htmlurl url="http://www.rosel.com" name="Rose Electronics">
|
Microserve Print Servers
|
lp
|
9100
@
<htmlurl url="http://www.xerox.com/" name="Xerox">
|
Models 4505, 4510, 4517, 4520
|
<tt>PASSTHRU</tt>
|
2501 (Appsocket on some models)
@
|
Model 4512
|
<tt>PORT1</tt>
|
10001 (programmable)
@
|
Model N17
|
<tt>RAW</tt>
|
9100
@
|
Models N24 and N32
|
<tt>RAW</tt>
|
2000
@
|
Models 4900, 4915, 4925, C55
|
<tt>PS</tt>
|
2000
@
|
Document Centre DC220/230
|
<tt>lp</tt>
|
- Unknown if supported -
@
</tabular>
</table>
<p>
All company, brand, and product names are properties of their respective owners.
<sect1> HP JetDirect Interface
<p>
The  HPJetDirect  card  can  be configured through the front
panel  or through a set of network files.  Here is a summary
of  the  methods  used  from  UNIX  systems, or when you are
desperate, to configure the printer.
<sect2> Setting Up IP Networking and Address
<p>
You can set the network address from the front panel.
Reset  the printer,
put it in offline mode.
and then use the MENU, +-, SELECT keys as follows:
<tscreen>
<verb>
 MENU  -> MIO MENU (use MENU to display MIO MENU)
 ITEM  -> CFG NETWORK=NO*
 +     -> CFG NETWORK=YES
 ENTER -> CFG NETWORK=YES*
 ITEM  -> TCP/IP=OFF* (use ITEM to display TCP/IP)
 +     -> TCP/IP=ON
 ENTER -> TCP/IP=ON*
 ITEM  -> CFG TCP/IP=NO* (use ITEM to display TCP/IP)
 +     -> CFG TCP/IP=YES
 ENTER -> CFG TCP/IP=YES*
 ITEM  -> BOOTP=NO*
     (Enable BOOTP if you want to - see below)
 ITEM  -> IP BYTE 1=0*
     This is IP address MSB byte.
     Use +- keys to change value, and then ENTER to change
     Use ITEM keys to get IP BYTE=2,3,4
 ITEM  -> SM BYTE 1=255*
      This is the subnet mask value
     Use +- keys to change value, and then ENTER to change
     Use ITEM keys to get IP BYTE=2,3,4
 ITEM  -> LG BYTE 1=255*
     This is the Syslog server (LoGger) IP address
     Use +- keys to change value, and then ENTER to change
     Use ITEM keys to get IP BYTE=2,3,4
 ITEM  -> GW BYTE 1=255*
     This is the subnet gateway (router) IP address
     Use +- keys to change value, and then ENTER to change
     Use ITEM keys to get IP BYTE=2,3,4
 ITEM  -> TIMEOUT=90
      This is the connection timeout value.  It puts a limit
     on time between connections.  A value of 10 is reasonable.
</verb>
</tscreen>
<sect2> BOOTP Information
<p>
If  you have a bootp server, you can put this information
in  the  bootptab  file.   To  use this, you must enable the
bootp  option  on  the printer.  The T144 option specifies a
file to be read from the bootp server.  This file is read by
using  the  TFTP  protocol, and you must have a TFTPD server
enabled.  Here is a sample bootptab entry.
<tscreen>
<verb>
# Example /etc/bootptab: database for bootp server (/etc/bootpd).
# Blank lines and lines beginning with '#' are ignored.
#
# Legend:
#
#       first field -- hostname
#                       (may be full domain name)
#
#       hd -- home directory
#       bf -- bootfile
#       cs -- cookie servers
#       ds -- domain name servers
#       gw -- gateways
#       ha -- hardware address
#       ht -- hardware type
#       im -- impress servers
#       ip -- host IP address
#       lg -- log servers
#       lp -- LPR servers
#       ns -- IEN-116 name servers
#       rl -- resource location protocol servers
#       sm -- subnet mask
#       tc -- template host (points to similar host entry)
#       to -- time offset (seconds)
#       ts -- time servers
#
# Be careful about including backslashes where they're needed.  Weird (bad)
# things can happen when a backslash is omitted where one is intended.
#
peripheral1:
:hn:ht=ether:vm=rfc1048:
:ha=08000903212F:
:ip=190.40.101.22:
:sm=255.255.255.0:
:gw=190.40.101.1:
:lg=190.40.101.3:
:T144="hpnp/peripheral1.cfg":
</verb>
</tscreen>
<p>
If  you  are  using the T144 option, you will need to create
the  configuration file.  The sample configuration file from
the HP Direct distribution is included below.
<tscreen>
<verb>
#
# Example HP Network Peripheral Interface configuration file
#
# Comments begin with '#' and end at the end of the line.
# Blank lines are ignored.  Entries cannot span lines.

# Name is the peripheral (or node) name.  It is displayed on the peripheral's
# self-test page or configuration plot, and when sysName is obtained through
# SNMP.  This name can be provided in the BOOTP response or can be specified
# in the NPI configuration file to prevent the BOOTP response from overflowing
# the packet.  The domain portion of the name is not necessary because the
# peripheral does not perform Domain Name System (DNS) searches.  Name is
# limited to 64 characters.

name: picasso

# Location describes the physical location of the peripheral.  This is the
# value used by the interface for the MIB-II sysLocation object.  The default
# location is undefined.  Only printable ASCII characters are allowed.
# Maximum length is 64 characters.

location: 1st floor, south wall

# Contact is the name of the person who administers or services the peripheral
# and may include how to contact this person.  It is limited to 64 characters.
# This is the value used by the interface for the MIB-II sysContact object.
# The default contact is undefined.  Only printable ASCII characters are
# allowed.  Maximum length is 64 characters.

contact: Phil, ext 1234

# The host access list contains the list of hosts or networks of hosts
# that are allowed to connect to the peripheral.  The format is
# "allow: netnum [mask]", where netnum is a network number or a host IP
# address.  Mask is an address mask of bits to apply to the network number
# and connecting host's IP address to verify access to the peripheral.
# The mask usually matches the network or subnet mask, but this is not
# required.  If netnum is a host IP address, the mask 255.255.255.255 can
# be omitted.  Up to ten access list entries are permitted.

# to allow all of network 10 to access the peripheral:
allow: 10.0.0.0  255.0.0.0

# to allow a single host without specifying the mask:
allow: 15.1.2.3

# Idle timeout is the time (in seconds) after which an idle
# print data connection is closed.  A value of zero disables
# the timeout mechanism.  The default timeout is 90 seconds.

idle-timeout: 120

# A community name is a password that allows SNMP access to MIB values on
# the network peripheral.  Community names are not highly secure; they are
# not encrypted across the network.  The get community name determines which
# SNMP GetRequests are responded to.  By default, the network peripheral
# responds to all GetRequests.  The get community name is limited to 32
# characters.
#
# For hpnpstat and hpnpadmin, the community name can be stored in
# /usr/lib/hpnp/hpnpsnmp.

get-community-name: blue

# The set community name is similar to the get community name.  The set
# community name determines which SNMP SetRequests are responded to.  In
# addition, SetRequests are only honored if the sending host is on the
# host access list.  By default, the network peripheral does not respond
# to any SetRequests.  The set community name is limited to 32 characters.
#
# The set community name can come from /usr/lib/hpnp/hpnpsnmp
# if it is the same as the get community name.  We recommend that the
# set community name be different from the get community name though.

set-community-name: yellow

# SNMP traps are asynchronous notifications of some event that has occurred.
# SNMP traps are useful only with network management software.  Traps are
# sent to specific hosts and include a trap community name.  Up to four
# hosts can be sent SNMP traps.   The trap community name is limited to
# 32 characters.  The default name is public.

trap-community-name: red

# The SNMP trap destination list specifies systems to which SNMP
# traps are sent.  Up to four IP addresses are allowed.  If no
# trap destinations are listed, traps are not sent.

trap-dest: 15.1.2.3
trap-dest: 15.2.3.4

# The SNMP authentication trap parameter enables or disables the sending
# of SNMP authentication traps.  Authentication traps indicate that an SNMP
# request was received and the community name check failed.  By default,
# the parameter is off.

authentication-trap: on

# The syslog-facility parameter sets the source facility identifier that the
# card uses when issuing syslog messages.  Other facilities, for example,
# include the kernel (LOG_KERN), the mail system (LOG_MAIL), and the spooling
# system (LOG_LPR).  The card only allows its syslog facility to be configured
# to one of the local user values (LOG_LOCAL0 through LOG_LOCAL7).  The
# selectible option strings, local0 through local7 (configured to LOG_LOCAL0
# through LOG_LOCAL7, respectively) are case insensitive.  The default
# syslog-facility for the card is LOG_LPR.

syslog-facility: local2

# This parameter allows the card to treat hosts on other subnets as if the
# hosts were on the card's subnet.  This parameter determines the TCP
# Maximum Segment Size (MSS) advertised by the card to hosts on other subnets
# and affects the card's initial receive-window size.  The card will use a
# TCP MSS of 1460 bytes for local hosts, and 536 bytes for a non-local host.
# The default is off, that is, the card will use the maximum packet sizes
# only on the card's configured subnet.
#
# The configuration utility does not allow access to this parameter.  If you
# want to configure it, you must manually edit the NPI configuration file
# and add it to the bottom of the entry for the network peripheral.

subnets-local: on

# This parameter affects how the card handles TCP connection requests from
# the host.  By default, the JetDirect MPS card will accept a TCP connection
# even if the peripheral is off-line.  If this parameter is set to "on", then
# the card will only accept a TCP connection when the peripheral is on-line.

old-idle-mode: off
</verb>
</tscreen>
<sect1> Printing to a SMB (MicroSoft) Printer
<p>
Microsoft use the SMB (Simple Message Block) protocol to transfer files
and print jobs to hosts and printers.
SMB can be used over TCP/IP, NetBEUI, IPX,
and other lower level network protocols.
<p>
Unfortunately,
most printers do not provide detailed status or error reports
when using the SMB protocol.
There are a very large number of printers that have deficient SMB
support that causes problems when used in a high traffic or
high throughput environment.
<p>
It is highly recommended that this protocol not be used unless there
is no alternative.
<p>
If you have a printer or a remote print spooler that supports
support SMB
You can use the
<ref id="smb" name="SAMBA">
<tt/smbclient/ program to send a print job to an SMB client.
The following is a sample
Shell Script script which you can use:
<tscreen>
<verb>
#!/bin/sh -x
# This script is an input filter for printcap printing on a unix machine. It
# uses the smbclient program to print the file to the specified smb-based
# server and service.
# The 'smb' printcap entry below shows how to configure LPRng
# for printing
#
# smb:
#  :sh:lp=|/usr/local/samba/smbprint
#  :sd=/usr/spool/smb:
#  :if= ... filter ...
#
# The /usr/spool/smb/.config file should contain:
#   server="PC_SERVER"
#   service="PR_SHARENAME"
#   password="PASSWORD"
#
# Set PC_SERVER to the server, PR_SHARENAME to the printer,
# and PASSWORD to the password for this service.
#
# E.g.
#   server=PAULS_PC
#   service=CJET_371
#   password=""
#
#
config_file=.config
if [ -f $config_file ] ; then
	eval `/bin/cat $config_file`
fi
#
# NOTE You may wish to add the line `echo translate' if you want automatic
# CR/LF translation when printing.
(
#   echo translate
    echo "print -"
    /bin/cat
) | /usr/local/bin/smbclient "\\\\$server\\$service" \
   "$password" -U "$server" -N -P 1>&2
</verb>
</tscreen>
<p>
If the above script was in <tt>/usr/local/libexec/filters/smbprint</tt>,
the printcap entry for this printer would be:
<tscreen>
<verb>
pauls_pc:
  :sd=/var/spool/lpd/%P
  # we filter the output
  :lp=|/usr/local/libexec/filters/smbprint
  # you can add filters if you want to do specific actions
  :ifhp=model=hp4
  :if=/usr/local/libexec/filters/ifhp
</verb>
</tscreen>
<sect1>Printing to AppleTalk Printers
<p>
The <ref id="appletalk" name="netatalk">
package comes with the
<tt>pap</tt> program that can be used to transfer jobs using the AppleTalk
protcol.
A printcap entry for a network printer looks like the following:
<tscreen>
<verb>
atalk:
  :lp=|/usr/local/atalk/bin/pap -e -p "npbname"
  :sd=/var/spool/lpd/atalk
  :ifhp=model=ps
  :if=/usr/local/libexec/filters/ifhp
</verb>
</tscreen>
<p>
The <tt/pap/ program must be
SETUID root and executable only by root or group <tt>daemon</tt>.
This can be done by using the following script:
<tscreen>
<verb>
cd /usr/local/atalk/bin
chown root pap
chgrp daemon pap
chmod 550 bin
chmod s+u bin
</verb>
</tscreen>
<sect1>Parallel Printers
<p>
In most UNIX systems the printer port has the name
<tt>/dev/lpt</tt>,
<tt>/dev/prn</tt>,
or something similar.
On most systems the
<tt>dmesg</tt> utility will print a list of IO devices found
during system configuration.
Use the following commands to get the information and scan
for the device.
You should also make sure that the printer device is
available.
<tscreen>
<verb>
dmesg >/tmp/a
grep lp /tmp/a
ls /dev/lp*
</verb>
</tscreen>
<p>
<p>
Gordon Haverland
<tt>&lt;haverlan@agric.gov.ab.ca</tt>&gt; supplied this little script,
that will assist with this:
<tscreen>
<verb>
#!/bin/sh
#set -v -x              # uncomment for debugging
PATH=/bin:/usr/bin
printer=
for printer in /dev/lp* ;
do
    echo PRINTER TEST to $printer 1&gt;&2
    for i in 1 2 3 4 5 6 7 8 9;
    do
        echo PRINTER $printer $i &gt; $printer;
    done
    echo -e \\r\\f &gt; $printer
done
exit 0;
</verb>
</tscreen>
<p>
If your printer is connected to the device name you provided,
then you should get a page of something out.  If the output
suffers from the ``staircase'' effect, you will see the numbers
``marching'' across the page, otherwise the numbers will all be in
a single column.
<sect1>Serial Printers
<label id="secserial">
<p>
If your printer is attached by a serial line,
then you may need to set the serial line characteristics before sending
the job to the printer.
Here are a set of guidelines to following when attaching a serial port printer
to a serial line.
<p>
1. Check to make sure that the line is not enabled for login.
Logins are usually managed by the
<tt>getty</tt> (BSD)
or
<tt>ttymon</tt> (Solaris, SystemV).
Check your system documentation and make sure that these daemons are not
managing the serial line.
<p>
2. Check the permissions and ownership of the serial line.
For the most easy testing,
set the permissions to 0666 (everybody can open for reading and writing).
After you have made sure that you can send jobs to the printer,
you might want to change the ownership of the serial line to the LPD server
and change the permissions to 0600.
<p>
3. Make sure that you can print a test file on the printer via the
serial port.
This may require setting the line characteristics and then sending
a file to the printer.
You should try to use 8 bit, no parity, with hardware flow control
and no special character interpretation,
and definitely no LF to CR/LF translation.
The problem is that different versions of UNIX systems have different
sets of stty(1) commands to do this.
The following simple test script can help in this.
<tscreen>
<verb>
#!/bin/sh
# 9600, no echo, no CR
FLAGS= 9600 -raw -parenb cs8 crtscts
DEV= /dev/tty01
(stty $FLAGS; stty 1>&2; cat $1 ) <$DEV >$DEV
</verb>
</tscreen>
<p>
This shows using stty to set the flags,
then to print the current settings, and then using
cat a file to the output.
If you attach a dumb terminal to the serial port,
you can even use this script to ensure that input from the device
is echoed to the output with the correct speed, parity,
etc.
<p>
Experience has shown that serially connected printers are the least
reliable and lowest speed.
Where possible,
it is strongly recommended that they be attached to a <it/network print box/
which will provide a
Socket API interface and handle the low level network to serial port protocol
conversions.
<sect>Typical Printcap Configurations
<label id="printcapref">
<p>
As described in the
<ref id="overview" name="Print Spooling Overview">,
the heart of the LPRng system is information in the <tt>/etc/printcap</tt>
file.
The printcap information specifies:
<enum>
<item>
The print queues available to users.
<item>
How client programs communicate with the <tt/lpc/ print server.
<item>
The configuration,
location,
and other information for each print queue on the print server.
<item>
How the <tt/lpd/ server processes jobs in each print queue.
</enum>
<p>
In order to explain a complex subject,
we will start with a set of simple printer configurations,
and explain the purpose and effect of each entry in the printcap.
<p>
For details about individual printcap
options, see the <tt>printcap(5)</tt>
man page from the LPRng distribution,
or use the <ref id="index" name="Index To All The Configuration and Printcap Options"> to find a specific
printcap option and its effects.
<sect1>Simple Client Printcap Entry
<label id="lp">
<label id="rm">
<label id="rp">
<p>
Options used:
<itemize>
<item> <tt>rm=</tt><em>remote host (machine)</em>
<item> <tt>rp=</tt><em>remote printer</em>
<item> <tt>lp=</tt><em>destination printer information</em>
<item> <tt>client</tt>&nbsp;&nbsp;client only printcap FLAG
</itemize>
<p>
I'll use this simple example to explain the basics of the LPRng
printcap format
and introduce some of the LPRng network configuration options.
Here is a simple printcap file used to provide client programs
(<tt/lpr, lprm,/ etc)
with <it/remote printer/ and <it/server/ information.
<tscreen>
<verb>
# printer lp1
lp1|printer1
  :rm=localhost
# printer lp2 with continuation
lp2:\
  :lp=pr@10.0.0.1:client
# printcap lp3, to printer pr, with overrides
lp3:rp=pr:rm=hpprinter.astart.com
  :force_localhost@
# Simplest possible printcap entry - defaults for everything
lp4
</verb>
</tscreen>
<enum>
<item>
Lines starting with a <tt>#</tt> sign are comments, and all
leading and trailing <em>whitespace</em>,
i.e. - spaces, tabs, etc, are ignored.
Empty lines are ignored as well.
<item>
A printcap entry starts with the printcap entry <bf/name/,
followed by one or more <em/aliases/,
followed by one or more options.
In the above example we have three printcap entries: <tt/lp1/ with an alias
<tt/printer1/
and <tt/lp2/, <tt/lp3/, and <tt/lp4/ with no aliases.
<item>
Aliases start with the <tt/|/ character and options with the <tt/:/ character;
tabs and spaces before and after the <tt/|/ or <tt/:/ characters
and at the start and end of lines are ignored.
You can use backslash (<tt/\/) at the end of a line to create a multi-line
value for an option.
The backslash will cause the next line to be appended to the
current line;
watch out for comments and ends of printcap entries if you use this facility.
As you can see from the example,
there is no <tt/Name/ printcap entry - this is part of the <tt/cm/
option on the previous line.
<item>
Options take the form of a
keyword/value pair, i.e.-
<verb>
:option=value
:option#value   (legacy, not advised for new systems)
:option
:option@
</verb>
<item>
Option names are case insensitive, but option values are not.
While <tt>Ts</tt> and <tt>ts</tt> are the same option name,
<tt/ts=Testing/ and <tt/ts=testing/ have their case preserved.
A string or integer value is specified by <tt/option=value/
or <tt/option#value/.
<item>
The use of the legacy <tt/option#value/
form is <bf/NOT/ recommended as some preprocessors
and database systems will treat <bf/#/ as the start of a comment
and delete the remainder of the line.
This has caused great consternation for sysadmins who wonder why their
NIS distributed printcap entries have been mysteriously truncated.
<item>
If you want to set a string option to <it/empty/ value,
use <tt/option=/. The <tt/option/ will set it to <tt/1/.
If an option value contains a colon, then use the C (or Perl or Tck/Tk)
string escape <tt>\072</tt> to represent the value.
<item>
Boolean options are set TRUE (1) if no value follows the keyword and FALSE (0) by
appending a <tt>@</tt>.
For example
<tt>sh</tt>
will set
<tt>sh</tt> to TRUE and
<tt>sh@</tt> to FALSE.
</enum>
<p>
There may be multiple options on the same line, separated
by colons.
However, this does make the file less readable. The next tip was
supplied by James H. Young &lt;<tt>jhy@gsu.edu</tt>&gt;:
<p>
<quote>
My personal preference for readability is to always put each
option on its own line.  Putting each option on its own line is
worth the trouble even though it detracts from the usability
of certain grepping techniques when trying to maintain these
types of files.
</quote>
<p>
Now let's examine the first printcap entry in detail.
It is reproduced here for convenience:
<tscreen>
<verb>
# printer lp1
lp1|printer1
  :rm=localhost
</verb>
</tscreen>
<enum>
<item>
We start with a comment, followed by the printcap entry name and and alias.
Aliases are useful when you want to refer to a single printer or print queue
by different names.
This can be useful in advanced printcap and print queue setups.
By default,
the remote printer name is the printcap entry name.
<item>
The <tt/rm/ (remote machine or host) option specifies the name or IP address
of the <tt/lpd/ host running <tt/lpd/.
In this example the remote host is <tt/localhost/
or the machine that the client is running on
and we assume that the <tt/lpd/ server is running on the localhost.
Thus,
we would communicate with printer
<tt/lp1@localhost/.
</enum>
<p>
Let's look at the next printcap entry:
<tscreen>
<verb>
# printer lp2 with continuation
lp2:\
  :lp=pr@10.0.0.1:client
</verb>
</tscreen>
<enum>
<item>
The <tt/lp2/ printcap entry illustrates the use (and abuse)
of the <tt/\/ continuation.
If you think about this,
we have really defined a printcap entry of the form:
<tscreen>
<verb>
lp2: :lp=pr@10.0.0.1:client
</verb>
</tscreen>
<p>
Luckily, LPRng ignores empty options like <tt/:&nbsp;:/.
While it is strongly recommended that <tt/\/
be avoided it may be necessary for compatibility with other system utilities.
<item>
The <tt/lp=pr@10.0.0.1/ option is an alternate way to
specify a remote queue and server.
If the <tt/force_localhost/ default is being used,
then the LPRng clients will ignore the <tt/10.0.0.1/ address
and still connect to <tt/pr@localhost/.
There is further discussion about this in the next section.
<item>
The <tt/client/ option explicitly labels client only printcap information.
The <tt/lpd/ server will ignore any printcap with the <tt/client/ option.
When constructing complex printcaps,
this option is used to keep ensure that you have consistent printcap information.
</enum>
The following printcap entry shows how to override the
<tt/force_localhost/ default,
and force the LPRng clients to connect directly to a remote server:
<tscreen>
<verb>
lp3:rp=pr:rm=hpprinter.astart.com
  :force_localhost@
</verb>
</tscreen>
<enum>
<item>
The <tt/rp=/  (remote printer)
remote print queue name to used when sending commands to the <tt/lpd/ print server.
<item>
The <tt/force_localhost@/ option is an example of a <it/flag/ option.
The <tt/@/ sets the option value to 0 (false).
We set <tt/force_localhost/ to false,
which now allows the LPRng clients to connect directly to the
specified remote printer.
In this example,
the <tt/hpprinter.astart.com/ could be a HP LaserJet Printer with a
JetDirect interface,
which supports the RFC1179 protocol.
<item>
One disadvantages of sending a job directly to a printer using the above
method is that <tt/lpr/ program will not
terminate or exit until all of the files have been transferred to the printer,
and this may take a long time
as the printer processes the files as they are received.
</enum>
<p>
Now let's look at the last printcap entry:
<tscreen>
<verb>
# Simplest possible printcap entry - defaults for everything
lp4
</verb>
</tscreen>
<p>
The last example is the simplest possible printcap entry.
This will cause LPRng clients to use the default values for everything.
The printer will be <tt/lp4/,
i.e. - the name of the printcap,
and the server will be <tt/localhost/ if <tt/force_localhost/ is set,
or the value of the <tt/default_remote_host/ configuration option
if it is not.
<sect1>Simple Server Printcap Example
<label id="cm">
<label id="mx">
<label id="secprintcap">
<p>
Options used:
<itemize>
<item> <tt>cm=</tt><em>comment for status</em>
<item> <tt>if=</tt><em>default job file filter </em>
<item> <tt>lf=</tt><em>log file </em>
<item> <tt>mx=</tt><em>maximum job size</em>
<item> <tt>lp=</tt><em>output device</em>
<item> <tt>sd=</tt><em>spool directory file </em>
<item> <tt>sh</tt><em>&nbsp;&nbsp;suppress headers (banners) </em>
<item> <tt>sf</tt><em>&nbsp;&nbsp;suppress form feeds between files</em>
</itemize>
<p>
The previous section discussed printcap entries for use by the client programs.
Now we will discuss printcap entries for use by the <tt/lpd/ server.
In simple configurations or when we have the <tt/force_localhost/
option enabled
we can use the same printcap for both LPRng clients and the <tt/lpd/
server.
<p>
<tscreen>
<verb>
# Local ASCII printer
lp1|printer
  :server
  :cm=Dumb printer
  :lp=/dev/lp1
  :sd=/var/spool/lpd/lp1
  :lf=log:af=acct
  :if=/usr/local/sbin/lpf
  :mx=0:sh:sf
</verb>
</tscreen>
<p>
<enum>
<item>
The printcap entry name is <tt/lp1/.
This information will be displayed when requesting status information using
the <tt/lpq/ program.
<item>
The <tt/printer/ alias.
This allows a single spool queue to have multiple names.
</item>
<item>
The <tt/server/ corresponds to the <tt/client/ flag
and indicates this printcap entry is for the <tt/lpd/
server only.
</item>
<item>The <tt>cm</tt> field supplies a information field
for <tt/lpq/ (printer status) output.
</item>
<item> The <tt>lp</tt> value
specifies the destination file, device or remote spool queue to which data is sent.
In this example it is the device <tt>/dev/lp1</tt>.
By default,
IO devices are opened for <em/write-only/ operation.
<item>The <tt>sd</tt> specifies the <it/spool directory/ where print job files
are stored until they are printed.
</item>
<item> The <tt/lf/ and <tt/af/ options specify the names
for the log and accounting files, respectively.
These have the default values <tt/log/ and <tt/acct/ respectively,
and if not absolute pathnames are relative to the spool queue directory.
A log file is highly recommended.
If these files don't exist, they will not be created,
and no logging or accounting will be done. You will
need to create them manually (e.g., by using <tt>touch</tt>)
or by using the
<tt><ref id="checkpc" name="checkpc"></tt>
program.
<item>
The <tt/if/ option specifies a filter program to be used
for jobs with the <tt/f/ or default job format format.
Filters and print formats are discussed in section
<ref id="secfilter" name="Filters">.
The <tt/lpf/ filter translates <tt/LF/ (line feed)
to <tt>CR/LF</tt> (carriage return/line feed) sequences,
eliminating <em>staircase</em> output.
</item>
<item><tt>mx</tt> indicates the maximum file size for a print job.
Specifying 0 means that there is no limit.
</item>
<item>The <tt>sh</tt> <it/suppress headers/ flag will suppress
printing banner pages.
<item>The <tt>sf</tt> <it/suppress form feeds/ flag will suppress
form feeds between the files of a multi-file print job.
</enum>
<sect1>The Printcap Parsing Rules
<label id="printcapparse">
<label id="server">
<label id="client">
<label id="tc">
<label id="oh">
<p>
Options used:
<itemize>
<item> <tt>client</tt><em>&nbsp;&nbsp; printcap entry valid only for client programs </em>
<item> <tt>oh</tt><em>&nbsp;&nbsp; printcap entry valid only on these hosts </em>
<item> <tt>server</tt><em>&nbsp;&nbsp; printcap entry valid only for lpd server </em>
<item> <tt>tc</tt><em>&nbsp;&nbsp; add named printcap entry contents </em>
</itemize>
<p>

In this section,
we will discuss the remaining tricky parts of the LPRng printcap
database:
combined client and server printcaps,
host specific printcap entries,
and the
<tt/tc/ <it/include/ facility.
<p>
The following is a complete description of how a printcap file is processed:
<enum>
<item>
When processing a printcap file,
the LPRng software reads and parses each entry individually.
Leading whitespace is removed.
Lines starting with <tt/#/ and blank lines are ignored.
<item>
Lines ending with <tt/\/ will have the <tt/\/ discarded,
and all lines of a printcap entry are joined by removing the line separators (<tt/\n/)
and replacing them with a space.
<item>
The printcap entry is parsed,
and the printcap name, aliases, and options are determined.
Colons <tt/:/ act as option separators,
and leading and trailing whitespaces are removed.
<item>
Options are sorted and except for the
<tt/tc=.../ option only the last option setting is retained.
<item>
Client programs will discard a printcap entry with a <tt/server/ option
and
server programs will discard a printcap entry with a <tt/client/ options.
<item>
The <tt/oh/ (<bf/o/n this <bf/h/ost) option specifies a list of
IP addresses and mask pairs or glob strings which are used to determine
if this printcap entry is valid for this host
(see discussion below).
<item>
After the above processing,
if there is an existing termcap entry with the same name,
the two sets of options are combined,
with the last option setting retained except for the <tt/tc/ entries
which are combined.
<item>
When a printcap entry is actually used,
the printcap entries listed by the <tt/tc/ include option
are extracted and combined in order.
This allows include entries to appear after the referring printcap entry.
Then printcap options will be combined with the included ones.
This has the effect that the options specified in the printcap entry
will override the ones from the <tt/tc/ included entries.
<item>
Finally,
each string printcap option with a <it/%X/ value
has <it/%X/ replaced by the following values.
Unspecified values will not be modified.
<tscreen>
<verb>
%P           printcap name
%h           short host name  (host)
%H           fully qualified host name  (host.dns.whatever)
%R           remote printer (rp value)
%M           remote host (rm value)
%D           date in YYYY-MM-DD format
</verb>
</tscreen>
<item>
When parsing multiple printcap files,
these are processed in order,
and all of their printcap entries are combined according to the
above procedures.
The <tt/tc/ resolution and <it/%X/ expansion is done after all the files
have been processed.
</enum>
<p>
The following examples show how to use the above rules
to your advantage.
You can combine both client and server printcap information in
a single file
as well as dividing a printcap entry into several parts.
Here is an example:
<tscreen>
<verb>
# seen by both client and server
lp1:lp=lp@pr1:mx=100
lp1:sd=/usr/local/spool/lp1:mx=0
# seen only by client
lp2:lp=lp@pr2:client
# seen only by server
lp2:lp=/dev/lp:server
</verb>
</tscreen>
<enum>
<item>
Printcap entries with the same name are combined.
The first printcap entry, <tt/lp1/,
the information is seen by both client and server.
The next printcap entry,  with the same name <tt/lp1/,
will be combined with the first one.
The order of options is important - the entries are scanned in order
and an option will have the last value set.
Thus,
after having read both the <tt/lp1/ printcap entries,
both client and server will have:
<tscreen>
<verb>
lp1:lp=lp@pr1
  :mx=0
  :sd=/usr/local/spool/lp1
</verb>
</tscreen>
<item>
The <tt/lp2/ has a client and server version.
This is recommended when complex printcaps on multiple hosts and servers
are used.
Thus, the LPRng clients will see:
<tscreen>
<verb>
lp1
  :lp=lp@pr1
  :mx=0
  :sd=/usr/local/spool/lp1
lp2
  :client
  :lp=lp@pr2
</verb>
</tscreen>
and the server will see:
<tscreen>
<verb>
lp1
  :lp=lp@pr1
  :mx=0
  :sd=/usr/local/spool/lp1
lp2
  :lp=/dev/lp
  :server
</verb>
</tscreen>
</enum>
<p>
If you have multiple printers of the same type whose configuration is almost
identical,
then you can define a set of <it/tc/ only printcap entries containing common
information
and use the <tt/tc/ include facility.
<p>
By convention,
all printer names start with an alphanumeric character and contain only
alphanumeric values, underscore (<tt/_/) or hyphen (<tt/-/).
A printcap entry starting with
period (<tt/./),
question mark (<tt/?/),
or
exclamation mark (<tt/!/),
is processed by LPRng
but can only be used with the <tt/tc/ include facility.
For example:
<tscreen>
<verb>
.hp:
  :sd=/usr/local/spool/%P
  :mx=0:sf:sh
hp1:tc=.hp,.filter
  :lp=lp@10.0.0.1
hp2:tc=.hp,.filter
  :lp=lp@10.0.0.2
.filter
  :if=/usr/local/libexec/filters/ifhp
  :lpd_bounce
</verb>
</tscreen>
<enum>
<item>
The <tt/.hp/ and <tt/.filter/ printcap entities will not be used as
real printcaps by LPRng,
but can be referenced by the <tt/tc/ printcap include facility.
After <tt/tc/ include processing is completed,
the printcap information would resemble:
<tscreen>
<verb>
hp1
  :lp=lp@10.0.0.1
  :if=/usr/local/libexec/filters/ifhp
  :lpd_bounce
  :mx=0
  :sd=/usr/local/spool/%P
  :sf
  :sh
hp2
  :lp=lp@10.0.0.2
  :if=/usr/local/libexec/filters/ifhp
  :lpd_bounce
  :mx=0
  :sd=/usr/local/spool/%P
  :sf
  :sh
</verb>
</tscreen>
<item>
The <it/%X/ processing will replace <tt/%P/ with the
printcap name,
so we would have:
<tscreen>
<verb>
hp1
  :lp=lp@10.0.0.1
  :if=/usr/local/libexec/filters/ifhp
  :lpd_bounce
  :mx=0
  :sd=/usr/local/spool/hp1
  :sf
  :sh
hp2
  :lp=lp@10.0.0.2
  :if=/usr/local/libexec/filters/ifhp
  :lpd_bounce
  :mx=0
  :sd=/usr/local/spool/hp2
  :sf
  :sh
</verb>
</tscreen>
</enum>
<p>
When administering a large number of printers over a large area,
it is sometimes desirable to have a <it/default/ printer for
each host.
This default printer may be different for each host,
and can be selected by using the <tt/oh/ entry.
The <tt/oh/ value is a list of the following entries
<tscreen>
<verb>
IP/n     - address + mask length    10.0.0.0/8
IP/IP    - address + mask           10.0.0.0/255.0.0.0
vvv      - glob for hostname        pc*.org.com
</verb>
</tscreen>
<p>
The LPRng software will determine the hostnames and IP addresses assigned to the
host and then check to see if there is a match in the listed hostnames
or IP addresses.
If there is a match,  the printcap entry will be used.
If not,  then the entry will be discarded.
For example:
<tscreen>
<verb>
lp:oh=*.admin.org.com,10.0.0.5,10.2.0.0/16:lp=pr1@server1
lp:oh=*.eng.org.com:lp=hp@server2
</verb>
</tscreen>
<enum>
<item>
In the above example,
if our host name is
<tt/booster.admin.org.com/,
then we would use <tt/lp=pr1@server1/,
as the <tt/*.admin.org.com/ glob pattern would match our host name.
<item>
if our host name is
<tt/booster.dev.org.com/ and our IP address is 10.2.0.1,
then we would use <tt/lp=pr1@server1/,
as the <tt>10.2.0.0/16</tt> ip address would be in the specified address range.
</enum>
<sect1>Displaying Printcap Information
<p>
If you are generating complex printcap entries,
you might need to find out exactly what the LPRng servers or clients
will actually see.
The LPRng software has several diagnostic tools to help you.
The most simple to use is the
<tt/lpc/ program.
<p>
The <tt/lpc client all/ and
<tt/lpc server all/ commands will display the printcap information that the
LPRng clients and <tt/lpc/ server would see when executing on the host.
For example:
<tscreen>
<verb>
#> lpc client all
lp1
  :lp=lp@pr1
  :mx=0
  :sd=/usr/local/spool/lp1
lp2
  :client
  :lp=/dev/lp
</verb>
</tscreen>
<sect1>Remote Printer Using RFC1179
<p>
Options used:
<itemize>
<item> <tt>lp=</tt><em>destination</em>
<item> <tt>rm=</tt><em>remote host (machine)</em>
<item> <tt>rp=</tt><em>remote printer (machine)</em>
</itemize>
<p>
You can have the <tt/lpd/ server forward jobs to another server
or print which supports the RFC1179 protocol by using the
following printcap:
<tscreen>
<verb>
# Simplest
remote|Remote Printer
   :lp=raw@server
# historical
remote:
  rp=raw:rm=server
# Sometimes you have to connect to a non-standard port
special:lp=lp@server%2000
</verb>
</tscreen>
<enum>
<item>
If the <tt/lp/ printer entry is present, it will override the
<tt/rm/ and <tt/rp/ printer entries.
<item>
The <tt/lp=pr@host/ format specifies that the output device is actually
a remote spool queue,
and jobs should be transferred using RFC1179 protocol.
<item>
By default,
LPRng will attempt to
<bf/sanitize/ all jobs that it originates or forwards.
This sanitization will result in an RFC1179 compliant <tt/control file/,
and will not modify any of the job information.
</enum>
<sect1>Remote Printer Using Socket API
<p>
If the spool queue destination is a remote printer supporting the
Socket API,
then you can have LPRng open a connection directly to the printer.
These include the older Apple printers with TCP/IP support and the
HP JetDirect supported printers.
<tscreen>
<verb>
# Simplest
remote
   :lp=10.24.2.3%9100
   :sh:sf
</verb>
</tscreen>
<enum>
<item>
The <tt/lp=server%port/ or <tt/lp=IPaddr%port/ format
specifies that <tt/lpd/ should open a TCP/IP connection to the remote
host and simply transfer verbatum the files to be printed.
<item>
The <tt/sh/ and <tt/sf/ will prevent <tt/lpd/ from trying to generate
banner pages or put form feeds between jobs.
</enum>
<p>
While this is the simplest printcap,
it is also the most dangerous as there is nothing to prevent
a malformed job from being sent to the printer.
The next printcap example is much more robust:
<tscreen>
<verb>
# Simplest
remote
   :lp=10.24.2.3%9100
   :of=/usr/local/libexec/filters/ifhp
   :if=/usr/local/libexec/filters/ifhp
   :sh:sf
</verb>
</tscreen>
<enum>
<item>
This version will use the <tt/ifhp/ filter to precondition the printer
and to process jobs.
See <ref id="ifhp" name="IFHP Filter"> for details.
The <tt/ifhp/ filter will perform the appropriate printer resets,
translate job information,
and ensure correct printer operation in the presence of errors.
It will also produce voluminous error messages and status information.
</enum>
<sect1>Parallel Printer
<p>
The parallel printer printcap is very simple.
<tscreen>
<verb>
# parallel printer
lp:
   :lp=/dev/lpr
   :sh:sf
</verb>
</tscreen>
<enum>
<item>
The <tt>lp=/dev/lpr</tt>
specifies that <tt/lpd/ should open the device for APPEND and simply transfer
job files to it.
<item>
The <tt/sh/ and <tt/sf/ will prevent <tt/lpd/ from trying to generate
banner pages or put form feeds between jobs.
</enum>
<p>
If you discover that UNIX print jobs result in a <it/staircase/
appearance,
then you need to force your printer to do <tt/LF/ (linefeed) to <tt>CR/LF</tt>
(carriage return/line feed) translation,
or do the translation yourself.
<tscreen>
<verb>
# Simple parallel printer
lp:
   :lp=/dev/lpr
   :if=/usr/local/bin/lpf
   :sh:sf
</verb>
</tscreen>
<p>
By using the <tt/if=...lpf/ filter,
the job will be passed through the <tt/lpf/ filter,
which will do the <tt/LF/ to <tt>CR/LF</tt> translation.
<p>
If you have a more complex printer that handles PostScript, PCL, and PJL,
then you will need to use the more powerful
<tt/ifhp/ filter:
<tscreen>
<verb>
# Simple parallel printer
lp:
   :lp=/dev/lpr
   :ifhp=model=hp4,status@
   :of=/usr/local/libexec/filters/ifhp
   :if=/usr/local/libexec/filters/ifhp
   :sh:sf
</verb>
</tscreen>
<p>
See <ref id="ifhp" name="IFHP Filter"> for details.
This entry will specify that the printer is an HP4,
and that no status information is available.
This is usually the case with a parallel port.
<sect1>A serial printer queue
<label id="br">
<label id="stty">
<p>
Options used:
<itemize>
<item> <tt>rw</tt><em>&nbsp;&nbsp;device opened RW flag</em>
<item> <tt>br#</tt><em>serial port bit rate</em>
<item> <tt>stty=</tt><em>stty options for serial port configuration</em>
</itemize>
<p>
The following is a typical printcap for a serial printer:
<tscreen>
<verb>
# Local Serial ASCII printer
lp2
  :lp=/dev/ttya
  :rw
  :cm=Serial printer
  :sd=/var/spool/lpd/lp2
  :stty=9600 -echo -crmod -raw -oddp -evenp pass8 cbreak ixon
  :if=/usr/local/sbin/lpf
  :mx=0:sh
</verb>
</tscreen>
<p>
Let's examine the new options:
<enum>
<item>
A serial port is usually <em/bidirectional/,
and printers will report errors back to the host computer.
The <tt/rw/ flag will cause the printer port to be opened
<tt/read-write/,
and the <tt/lpd/ server will report status information.
<item>
The <tt>stty</tt> option specifies the <tt>stty(1)</tt>
flags and line speed needed to configure the serial line
(See
<ref id="secserial" name="Serial Printers">
for details).
<item>
The legacy <tt>br</tt> (bit rate) option
can be used to specify the line speed as well.
</enum>
<sect1>Single Printcap File for Large Installation
<label id="secoh">
<p>
One of the major problems faced by administrators of large sites is how
to distribute printcap information.
They would like to have a single printcap file either distributed by
a file server (NFS) or by some other method such as <tt/rdist/.
By using the
<tt>server</tt>
and
<tt>oh</tt>
tags,
information for the specific sites can be separated out.
For example:
<tscreen>
<verb>
#/etc/printcap file
pr1:lp=pr1@serverhost1:oh=*.eng.site.com,130.191.12.0/24
pr2:lp=pr1@serverhost1:oh=*.eng.site.com,130.191.12.0/24
pr1:lp=pr2@serverhost2:oh=*.admin.site.com
pr2:lp=pr2@serverhost2:oh=*.admin.site.com
pr1:server:oh=serverhost1.eng.com:lp=/dev/lp:tc=.common
pr2:server:oh=serverhost2.admin.com:lp=/dev/lp:tc=.common
.common:sd=/usr/local/lpd/%P
</verb>
</tscreen>
<p>
The above example has some interesting effects.
The <tt>pattern</tt> is used as a <em>glob</em> pattern
and is applied to the fully qualified domain name (FQDN) of the
host reading the printcap file.
For example,
<tt>*.eng.site.com</tt> would match host
<tt>h1.eng.site.com</tt>
but would not match
<tt>h1.admin.site.com</tt>.
Thus, the effects of the first couple of entries would be to
specify that the
<tt>pr1</tt> and <tt>pr2</tt> printers on the
<tt>eng</tt> hosts would be <tt>pr1@serverhost1</tt>,
and on the
<tt>admin</tt> hosts would be <tt>pr2@serverhost2</tt>,
<p>
Also,
the lpd daemons on
<tt>serverhost1</tt>
and
<tt>serverhost2</tt>
would extract the additional
information for
<tt>pr1</tt>
and
<tt>pr2</tt> respectively,
overriding the common <tt/lp/ entries.
<sect1>Bounce queues
<label id="bq">
<label id="lpdbounce">
<label id="bqformat">
<label id="bouncequeues">
<p>
Options used:
<itemize>
<item> <tt>lpd_bounce</tt>&nbsp;&nbsp;<em>lpd filters and then forwards</em>
<item> <tt>bq=</tt><em>destination for filtered job</em>
<item> <tt>bq_format=</tt><em>format of filtered job</em>
</itemize>
<p>
When the destination of a spool queue is another spool queue
the job is simply forwarded without any modifications.
However,
sometimes it is essential that the job be modified before
forwarding,
as when the remote spool queue is actually a printer,
and
jobs need to be converted to the format acceptable by
the remote printer or banner pages added.
<p>
The <tt/lpd_bounce/ flag marks a spool queue as a bounce queue.
<tt/Lpd/ will perform all of the usually job processing steps,
such as banner generation,
filtering files,
etc,
but
saves the output to a file.
This file is then sent to the destination print queue for further
processing.
<p>
<tscreen>
<verb>
# Simple example of a bounce queue
bounce:lp=bounce@bouncehost
bounce:server
    :lp=lp@remote
    :lpd_bounce
    # LEGACY
    #bq=lp@remote
    :sd=/usr/spool/lpd/%P
    :if=/usr/local/bin/lpf
    :vf=/usr/local/bin/lpf
    :bq_format=l
    # uncomment ab if you want banner
    #ab
</verb>
</tscreen>
<p>
Some comments:
<p>
<enum>
<item>The
<tt/lpd_bounce/
option marks the job as a bounce queue,
and the <tt/lpd/ server will process the job through the appropriate
filter programs.
<item>The legacy <tt/bq=host/
has the same effect as
<tt/lpd_bounce/.
This option is retained for compatibility with previous versions of LPRng.
It is recommended that this option not be used.
<item>The printcap has filter specifications for different job formats.
These are the programs that will be used by LPRng to process the job.
<item>The
<tt>bq_format</tt>
specifies the job format for the output file sent to the remote spool queue.
If not specified, it defaults to
<tt>l</tt> (literal or binary).
<item>
The <tt>ab</tt>
(always print a banner) flag will force a banner to be
added to the job.
The banner generation is done as discussed in
<ref id="bannerprinting" name="Banner Printing">.
</item>
</enum>
<sect1>Changing Job Formats
<label id="translateformat">
<p>
Options used:
<itemize>
<item> <tt>translate_format=</tt><em>change outgoing job file formats</em>
<item> <tt>translate_incoming_format=</tt><em>change incoming job file formats</em>
</itemize>
<p>
A rarely encountered problem is when a job is printed with
one format but for compatibility needs to be processed with another.
The simple
<tt>translate_format=vlxf</tt>
option will rename format
<tt>x</tt>
files to
<tt>f</tt> format.
<p>
This can be used to resolve problems with PC based software,
which spools jobs using the <tt/v/ format.
Unfortunately,
many RCF1179 print spoolers do not understand the
<tt/v/ format and mishandle the job.
A simple forwarding queue with the following entries will rename
<tt/v/ format to <tt/l/ (binary) format.
<tscreen>
<verb>
lp
  :sd=/usr/spool/lpd/%P
  :translate_format=vl
  :lp=lp@printerserver
</verb>
</tscreen>
<p>
The <tt/translate_incoming_format/ will do the same thing,
but this time on incoming jobs.
<sect1>LPR Filters Files
<label id="lprbounce">
<p>
Options used:
<itemize>
<item> <tt>lpr_bounce</tt><em>&nbsp;&nbsp;lpr does filtering</em>
</itemize>
<p>
Some users would like the advantages of
the filtering and processing capabilities of a lpd daemon
without running a lpd daemon on their system.
By having the <tt>lpr</tt> program
process the job by passing it through the various filters
and then send the output of the filters as the print job you can
get the desired effect.
<tscreen>
<verb>
# Simple example of an lpr_bounce entry
bounce
  :lpr_bounce
  :lp=lp@remote
  :if=/usr/local/bin/lpf
</verb>
</tscreen>
<p>
The
<tt>lpr_bounce</tt>
flag, if present in the printcap entry,
will force <tt> lpr </tt> to process the job using the
specified filters and send the outputs of the filters to the remote printer
for further processing.
<sect1>Dynamic Routing
<label id="destinations">
<label id="router">
<label id="routing">
<p>
Options used:
<itemize>
<item> <tt>destinations=</tt><em>destinations for jobs</em>
<item> <tt>router=</tt><em>router program</em>
</itemize>
<p>
LPRng has the ability to route a job to one or
more destinations in a dynamic manner.
This is not the same as
<it/load balancing/,
as the destinations are hard coded and not able to be changed.
This is accomplished by having
a <tt>router</tt> filter generate a set of destinations.
Here is a sample printcap entry:
<tscreen>
<verb>
t2|Test Printer 2
    :sd=/var/spool/LPD/t2
    :lf=log
    :destinations=t1@server1,t1@server2,t1@localhost
    :router=/usr/local/LPD/router
</verb>
</tscreen>
<p>
When a job arrives at the <tt/lpd/ server,
the 'router' filter
is invoked with the standard filter options which include
the user, host, and other information obtained from the control file.
STDIN is connected to a temporary copy of the control file,
and the CONTROL environment variable is set to the value of the
actual control file itself.
<p>
The routing filter exit status is used as follows:
<itemize>
<item>
0  (JSUCC) - normal processing
<item>
37 (JHOLD) - job is held
<item>
any other value - job is deleted from queue
</itemize>
<p>
The router filter writes to STDOUT a file specifying the destinations
for the job.
The destinations entries in this file file have the following format.
Entry order is not important,
but each destination must end with the 'end' tag.
<tscreen>
<verb>
dest (destination queue)
copies (number of copies to be made)
priority (priority letter)
X(controlfile modifications)
end
</verb>
</tscreen>
<p>
Example of router output:
<tscreen>
<verb>
dest t1@localhost
copies 2
CA
priority B
end
dest t2@localhost
CZ
priority Z
end
</verb>
</tscreen>
<p>
In this example,
two copies of the job will be sent to the t1 and t2 spool queue servers.
The Class (C letter value) and job priority information will be rewritten
with the indicated values.
<p>
If routing information
is specified by the router filter the job will be sent to the default
destination.
<p>
LPQ will display job information in a slightly different format
for multiple destination jobs.  For example:
<verb>
Printer: t2@astart2 'Test Printer 2' (routed/bounce queue to 't1@astart2.astart.com')
  Queue: 1 printable jobs in queue
 Rank  Owner/ID        Class Job Files                           Size Time
active  papowell@astart2+707 A 707  /tmp/hi                         3 10:04:49
 - actv papowell@astart2+707.1 A 707 ->t1@localhost <cpy 1/2>       3 10:04:49
 -      papowell@astart2+707.2 A 707 ->t2@localhost                 3 10:04:49
</verb>
<p>
The routing information is displayed below the main job information.
Each destination will have its transfer status displayed as it is
transferred.  By convention,  the job identifier of the routed jobs
will have a suffix of the form .N added;  copies will have CN added
as well.  For example, papowell@astart2+707.1C2 will be the job
sent to the first destination, copy two.
<p>
Routed jobs can be held, removed, etc., just as normal jobs.  In addition,
the individual destination jobs can be manipulated as well.  The LPC
functionality has been extended to recognize destination jobids as well
as the main job id for control and/or selection operations.
<p>
The optional
<tt>destinations</tt> entry specifies the possible set of
destinations that the job can be sent to,
and is for informational purposes only.
In order for LPQ/LPRM to find the job once it has passed through LPD,
LPQ/LPRM uses the list of printers in the
<tt>destinations</tt>,
and loop over all the names in the list looking for the "job" that you are interested in.
If there is no
<tt>destinations</tt>
information, the
<tt>bq</tt> information will be used.
<p>
Lars Anderson &lt;<tt>lsa@business.auc.dk</tt>&gt; supplied this example
(slightly edited):
<p>
This script will attempt to distribute print jobs evenly on
2 printers hpl5a and hpl5b when sending to hpl5bounce.
<p>
<tscreen>
<verb>
hpl5bounce|for PLP/LPRng software - network based HP JetDirect card:
        :lpd_bounce
        #default
        :rp=hpl5b
        :destinations=hp5a,hp5b
        :router=/usr/local/admscripts/bouncer.pl
hpl5a|for PLP/LPRng software - network based HP JetDirect card:
        :lp=hpl5a%9100
        :tc=.hplcommon
hpl5b|for PLP/LPRng software - network based HP JetDirect card:
        :lp=hpl5b%9100
        :tc=.hplcommon
# Common settings
.hplcommon:
        :sd=/var/spool/lpd/%P
        :rw:sh:ps=status
        :fx=flp
        :if=/usr/local/libexec/filters/ifhp -Tbanner=on
        :of=/usr/local/libexec/filters/ofhp -Tbanner=on
</verb>
</tscreen>
<p>
The perl script <tt>bouncer.pl</tt> looks like this:
<p>
<tscreen>
<verb>
#!/usr/bin/perl
#
# Script for printjob load sharing
#   This is static, not dynamic balancing
#
# Printqueues to check
$printer1=&quot;hpl5a\@localhost&quot;;
$printer2=&quot;hpl5b\@localhost&quot;;
# obtain number of jobs in each printqueue
$lpq1=`/usr/local/bin/lpq -s -P$printer1`;
$lpq2=`/usr/local/bin/lpq -s -P$printer2`;
$lpq1=~ (/(\d+) jobs?/); $numjobs1=$1;
$lpq2=~ (/(\d+) jobs?/); $numjobs2=$1;
if ($numjobs1 == 0) &lcub;
    print &quot;dest $printer1\nCA\nend\n&quot;;
    exit;
&rcub;
if ($numjobs1 &gt; $numjobs2) &lcub;
    print &quot;dest $printer2\nCA\nend\n&quot;;
    exit;
&rcub;
print &quot;dest $printer1\nCA\nend\n&quot;;
</verb>
</tscreen>
<sect1>Printer Load Balancing
<p>
In a large site, you could have several equivalent printers, which
will be used by many people. The reason for this is, of course, to
increase the printer output by enabling several jobs to be printed at
once.
<p>
LPRng supplies mechanisms to define a `virtual' printer for such a set
of real printers. If properly set up, print jobs will be distributed
evenly over all printers.
<p>
<sect2>Multi-server print queue
<label id="ss">
<label id="sv">
<p>
Options used:
<itemize>
<item> <tt>ss=</tt><em>queue served by printer </em>
<item> <tt>sv=</tt><em>printers where jobs are sent (servers)</em>
</itemize>
<p>
A multi-server print queue is one that feeds jobs to other queues.
The main queue
<tt>sv=q1,q2,...</tt> printcap entry specifies the names of the printers
that will be sent jobs.
These printers must have their spool queues on this LPD server.
<p>
Servers that are fed jobs have a
<tt>ss=</tt><em>mainqueue</em>
printcap entry.
This informs the <tt>lpd</tt> server that the queue operates under the
control of the <em>mainqueue</em> print queue,
and is fed jobs from it.
<p>
During normal operation,
when the <tt>lpd</tt> server has a job to print in the <em>mainqueue</em>,
it will check to see if there is an idle <em>service</em>  queue.
If there is,
it will transfer the job to the service queue spooling directory
and start the service queue printing activities.
<p>
Users can send jobs directly to the individual printers serving a queue.
<p>
The next example (and the comments underneath) was supplied by John Perkins
&lt;<tt>john@cs.wisc.edu</tt>&gt; (slightly edited).
<p>
Here's how I've set up a bounce queue that feeds 6 LaserWriters:
<p>
<tscreen>
<verb>
laser|pi|Room 1359 LaserWriters
    :lp=laser@server.com
laser|pi|Room 1359 LaserWriters
    :server
    :lf=/usr/adm/laser-log
    :sv=laser1,laser2,laser3,laser4,laser5,laser6
    :sd=/usr/spool/laser
.commonlaser
    :sd=/usr/spool/%P
    :rw:mx=0:sh
    :lf=/usr/adm/laser1-log
    :if=/s/lprng/lib/filters/cappsif
    :of=/s/lprng/depend/cap/bin/papof
    :ss=laser
    :fx=fdginpt
laser1|pi1|Room 1359 LaserWriter #1
    :lp=laser1@server.com
laser1|pi1|Room 1359 LaserWriter #1
    :server
    :lp=/dev/laser1
    :tc=.commonlaser
laser2|pi2|Room 1359 LaserWriter #1
    :lp=laser2@server.com
laser2|pi2|Room 1359 LaserWriter #2
    :server
    :lp=/dev/laser2
    :tc=.commonlaser
</verb>
</tscreen>
<p>
and so on for the other 4 <tt>laser</tt><em>N</em> queues.
<p>
This will forward a job from <tt>laser</tt> to <tt>laser</tt><em>N</em>, once
one of those queues is available. It will hold jobs in the
``<tt>laser</tt>'' queue until one of the other queues is empty.
<p>
Even though the queues are not meant for
direct use,
people can print directly to individual queues.
This allows a specific load sharing printer to be used.
If you wanted to
<em>hide</em> the load sharing printers,
i.e. - not allow direct spooling to them,
then you would simply remove the non-server entries from the printcap.
<sect2>Checking Busy Status of Server Queues
<label id="checkidle">
<p>
Options used:
<itemize>
<item> <tt>check_idle=</tt><em>check for idle printer program </em>
</itemize>
<p>
The previous section outlined how LPRng uses the <tt>sv</tt> and <tt>ss</tt>
flags to indicate that the server spool queue has multiple destination queues.
However,
there is a problem when the actual printer being served by the destination queue
is a remote device,
and can be busy or offline.
<p>
The <tt>check_idle</tt> option specifies a program that is invoked by the
<tt>lpd</tt>
server to determine if the spool queue device is available.
<p>
The program is invoked with the standard filter options,
STDIN and STDOUT connected to <tt>/dev/null</tt>,
and STDERR to the status file.
<p>
The program should make a connection to the remote device or system
and should determine that the remote device is available for use,
and then exit with the following status.
<tscreen>
<verb>
Key      Value   Meaning
JSUCC    0       Successful - printer is idle
JABORT   non-zero Printer is not accepting jobs
</verb>
</tscreen>
<p>
If the printer is accepting jobs but is temporarily busy,
the program should poll the printer until it becomes free,
only exiting when it is available for use.
If the printer is not accepting jobs, the program should exit with a non-zero
exit code.
<p>
The following is a sample printcap entry, showing how the <tt>check_idle</tt>
facility can be used.
<tscreen>
<verb>
pr:
  :lp=laserjet%9100
  :check_idle=/usr/local/filters/remote_check lp@laserjet
  :if=/usr/local/filters/ifhp
</verb>
</tscreen>
<p>
The following perl program shows how to generate a query to the
remote printer by simulating an <tt>lpq</tt> query and checking for
returned status.
<tscreen>
<verb>
#!/usr/local/bin/perl
# Usage:
#  remote_check printer@host[%port] [-options]
#   -Tflag[,flags]*
#  flag
#    debug  - turns debugging on
#    long   - use long status format
#
# query the remote printer whose name is passed on the command line
#
# Note that -Txxx options are passed AFTER the printer
use English;
use IO::Socket;

my $JSUCC = 0;
my $JABORT = 33;
my $JNOSPOOL = 38;
my $JNOPRINT = 39;

my $debug = 0;
my $optind;

# pull out the options
my($key,$value,$opt,$long,$opt_c);

$printer = $ARGV[0];

for( $i = 1; $i < @ARGV; ++$i )&lcub;
    $opt = $ARGV[$i];
    print STDERR "XX opt= $opt\n" if $debug;
    if( $opt eq '-c' )&lcub;
        $opt_c = 1;
    &rcub; elsif( ($key, $value) = ($opt =~ /^-(.)(.*)/) )&lcub;
        if( $value eq "" )&lcub;
            $value = $ARGV[++$i];
        &rcub;
        $&lcub;"opt_$key"&rcub; = $value;
        print STDERR "XX opt_$key = " . $&lcub;"opt_$key"&rcub; . "\n" if $debug;
    &rcub; else &lcub;
        $optind = $i;
        last;
    &rcub;
    print STDERR "XX opt_P = $opt_P\n" if $debug;
&rcub;

$long = 0;  # short

if( defined($opt_T) )&lcub;
    print STDERR "XX CHECK_REMOTE opt_T=$opt_T\n" if $debug;
    if( $opt_T =~ /debug/ )&lcub;
        $debug = 1;
    &rcub;
    if( $opt_T =~ /short/ )&lcub;
        $long = 1;
    &rcub;
    if( $opt_T =~ /long/ )&lcub;
        $long = 0;
    &rcub;
&rcub;

print STDERR "XX CHECK_REMOTE " . join(" ",@ARGV) . "\n" if $debug;

if( !defined($printer) or $printer =~ /^-/ )&lcub;
    print STDERR "$0: no printer value\n";
    exit( $JABORT );
&rcub;

while( checkstatus( $printer, $long ) )&lcub;
    print STDERR "XX CHECK_REMOTE sleeping\n" if $debug;
    sleep(10);
&rcub;

exit $JSUCC;

sub checkstatus &lcub;
    my ($printer,$long) = @_;
    my ($remote,$port);
    my ($count, $socket, $line);

    if( $long )&lcub;
        $long = 4;
    &rcub; else &lcub;
        $long = 3;
    &rcub;
    if( $printer =~ /@/ )&lcub;
        ($printer,$remote) = $printer =~ m/(.*)@(.*)/;
    &rcub;
    $remote="localhost" unless $remote;

    if( $remote =~ /%/ )&lcub;
        ($remote,$port) = $remote =~ m/(.*)%(.*)/;
    &rcub;
    $port = 515 unless $port;
    print STDERR "XX CHECK_REMOTE remote='$remote',"
        . " port='$port', pr='$printer', op='$long'\n" if $debug;

<p>
    $socket = getconnection( $remote, $port );

    $count = -1;
    # send the command
    printf $socket "%c%s\n", $long, $printer;

    while ( defined( $line = <$socket>) && $count < 0 )&lcub;
        chomp $line;
        print STDERR "XX CHECKREMOTE '$line'\n" if $debug;
        if( $line =~ /printing disa/ )&lcub;
            print STDERR "XX CHECKREMOTE printing disable\n" if $debug;
            exit $JNOPRINT;
        &rcub; elsif( $line =~ /spooling disa/ )&lcub;
            print STDERR "XX CHECKREMOTE printing disable\n" if $debug;
            exit $JNOSPOOL;
        &rcub; elsif( $line =~ /([0-9]*)\s+job.?$/ )&lcub;
            $count = $1;
            print STDERR "XX CHECKREMOTE $count jobs\n" if $debug;
        &rcub;
    &rcub;
    close $socket;
    if( $count < 0 )&lcub;
        print STDERR "CHECKREMOTE cannot decode status\n";
        exit $JABORT;
    &rcub;
    return $count;
&rcub;

sub getconnection &lcub;
    my ($remote,$port) = @_;
    my ($socket);
    print STDERR "XX CHECK_REMOTE remote='$remote', port=$port\n" if $debug;
    $socket = IO::Socket::INET->new(
        Proto => "tcp",
        PeerAddr => $remote,
        PeerPort => $port,
        );
    if( !$socket )&lcub;
        print STDERR "CHECK_REMOTE IO::Socket::INET failed - $!\n";
        exit $JABORT;
    &rcub;
    $socket->autoflush(1);
    $socket;
&rcub;
</verb>
</tscreen>
<p>
The example of the previous section can be modified now
so that it uses the <tt>check_idle</tt> facility.
The master queue will send jobs only to the server queue queues
which report idle status.
<tscreen>
<verb>
laser1|pi1|Room 1359 LaserWriter #1
    :server:check_idle=/usr/local/libexec/filters/remote_check pr@laser1
    :lp=laser1%9100
    :tc=@commonlaser
laser2|pi2|Room 1359 LaserWriter #2
    :server:check_idle=/usr/local/libexec/filters/remote_check pr@laser1
    :lp=laser2%9100
    :tc=@commonlaser
</verb>
</tscreen>
<sect1>Locations of Printcap Files
<label id="lpdprintcappath">
<label id="printcappath">
<label id="details">
<p>
Options used:
<itemize>
<item> <tt>printcap_path=</tt><em>printcap file locations</em>
<item> <tt>lpd_printcap_path=</tt><em>additional server printcap file locations</em>
</itemize>
<p>
The
<tt>printcap_path </tt>
and
<tt> lpd_printcap_path </tt>
configuration options (see
<ref id="lpdconf" name="lpd.conf(5)">) specify a set of paths for the
printcap information.
Client programs use only <tt>printcap_path</tt> and the <tt>lpd</tt>
server uses both
<tt>printcap_path</tt> and <tt>lpd_printcap_path</tt>.
The path names can be separated with whitespace,
commas, semicolons, or colons.
The default values are:
<tscreen>
<verb>
printcap_path      /etc/printcap /usr/etc/printcap
lpd_printcap_path  /etc/lpd_printcap /usr/etc/lpd_printcap
</verb>
</tscreen>
<sect2>Separate Server and Client Printcap Files
<p>
Since only the LPD server uses the
printcap file specified by the
<tt/lpd_printcap_path/,
you can place server specific information there.
This allows you to have a common printcap file for clients and an
additional one for the lpd servers.
<sect2> ALL Printcap Entry
<label id="allpc">
<p>
The <tt/all/ printcap name and <tt/all/ option
is reserved to provide a list of printers
available for use by the spooling software.
This is a desperation,
last ditch,
back to the wall option for
administrators
with systems that do not have ways to provide a list of printcap entries.
The 'all' printcap entry has the form:
<tscreen>
<verb>
all:all=pr1,pr2,...
</verb>
</tscreen>
<p>
The value of the <tt/all/ option should be a list of printcap names
whose values will then be extracted.
<sect1>Management Strategies for Large Installations
<p>
One very effective way to organize print spooling is to have a small
number of print servers running a
<tt>lpd</tt> daemon,
and to have all the other systems send their jobs directly to them.
By using the above methods of specifying the printer and server host
you eliminate the need for more complex management strategies.
<p>
However,
you still need to inform users of the names and existence of these printers,
and how to contact them.
One method is to use a common
<tt>/etc/printcap</tt>
file which is periodically updated and transfered to all sites.
Another method is to distribute the information using the
NIS or some other database.
LPRng has provided a very flexible method of obtaining and distributing
database information:  see
<ref id="secnis" name="Using Programs To Get Printcap Information">
for details.
<sect1>Using Programs To Get Printcap Information
<label id="secnis">
<p>
In the
<tt>lpd.conf</tt>
file you can specify:
<tscreen>
<verb>
printcap_path=|program
</verb>
</tscreen>
This will cause the LPRng software to execute the specified program,
which should then provide the printcap information.
The program is invoked with the standard filter options,
and has the name of the printcap entry provided on
<tt>STDIN</tt>.
The filter
should supply the printcap information on
<tt>stdout</tt>
and exit with a 0
(success) error code.  By convention,  the printcap name 'all'
requests a printcap entry that lists all printers.
<p>
This technique has been used to interface to the Sun Microsystem NIS
and NIS+ databases with great success.
By having the invoked program a simple shell script or front end to the
<tt>nismatch</tt> or <tt>ypmatch</tt> programs,
the complexity of incorporating vendor specific code is avoided.
<sect2>How to use NIS and LPRng
<p>
This note is based on material sent to the
<tt>lprng@lprng.org</tt>
mailing list by
Paul Haldane
<tt>&lt;paul@ucs.ed.ac.uk></tt>.
<p>
<tscreen>
<verb>
 # From: Paul Haldane <paul@ucs.ed.ac.uk>
 # To: lprng@lprng.org
 # Subject: Re: Problem using plp with NIS
 #
</verb>
</tscreen>
<p>
We generally don't use NIS for printcap files (we've
moved to hesiod) but I can show you what we've done in the past.
<p>
The input to NIS is a normal printcap file:
<tscreen>
<verb>
# Classical printcap entry
lp23a|lp23|lp|main printhost printer - KB, EUCS front Door:\
        :lp=lp23a@printhost:\
        :sd=/usr/spool/lpr/lp23a:

#lprng printcap entry
lplabel|lpl|TEST - Labels printer:
        :lp=:rm=printhost:rp=lplabel:
        :sd=/usr/spool/lpr/lplabel:
        :rg=lpadm:mx=1:
</verb>
</tscreen>
<p>
To build the NIS printcap.byname map we add the following to
the NIS makefile (along the other bits and pieces that the makefile
needs to know about a new map).
<tscreen>
<verb>
PRINTCAP=$(DIR)/printcap
#PRINTCAP=/etc/printcap
# warning : [  ] is actually [<space><tab>] in the script
printcap.time: $(PRINTCAP) Makefile
  if [ -f $(PRINTCAP) ]; then \
    sed < $(PRINTCAP) \
      -e 's/[   ][  ]*$$//' -e '/\\$$/s/\\$$/ /' \
    | awk '$$1 ~ /^#/&lcub;next;&rcub; $$1 ~ /^[:|]/ &lcub;printf "%s", $$0; next;&rcub; \
        &lcub;printf "\n%s", $$0 &rcub;' \
    | sed -e 's/[   ]*:[  ]*:/:/g' -e 's/[  ]*|[  ]*/|/g' \
      -e '/^[   ]*$$/d' > .printcap.$$$$; \
    cat .printcap.$$$$; \
    if [ $$? = 0 -a -s .printcap.$$$$ ]; then \
      awk <.printcap.$$$$ '&lcub; FS=":"; OFS="\t"; &rcub; &lcub; \
          n = split($$1, names, "|"); \
          for (i=1; i<=n; i++) \
              if (length(names[i]) > 0 \
              && names[i] !~ /[ \t]/) \
                  print names[i], $$0; \
      &rcub;' | $(MAKEDBM) - $(YPDBDIR)/$(DOM)/printcap.byname; \
      awk <.printcap.$$$$ '&lcub; FS=":"; OFS="\t"; &rcub; &lcub; \
          n = split($$1, names, "|"); \
          if (n && length(names[1]) > 0 && names[1] !~ /[ \t]/) \
              print names[1], $$0; \
      &rcub;' | $(MAKEDBM) - $(YPDBDIR)/$(DOM)/printcap.bykey; \
      rm -f .printcap.$$$$; \
      touch printcap.time; echo "updated printcap"; \
    fi \
  fi
  @if [ ! $(NOPUSH) -a -f $(PRINTCAP) ]; then \
      $(YPPUSH) printcap.byname; \
      $(YPPUSH) printcap.bykey; \
      touch printcap.time; echo "pushed printcap"; \
  fi
</verb>
</tscreen>
<p>
To specify that you want YP database rather than file access,
use the following entry in your <tt>/etc/lpd.conf</tt> file:
<tscreen>
<verb>
printcap_path |/usr/local/libexec/pcfilter
</verb>
</tscreen>
<p>
Put the following shell script in /usr/local/libexec/pcfilter
<tscreen>
<verb>
#!/bin/sh
#/usr/local/libexec/filters/pcfilter
read key
ypmatch "$key" printcap.byname
</verb>
</tscreen>
<p>
<sect2>How to use NIS and LPRng - Sven Rudolph
<p>
<tscreen>
<verb>
 Date: Wed, 11 Sep 1996 00:11:02 +0200
 From: Sven Rudolph <sr1@os.inf.tu-dresden.de>
 To: lprng@lprng.org
 Subject: Using :oh=server: with NIS
</verb>
</tscreen>
<p>
When I use a cluster-wide printcap,
two entries for each printer will appear, e. g.:
<tscreen>
<verb>
---------- start of /etc/printcap snippet
lp1
 :lp=lp1@server
lp2
 :lp=lp2@server
lp1
 :server:oh=servername
 :sd=/var/spool/lpd/lp1
 :lp=/dev/lp1
 :sh:mx=0
---------- end of /etc/printcap snippet
</verb>
</tscreen>
<p>
When I create a NIS map out of this,
the printer name is used as a key
and must be unique. So NIS' makedbm decides to drop all but the last
entry for each printer. This makes the printer on the clients
unavailable.
I solved this by a hack where the second entry is called lp1.server
and the NIS client script has to request the right entry.
<enum>
<item>
Assumptions
<p>
Perl is available at the YP server in /usr/bin/perl .
A Bourne Shell is available at all clients in /bin/sh
The printcap that is to be exported is in /etc/printcap .
The printcap is written in the new format.
<p>
In the examples the printer is called lp1 .
</item>
<item>
Add the following to your YP Makefile (/var/yp/Makefile) on the YP
server :
<tscreen>
<verb>
---------- start of /var/yp/Makefile snippet
PRINTCAP  = /etc/printcap
printcap: $(PRINTCAP)
    @echo "Updating $@..."
    $(CAT) $(PRINTCAP) | \
        /usr/lib/yp/normalize_printcap | $(DBLOAD) -i $(PRINTCAP) \
        -o $(YPMAPDIR)/$@ - $@
    @if [ ! $(NOPUSH) ]; then $(YPPUSH) -d $(DOMAIN) $@; fi
    @if [ ! $(NOPUSH) ]; then echo "Pushed $@ map." ; fi
---------- end of /var/yp/Makefile snippet
</verb>
</tscreen>
<p>
(These lines are for Debian GNU/Linux, other systems might require
other modifications)
<item>
Install the programs <tt>match_printcap</tt>
and <tt>normalize_printcap</tt> to <tt>/usr/lib/yp</tt>.
normalize_printcap
is only required on the YP server.
The <tt>normalize_printcap</tt> processes only the LPRng printcap format.
<tscreen>
<verb>
---------- start of /usr/lib/yp/normalize_printcap
#! /usr/bin/perl
$debug = 0;
$line = "";
$new = "";
while (<>) &lcub;
    chomp;
    next if ( /^\s*\#.*/ );
    s/^\s*$//;
    next if ( $_ eq '' );
    print "new: " . $_ . "\n" if $debug;;
    if (/^\s/) &lcub; # continuation line
        $line = $line.$_;
        print "continued: $line\n" if $debug;
        next;
    &rcub; else &lcub;
        $line =~ s/\s+\:/:/g;
        $line =~ s/\:\s+/:/g;
        $line =~ s/\:\s*\:/:/g;
        print "line: $line\n" if $debug;
        push(@lines, $line) if $line;
        $line = $_;
    &rcub;
&rcub;
$line =~ s/\s+\:/:/g;
$line =~ s/\:\s+/:/g;
$line =~ s/\:\s*\:/:/g;
push(@lines,$line) if $line;
@lines = sort(@lines);
foreach $line (@lines) &lcub;
    ($printers) = split(/\:/,$line);
    @printers = split(/\|/,$printers);
    foreach $printer (@printers) &lcub;
      $num&lcub;$printer&rcub;++;
      push(@allprinters,$printer);
      print "allprinters: @allprinters\n" if $debug;
      print $printer."_".$num&lcub;$printer&rcub;."\t$line\n";
    &rcub;
&rcub;
@pr = keys %num;
print "printers @pr\n" if $debug;
if ($#allprinters >=0) &lcub;
    print "all_1\tall:all=".join(",",@pr)."\n";
&rcub;
---------- end of /usr/lib/yp/normalize_printcap
</verb>
</tscreen>
<p>
The result of processing the sample printcap file is:
<tscreen>
<verb>
lp1_1 lp1:lp=lp1@server
lp1_2 lp1:server:oh=servername:sd=/var/spool/lpd/lp1:lp=/dev/lp1:sh:mx=0
lp2_1 lp2:lp=lp2@server
all_1 all:all=lp1,lp2
</verb>
</tscreen>
<p>
Observe that each of the real printer entries has a key consisting of the
printer name with a numerical suffix.
This leads to the following method of extracting the printcap information
using <tt>ypmatch</tt>:
<tscreen>
<verb>
---------- start of /usr/lib/yp/match_printcap
#!/bin/sh
read p
n=1
while ypmatch "$&lcub;p&rcub;_$&lcub;n&rcub;" printcap 2>/dev/null; do
    n=`expr $n + 1`
done
---------- end of /usr/lib/yp/match_printcap
</verb>
</tscreen>
<item>
Now test the YP arrangement:
<tscreen>
<verb>
$ cd /var/yp; make # this should create the printcap map
$ ypcat printcap # should provide the whole normalized printcap
$ echo lp1 |/usr/lib/yp/match_printcap # yields lp1 printcap
</verb>
</tscreen>
<item>
Add the printcap_path entry to <tt>/etc/lpd.conf</tt>:
<tscreen>
<verb>
printcap_path=|/usr/lib/yp/match_printcap
</verb>
</tscreen>
<item>
Test the use of the printcap path entry:
<tscreen>
<verb>
$ lpq -Plp1 # shows the status of lp1
</verb>
</tscreen>
<item>
Restart the lpd server and check to see that it accesses
the right printcap information.
Use the same <tt>lpq</tt> command,
and then try <tt>lpc printcap lp1</tt>.
</enum>
<sect1>Lexmark Printers
<p>
Some Lexmark printers do not send
<em>end of job</em> status back unless configured
to do so.
Here is what is needed to force this.
(This capability has been incorporated into the <tt/ifhp/ filter.)
<tscreen>
<verb>
From: Matt White <whitem@bofh.usask.ca>
To: lprng@lprng.com
Date: Wed, 21 Jan 1998 18:25:50 -0600 (CST)
Subject: Re: [LPRng] ifhp with Lexmark Optra N printer

On Wed, 21 Jan 1998, Simon Greaves wrote:

> Apologies in advance if this is way off mark, but we've been evaluating a
> commercial print charging package (Geomica) which works by talking to the
> printer in what I think is a similar way to the ifhp filters. Lexmarks are
> currently a big headache because they seem to fail to return the message
> that they have finished printing which screws things up somewhat. In our
> case, it is believed to be a problem with the Lexmark firmware which they
> are looking into.

There is a fix for that...it is originally from the Lexmark 4039 series,
but it still works on the Optra S 1650 machines that we have (and should
work on the rest of the optra line).  Just send this little chunk of
postscript to the printer once:

-----------snip----------
%! Postscript utility file to set the 4039 printer into synchronous mode
serverdict begin 0 exitserver
statusdict begin true setenginesync end
-----------snip----------

Basically, it causes the printer to wait until it is finished printing
before actually reporting that it is done.  I've got 3 Optra S printers
running with ifhp right now with no extra options (just defaults).

---------------------------------------------------------------------
- Matt White                         whitem@arts.usask.ca           -
- Network Technical Support          http://arts.usask.ca/~whitem   -
- College of Arts & Science          University of Saskatchewan     -
---------------------------------------------------------------------
</verb>
</tscreen>
<sect1>Tektronix Phaser Printers
<label id=P450>
<p>
The <tt/ifhp/ filter supports the
<ref id="appsocket" name="AppSocket"> protocol used by Tektronix.
You will need a printcap similar to the following:
<tscreen>
<verb>
phaser:
 :sd=/var/spool/lpd/%P
 # need a dummy device for output
 :lp=/dev/null
 # You need to specify the IP address of the printer's network interface
 #  In this example it is 10.0.0.1 - replace with the correct value
 # The filter will actually open the connection.
 :if=/usr/local/libexec/filters/ifhp -Tdev=10.0.0.1%9100,model=tek
</verb>
</tscreen>
<sect1>Duplex Printing
<p>
Duplex printing is when you print on both sides of a page.
Some printers which do duplex printing require that you
send them special commands to force this mode.  This is
usually done by the FILTERS.  The IFHP filter makes a stab at sending
the PJL or PostScript commands to the printer.  Many people have
reported problems doing duplex printing,  so  here is a check
list.
<enum>
<item>
Make sure you have enough memory for the worst case
print job.  Usually the printer has to rasterize both
pages before it can produce an impression.  It may require
much more memory than you expect.
<item>
Check your printer manual to discover the EXACT form of the
<tt>enter duplex mode</tt> command and make sure that either the command
is part of the job (PJL language at the start of the job,
postscript header, etc), or that the filter generates the
correct form.
<p>
Note there is a PostScript Printer Description file (PPD) for
most printers that support PostScript,  and they even have the
PJL and PostScript code for this in the PPD file.
<item>
It has been observed that even with what would apparently be
sufficient memory,  that many duplex jobs print 'oddly',
that they are not aligned on the same side in the same way,
etc etc.  This may not be the fault of the software,  but of the
support for duplex operation.
<item>
Read the IFHP documentation,
and create a configuration section in the <tt/ifhp.conf/ file
for your printer.
</enum>
<p>
I know this is painful,  but until there is a uniform way to get the
correct commands extracted from either PPD or some other database then
this appears to be the only way to do it.
<quote>
<em>
Patrick Powell
</em>
</quote>
<sect1>Solaris, Newsprint and FrameMaker
<p>
The following is a guide to using LPRng and
Sun Microsystems Newsprint by
Christopher Hylands, Ptolemy Project Manager
of the University of California.
<p>
The Sun Newsprint printer is actually
an OEM version of the  Tektronix PhaserII;
Sun Microsystems appears to have dropped support for Newsprint,
and the recommended migration path is to buy a PostScript printer.
If you want more information on using the Newsprint system,
notes are available via
<tt>http://ptolemy.eecs.berkeley.edu/~cxh/lprng.html</tt>.
<p>
Looking through the mailing list logs, it looks like everyone was
having a hard time getting lprng to work with Sun's brain-dead
newsprinters.  I tried using GhostScript, but the fonts were, IMHO,
ugly, so I spent a little time getting the newsprint fonts to work.
<p>
The key thing was to grab the file
<tt>/usr/newsprint/lpd/if</tt>
from a SunOS4.1.3 newsprint installation.
If you cannot get this code,
then the installation will be extremely difficult.
<p>
To install lprng on a Solaris2.x machine,
you need to first stop the existing print services and install the
startup scripts for LPRng.
Note that if there is a local printer, you may have
to also fix the permissions of the device. Typical commands are:
<tscreen>
<verb>
chown daemon /devices/sbus@1,f8000000/SUNW,lpvi@1,300000:lpvi0
</verb>
</tscreen>
<p>
We use the following simple <tt>if</tt> script.
<tscreen>
<verb>
#/bin/sh
# extremely simple filter script
/bin/cat
</verb>
</tscreen>
<p>
The Sparcprinters use licensed fonts from NeWSprint. To use the
licensed fonts, you must have the lprng spool directory for the
sparcprinter in the same location as spool directory of the brain
dead Solaris lp system.  If your printer is named xsp524, then this
directory would be <tt> /etc/lp/printers/xsp524</tt>.
<p>
The printcap entry looks like:
<tscreen>
<verb>
sp524|524:
    :mx=0:sf:sh:sb:
    :lp=:rm=doppler:rp=xsp524:
    :sd=/var/spool/lpd/sp524d:
    :lf=/var/spool/lpd/sp524d/log:
xsp524|Sun SPARCprinter NeWSprint printer:
    :mx=0:sf:sb:sh:rs:
    :lp=/dev/lpvi0:
    :sd=/etc/lp/printers/xsp524:
    :lf=/etc/lp/printers/xsp524/log:
    :af=/var/spool/lpd/xsp524/acct:
    :if=/usr/local/libexec/newsprint/if:
</verb>
</tscreen>
<p>
The
<tt>/usr/local/libexec/newsprint/if</tt>
was copied from
<tt>/usr/newsprint/lpd/if</tt>
in a SunOS4.x installation of the newsprint
software.
Unfortunately, the newsprint engine is so brain dead that it
needs many environment variables set, so it is fairly difficult to
come up with a clean script to start the engine. I made the following
changes to the file.
<enum>
<item>
First, set the path in the script.
You may also need to change defaults to suit your preferences:
<tscreen>
<verb>
PATH=/usr/ucb:/usr/bin:/etc:/usr/etc:/opt/NeWSprint/bin:/opt/NeWSprint/np/bin:
PATH=$PATH:$NPHOME/pl.$ARCH/bin:$NPHOME/np/bin; export PATH
</verb>
</tscreen>
</item>
<item>
You will also need a
<tt>/etc/lp/printers/printername/.params</tt>
file. If you
are using the same spooler directory as the directory that the Solaris
lp system uses, then the .param file should appear there. If you are
using a different spooler directory, then you will need to copy
the .param file from elsewhere and edit it accordingly.
</item>
<item>
If you are going to move a license to a new printer, you should
probably save the .param file in the old printer spooler directory.
Run /opt/NeWSprint/bin/fp_install and remove the license from the
old printer and assign it to the new printer.
You could run /opt/NeWSprint/bin/rm_np_printer and remove the printer,
but that will get rid of the .param file
</item>
<item>
FrameMaker under Solaris2.x uses the lp command. The fix is to edit
$FMHOME/fminit/FMlpr and comment out the lp line and add an lpr line
<tscreen>
<verb>
sunxm.s5.sparc)
    lpr -P"$PRINTER" "$FILE"
    #lp -c -d"$PRINTER" "$FILE"
</verb>
</tscreen>
</item>
</enum>
<tscreen>
<verb>
Christopher Hylands, Ptolemy Project Manager  University of California
cxh@eecs.berkeley.edu                 US Mail: 558 Cory Hall #1770
ph: (510)643-9841 fax:(510)642-2739       Berkeley, CA 94720-1770
home: (510)526-4010 (if busy -4068)       (Office: 493 Cory)
</verb>
</tscreen>
<sect>LPRng checkpc Utility
<label id="checkpc">
<p>
The <tt>checkpc</tt> (check printcap file) is one of the most
useful utilities in the LPRng package.
<p>
It will read all the configuration files, printcap files and tests
whether devices are set up correctly. Optionally, it will also set the
permissions for spool directories and device files. Additionally, it
will truncate the accounting and log files to a maximum size. Another
use for <tt>checkpc</tt> is to remove old entries from queue
directories.
<p>
For a new installation, you will want to run
<tscreen>
<verb>
checkpc -f -V
</verb>
</tscreen>
to set the permissions right. The <tt>-f</tt> flag instructs the
program to correct file permissions. If you don't run this as
<tt>root</tt>, you'll receive a warning about that fact and any
<bf>chown(2)</bf> calls will (most likely) fail.
<p>
The program reports everything it changes. Since it isn't too clever
about some things (visit the man page), you should keep an eye on the
output, and run it again if needed. If it keeps failing, change the
permissions yourself.
<sect1>Maintenance
<p>
Later, you will want to use <tt>checkpc</tt> for the daily
maintenance of your system. I have this line in user <tt>lp</tt>'s
crontab:
<tscreen>
<verb>
32 5 * * * checkpc -t 10K -A3 -r &gt;/dev/null 2&gt;&1
</verb>
</tscreen>
This job will:
<enum>
<item>truncate all log and accounting files to 10KB (<tt>-t 10K</tt>).
Actually, it will keep the last 10K from the file, starting on a
complete line.</item>
<item>remove all stale files older than three days (<tt>-A3 -r</tt>).</item>
</enum>
I'm redirecting output to <tt>/dev/null</tt>, because <tt>checkpc</tt>
is a little noisy to my taste. (But too noisy is better than too
silent :)
<sect1> Printcap Information
<p>
You can use <tt/checkpc -V -P/
to examine printcaps and tell you what
they contain.
This is identical to the <tt/lpc server all/ operation,
but with a higher level of verbosity.
<sect>Spool Queues and Files
<label id="sd">
<label id="cd">
<p>
When files are accepted by the <tt>lpd</tt> server for printing,
they are stored in a spool queue directory,
together with other files controlling the print operation.
This section describes these files and how the LPRng software uses them.
<p>
For descriptive purposes,
we will use the following printcap entry as a guide:
<p>
<tscreen>
<verb>
pr|alias
  :sd=/var/lpd/pr_public
  :cd=/var/lpd/pr
</verb>
</tscreen>
<sect1>Spool Queue
<p>
<itemize>
<item> <tt>sd=</tt><em>Spool queue directory name</em>
</itemize>
<p>
The
<tt>sd</tt>
option in the printcap entry specifies the spool queue
directory.
If there is no
<tt>sd</tt>
entry or value,
then the printer can only be used by the clients such as <tt>lpr</tt>
to locate the destination for a print job.
All information,
files,
etc.,
for a print queue is stored in the spool directory.
<sect1>Queue Lock File
<label id="queue_lock_file">
<p>
<itemize>
<item> <tt>spool_lock_file</tt><em>&nbsp;&nbsp;spool queue lock file - default %P</em>
</itemize>
<p>
When the <tt>lpd</tt> server starts printing,
it will fork individual worker processes to service each queue.
To prevent multiple processes from working on the same queue,
a printer lock file specified by the
<tt/queue_lock_file/ option
(default <tt/%P/ - the %P is expanded to the print queue name)
is used.
In our example,
the lock file would be:
<tt>/var/lpd/pr/pr</tt>.
<p>
The process ID of the currently active printer is stored in the lock file.
By reading the lock file and testing to see if the process is still active,
programs such as <tt/lpq/ can determine queue activity.
<p>
Similarly,
the worker process may need to create other processes to assist it.
These in turn will create lock or temporary files in the spool directory
as well.
<sect1>Spool Control File
<label id="queue_control_file">
<p>
<itemize>
<item> <tt>spool_control_file</tt><em>&nbsp;&nbsp;spool queue control file - default control.%P</em>
</itemize>
<p>
The spool control file is used to control the operations of the
spooler,
and is in the spool or control directory.
The file name specified by the
<tt/queue_control_file/ option
(default <tt/control.%P/ - the %P is expanded to the print queue name);
in our example,
the control file would be:
<tt>/var/lpd/pr/control.pr</tt>.
<p>
The <tt>lpc</tt> program sends spool control requests to the
<tt>lpd</tt> daemon,
which updates the control file and then signals the appropriate
spool server processes that an update has been performed.
The control file contents have the form:
<tscreen>
<verb>
key value
</verb>
</tscreen>
<p>
The following keys and their values are currently supported.
<p>
<!--  START TABLE2 -->
<tt>printing_disabled&nbsp;&nbsp;&nbsp;</tt>
<tt>0 or 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>
<tt>disable printing of jobs in queue</tt> <newline>
<tt>spooling_disabled&nbsp;&nbsp;&nbsp;</tt>
<tt>0 or 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>
<tt>disable placing jobs in queue</tt> <newline>
<tt>holdall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>
<tt>0 or 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>
<tt>hold jobs until released</tt> <newline>
<tt>redirect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>
<tt>printer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>
<tt>transfer jobs to indicated printer</tt> <newline>
<tt>class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>
<tt>glob expression&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>
<tt>print only jobs whose class matches glob expression</tt> <newline>
<tt>server_order&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>
<tt>printer name list&nbsp;&nbsp;&nbsp;</tt>
<tt>preferred order of printer use</tt> <newline>
<tt>debug&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>
<tt>debugging options&nbsp;&nbsp;&nbsp;</tt>
<tt>debugging and tracing</tt> <newline>
<!--  END TABLE2 -->
<p>
The <tt>printing_disabled</tt> and <tt>spooling_disabled</tt>
are managed using the <tt>lpc start</tt>, <tt>lpc stop</tt>,
<tt>lpc enable</tt> and <tt>lpc disable</tt>
commands.
Similarly,
<tt>holdall</tt> is enabled and disabled by <tt>holdall</tt> and
<tt>noholdall</tt>
commands respectively.
When holdall is enabled,
jobs placed in the print queue will be held until they are explicitly
released for printing by an <tt>lpc release</tt> command.
<p>
The <tt>redirect</tt> entry is used to redirect or transfer jobs
which are spooled to this queue to another queue,
and is managed by the redirect command.
The <tt>lpc redirect off</tt> removes the redirect entry from the
control file.
<p>
The <tt>class</tt> entry is similar in operation to the
<tt>holdall</tt>,
but allows jobs whose class identification matches the glob
expression to be printed.
This can be useful when you have special forms or paper required for a
print job,
and want to run only these jobs when the paper is in the printer.
<p>
The <tt>server_order</tt>
entry is created and updated for a multiple printer queue.
It records the order in which printers should next be used
for normal print operations.
This allows <em>round robin</em> use of printers,
rather than having all jobs printed to the first printer in the
list of printers.
<p>
The <tt>debug</tt>
entry is set by the <tt>lpc debug</tt> command,
and is used to enable or disable debugging and tracing information
for a spool queue.
This facility is for diagnostic purposes only.
<sect1>Log and Status Files
<label id="lf">
<label id="ps">
<label id="short_status_date">
<label id="maxstatusline">
<label id="maxstatussize">
<label id="minstatussize">
<label id="maxlogfilesize">
<label id="minlogfilesize">
<label id="createfiles">
<label id="queue_status_file">
<p>
<itemize>
<item> <tt>create_files</tt><em>&nbsp;&nbsp;create log, accounting and status files</em>
<item> <tt>lf=</tt><em>log file name (default: log)</em>
<item> <tt>max_log_file_size#</tt><em>&nbsp;&nbsp;maximum log file size (Kbytes)</em>
<item> <tt>min_log_file_size#</tt><em>&nbsp;&nbsp;minimum log file size (Kbytes)</em>
<item> <tt>max_status_line#</tt><em>&nbsp;&nbsp;maximum status line length (characters) </em>
<item> <tt>max_status_size#</tt><em>&nbsp;&nbsp;maximum status file size (Kbytes)</em>
<item> <tt>min_status_size#</tt><em>&nbsp;&nbsp;minimum status file size (Kbytes)</em>
<item> <tt>ps=</tt><em>filter status file name (default: status)</em>
<item> <tt>queue_status_file=</tt><em>queue status file (default: status.%P)</em>
<item> <tt>short_status_date=</tt><em>display short (hh:mm) timestamp (default: true)</em>
</itemize>
<p>
During operation,
the <tt>lpd</tt> server records the current printing operations
in the spool queue status file specified by the <tt/spool_status_file/ option
(default <tt/status.%P/ - the %P is expanded to the print queue name);
for our example, this would be
<tt>/var/lpd/pr/status.pr</tt>.
In order to prevent this file from growing too large,
the server will periodically truncate the file.
You can force creation of these files by setting the
<tt/create_files/ option.
The
<tt>max_status_size</tt> configuration or printcap option
sets the maximum size (in Kbytes) of the status file;
if the file exceeds this,  only the last
<tt>min_status_size</tt> bytes
or 25% of the maximum size (default if not specified)
will be preserved.
<p>
Similarly,
the server logs its operations in the log file specified by the
<tt>lf</tt> (log file) option (default is <tt>lf=log</tt>).
The <tt>max_log_file_size</tt>
value
(default 0)
specifies the maximum length
of the log file in Kbytes.
If this value is non-zero,
then the log file is truncated to
<tt>min_log_file_size</tt> bytes
or 25% of the maximum file size.
Again, the last portion of the log file is preserved.
If the <tt>max_log_file_size</tt> value is 0,
then the log file grows without limit.
<p>
Some filters require an additional filter status file
that they use for recording additional filter status or
other operational information.
The
<tt>ps</tt> names this file,
and it is passed to a print filter using the <tt>$s</tt>
option
(see
<ref id="filtercmd" name="Filter Command Line Flags">).
<p>
The STDERR output for filters is put into the printer
status file.
This allows the filter to produce informative messages that can be displayed
as part of the user status.
In addition,
a separate status file specified by the
<tt>ps</tt> (Printer Status) can be used as well.
This file is
<em>not</em>
truncated by the LPRng system.
<p>
When reporting status information,
the length of line returned can be a problem.
The <tt>max_status_line#79</tt> option restricts the status line
to a maximum of 79 characters.
<p>
The <tt>short_status_date</tt> (default is true)
option causes short (hour:minute) timestamps to be displayed
on status queries.
<sect1>Job Files
<p>
<label id="nline_after_file">
<itemize>
<item> <tt>longnumber</tt><em>&nbsp;&nbsp; long job number</em>
<item> <tt>default_priority=</tt><em>default job priority</em>
<item> <tt>nline_after_file=</tt><em>N line after data file</em>
</itemize>
<p>
A print job consists of a control file and one or more data files.
<ref id="rfc1179" name="RFC1179">
specifies the general format of these files and how they are to be
transfered between servers.
LPRng has extended the contents of the control files and the transfer protocol
to provide a more powerful set of features,
but has extensive provisions for backwards compatibility with
non-LPRng software.
A sample control file is shown below:
<tscreen>
<verb>
Hastart4.astart.com
J/tmp/file1 /tmp/file2
CA
Lpapowell
Ppapowell
fdfA002230astart4.astart.com
N/tmp/file1
UdfA002230astart4.astart.com
fdfB002230astart4.astart.com
N/tmp/file2
UdfB002230astart4.astart.com
</verb>
</tscreen>
<p>
The first part of the control file contains general information generated
by the <tt>lpr</tt> or other spooling program.
The information lines start with an uppercase letter or digit.
Some other spooling systems also start information lines with
various punctuation marks such as underscores (_) or periods (.).
<p>
Following this are a set of entries about each of the various files to
be printed.
These lines start with a lower case letter,
followed by the print file name.
The lower case letter is the
<em>format</em> to be used to process the file.
See
<ref id="format" name="print file formats">
for more information about its use.
<p>
<table>
<tabular ca="|l|l|l|">
Key
|
Meaning
|
Generated By
@
A
|
identifier *
|
LPRng internal
@
C
|
class
|
lpr -C class
@
D
|
date
|
lpr
@
H
|
originating host
|
lpr
@
I
|
indent
|
lpr -i indent
@
J
|
jobname
|
lpr -J jobname (default: list of files)
@
L
|
bnrname
|
lpr -U username
@
N
|
filename
|
(see text)
@
M
|
mailname
|
lpr -m mailname
@
P
|
logname
|
lpr
@
Q
|
queuename
|
lpr -Q
@
R
|
accntname
|
lpr -R accntname
@
S
|
slinkdata *
|
lpr
@
T
|
prtitle
|
lpr -T prtitle
@
U
|
unlnkfile
|
(see text)
@
W
|
width
|
lpr -w width
@
Z
|
zopts *
|
lpr -Z zopts
@
1
|
font1
|
lpr -1 font1
@
2
|
font2
|
lpr -2 font2
@
3
|
font3
|
lpr -3 font3
@
4
|
font4
|
lpr -4 font4
@
</tabular>
</table>
<p>
The entries marked with * are used only by LPRng.
<tt>N</tt> and <tt>U</tt> lines
are associated with a print file.
The <tt>N</tt> line is the original name of the print
file.
By default,
LPRng places this line <it>before</it>
the corresponding data file.
You can use the
<tt/nline_after_file/
option to have LPRng place the N line after the data file line.
The <tt>U</tt> line originally was used to indicate that the
named file was to be unlinked after printing.
This information is now ignored by LPRng.
These lines are always grouped with a print file entry.
<p>
The names of control and data files follow a very strict pattern.
Control files have the format <tt>cfX<em>number</em><bf>host</bf></tt>,
where X is an upper case letter,
<em>number</em> is (usually) a 3 digit number,
and <bf>host</bf> is the host name.
<ref id="rfc1179" name="RFC1179">
restricted the total length of the control file name to 32 characters;
LPRng has a much looser limit.
<p>
Data file names must follow the same pattern as the control file name,
and have the format
<tt>dfX<em>number</em><bf>host</bf></tt>.
The X can be in the range A-Za-z,
allowing at most 52 data files for a job.
The <em>number</em> and <bf>host</bf> must be identical to the corresponding
control file.
<p>
By convention,
LPRng uses the X of the control file name to set a priority for the
job.
A job with control file name
<tt>cfA...</tt>
will have <em>lower</em> format
than a job with format
<tt>cfB...</tt>,
and so forth.
The <tt>lpr</tt> program uses the first letter of the class name
or an explicit priority indication to set the letter value.
If none of these are specified, then the
<tt>default_priority</tt> value from the configuration or printcap
entry is used.
<p>
The job number is usually a 3 digit value.
However,
in systems where a large number of jobs are spooled and need to be
kept for printing at scheduled times,
this can lead to problems.
The
<tt>longnumber</tt>
option will use 6 digit job numbers.
This must be used with care when operating with non-LPRng software.
<sect1>Job Hold File
<p>
Associated with each control file is a
hold file that has additional information controlling the printing operations.
The entries in this file have the form:
<tscreen>
<verb>
key [value]
</verb>
</tscreen>
<p>
The following is an example of a hold file:
<tscreen>
<verb>
server 0
subserver 0
attempt 3
error cannot open printer
hold 0
priority 0
remove 0
routed 0
</verb>
</tscreen>
<p>
The
<tt>server</tt>
and
<tt>subserver</tt>
entry records the process ID of the server process
and the subserver process that is printing the job.
The
<tt>attempt</tt>
field records the total number of attempts to print the job.
The
<tt>error</tt>
field records any error that would prevent the job from being printed.
This information is reported by the <tt>lpq</tt> program.
<p>
The
<tt>hold</tt>
field is non-zero when the
<tt>lpc hold</tt>
command is used to
explicitly prevent the job from being printed;
<tt>lpc release</tt>
will clear the field and allow the job to be printed.
<p>
The
<tt>priority</tt>
field is modified by the
<tt>lpc topq</tt>
command and is used to provide an overriding priority to printing the file.
<p>
The
<tt>remove</tt>
field is non-zero when the file has been printed and should be removed.
<p>
The
<tt>routed</tt>
field is used to indicate that there is routing information present in
the hold file,
and that special handling is needed.
The routing information is provided by a
<ref id="routing" name="routing filter">.
The information is recorded by information in the hold file.
The following is an example of routing information.
Normally this information is stored in a URL escaped format,
with one line per destination,
but for clarity this has been broken out into plain text form:
<p>
<tscreen>
<verb>
active 0
attempt 0
done 0
hold 0
priority 0
remove 0
routed 880892602
route 1
  dest t1
  ident papowell@astart4+705.1
  error
  copies 1
  copy_done 0
  status 0
  active 0
  attempt 0
  done 0
  hold 0
  sequence 0
  priority B
  CB
  end
route 2
  dest t1
  ident papowell@astart4+705.2
  error
  copies 0
  copy_done 0
  status 0
  active 0
  attempt 0
  done 0
  hold 0
  sequence 1
  end
</verb>
</tscreen>
<p>
Routing information lines start with
<tt>route</tt> followed by individual routing entry information.
The <tt>route</tt> <tt>dest</tt>,
<tt>copies</tt>,
<tt>priority</tt>,
and
<tt>Xnnnn</tt>
entries are
derived from the output of the router program;
other fields are used during the printing process.
The <tt>copy_done</tt> records the numbers of copies done,
while the <tt>done</tt> records that the entry has been completed.
The <tt>status</tt> is the process ID of the server process
doing the printing.
<p>
The output from  route filter  that generated the above file was:
<tscreen>
<verb>
dest t1
copies 1
priority B
CB
end
dest t1
end
</verb>
</tscreen>
<sect1>Job State
<label id="ah">
<p>
Options used:
<itemize>
<item> <tt>ah</tt><em>&nbsp;&nbsp;Automatically hold jobs</em>
</itemize>
<p>
A job can be in the following state:
<enum>
<item>Initial.
This is the state during job submission.
Jobs in the initial state do not have any status displayed for them.
<item>Held.
Once a job is submitted,
it can either be printed or <em>held</em>.
The <tt>ah</tt> printcap option specifies that all jobs are
automatically held on submission.
The
<tt>lpc release</tt>
and
<tt>lpc redo</tt>
command will cause these jobs to be printed and
the <tt>lprm</tt> command can remove these jobs.
<item>
Active.
The job is being processed for printing or transfer to another queue.
<item>
Pending.
Jobs which can be printed but are not active.
This can be due to the printer being busy or
the job <bf>class</bf> not being printed.
<item>
Error.
Jobs which have encountered an error during printing.
The
<tt>lpc release</tt>
and
<tt>lpc redo</tt>
command will cause these jobs to be printed and
the <tt>lprm</tt> command can remove these jobs.
<item>
Done.
Jobs which have completed printing,
but which are not yet removed from the print queue.
See the
<tt><ref id="savewhendone" name="save_when_done"></tt>
flag for more information.
The <tt>lprm</tt> command can remove these jobs.
</enum>
<p>
Normally the job sequences is initial, pending, active, and done.
However, a job may be put in the error state by problems processing the job
or by actions of the <tt>lpc</tt> command.
<sect1>Job Identifier
<label id="useidentifier">
<p>
Options:
<itemize>
<item> <tt>use_identifier</tt><em>&nbsp;&nbsp;put job identifier in control file</em>
</itemize>
<p>
For each job in a spool queue,
the LPRng software creates a unique identifier.
This identifier is recorded in the control file <tt>A</tt> line.
It can be used by the various client programs for identifying jobs,
and is displayed by the <tt>lpq</tt> program as status information.
<sect>Configuration File lpd.conf and Options
<label id="configfile">
<label id="lpdconf">
<p>
The values in the LPRng configuration file
(default: <tt>/etc/lpd.conf</tt>)
override the compile time default values for printcap options.
See the
<ref id="index" name="Index To All The Configuration and Printcap Options">
for an index to a complete list of configuration options.
<sect1>Configuration File Format
<p>
The LPRng distribution contains a template <tt>lpd.conf</tt> file
which can be installed as
<tt>/etc/lpd.conf</tt>.
The configuration file has the following format:
<tscreen>
<verb>
# lpd.conf generated from  on Wed Apr  7 07:59:48 PDT 1999

#   The values in this file are the default values.
#   If you modify the file,  set the value to something other than the default
#   For example, '# default force_localhost' means the 'force_localhost' option
#    change this to 'force_localhost@' to have the opposite effect.

# Purpose: always print banner, ignore lpr -h option
#   default ab@
# change ---
ab
# Purpose: query accounting server when connected
#   default achk@
# Purpose: accounting at end (see also af, la, ar, as)
#   default ae=jobend $H $n $P $k $b $t
# Purpose: name of accounting file (see also la, ar)
#   default af=
...
</verb>
</tscreen>
<p>
The options are set exactly as for a printcap file,
but do not require a leading colon (:).
<p>
To change the default value of an option,
remove the comment character and edit the entry as shown in the above example.
<p>
To force the <tt>lpd</tt> server to use the new options,
use the <tt>lpc reread</tt> command.
<sect1>Configuration Information
<label id="allowgetenv">
<p>
In order to protect system security,
the
<tt>/etc/lpd.conf</tt>
and
<tt>/etc/printcap</tt>
files should be read only.
<p>
For testing purposes
when LPRng is compiled with the <tt>-DGET_ENV</tt> option
LPRng uses the value of the <tt>LPD_CONF</tt> environment variable
as the path to the <tt/lpd.conf/ file.
<bf>This is a security loophole,
and should not be used when running SETUID ROOT or as ROOT.</bf>
<sect1>Configuration Options
<p>
The following variables are used to set default behavior
for the LPRng software,
or are commonly used for configuration of LPRng operations.
<sect2>default_format
<label id="defaultformat">
<p>
Default format for printing.
Usually,
<tt>default_format=f</tt>,
but setting it to
<tt>default_format=l</tt> will cause all files spooled by lpr
to be spooled as binary files.
<sect2>default_permission=ACCEPT
<label id="defaultpermission">
<p>
The default permissions to use when checking for printing or other permissions.
<sect2>default_priority=A
<label id="defaultpriority">
<p>
The default priority for a print job.
<sect2>default_remote_host=localhost
<label id="defaultremotehost">
<p>
The default <tt>lpd</tt> server host.
<sect2>default_tmp_dir=/tmp
<label id="defaulttmpdir">
<p>
The default directory for temporary files.
<p>
This option can be used to specify a default
printer. If no value is given (default), the first printer in the
printcap file will be used when no printer is specified.
<sect2>domain_name=domain.name
<p>
You will only need to set this if LPRng can't determine your
hosts domain name itself.
This is usually a desperation option when DNS or some other
database system is not available.
The value of the $USER environment variable will be used as the return address.
<sect1>The Record Queue Name qq and force_queuename flags
<label id="qq">
<label id="usequeuename">
<label id="forcequeuename">
<p>
Options used:
<itemize>
<item> <tt>qq</tt><em>&nbsp;&nbsp;Insert queue name into control file</em>
<item> <tt>use_queuename</tt><em>&nbsp;&nbsp;(alias for qq)</em>
<item> <tt>force_queuename=</tt><em>&nbsp;Queuename to be used</em>
</itemize>
<p>
The printcap information consists of the printer name and aliases;
when a job is spooled to a printer alias,
it is actually spooled to the main printer entry.
<p>
The
<tt>qq</tt>
use queuename option or its
alias
<tt>use_queuename</tt>
tells
LPRng to record the queue name that a job was queued to,
and make it available to other software for processing.
The
<tt>force_queuename=...</tt>
entry forces this name to be used.
This capability has some interesting possibilities,
as shown below.
<tscreen>
<verb>
pr1_landscape|pr1_portrait|pr_raw:lp=pr@host:qq
</verb>
</tscreen>
<p>
If a job is printed using
<tt>lpr -Ppr1_landscape</tt>,
then
<tt>pr1_landscape</tt>  will be recorded as the spool queue name
by the LPRng software.
<p>
Later,
when the job is processed by a filter,
the filter will be invoked with a
<tt>-Qpr1_landscape</tt>
command line option.
The filter can use the name of the queue to enable say,
landscape,
portrait,
or raw
orientations.
<tscreen>
<verb>
john|tom|frank:lp=pr@host:force_queuename=office
</verb>
</tscreen>
<p>
This printcap entry forces the queuename to be <tt>office</tt>;
this information could be used by a central routing facility to
process the information is a suitable manner.
<sect1>The check_for_nonprintable Flag
<label id="checkfornonprintable">
<label id="ml">
<label id="xt">
<p>
Options used:
<itemize>
<item> <tt>check_for_nonprintable</tt><em>&nbsp;&nbsp;LPR checks for non-printable file </em>
<item> <tt>ml=</tt><em>&nbsp;&nbsp;minimum number of printable characters </em>
</itemize>
<p>
Normally, <tt>lpr</tt>
checks an <tt>f</tt> format file
for non-printable characters (i.e., escape characters) at the start
of the print file.
Disabling this check allows you to print executable files,
etc., which can cause extreme abuse of your printer.
<p>
Disabling can be done on a single printcap basis,
or you can do this on a global basis by modifying the
configuration information (see
<ref id="lpdconf" name="lpd.conf">).
<p>
The <tt>ml</tt> value specifies the number of characters that
are to be checked.
Clearly,  if it is 0, none will be checked.
<sect1>The rg Restrict Use to Group Members Option
<label id="rg">
<p>
Options used:
<itemize>
<item> <tt>rg=</tt><em>Restricted group list</em>
</itemize>
<p>
The <tt>rg</tt> value specifies a list of groups.
If this value is present use of a printer or operation is restricted to only
users in a particular group.
<p>
This was a wimpy attempt to do restrictions on print facilities.
The -Ppr@host option overrides this check,
unless the <tt>rg</tt> value is put in the LPRng defaults.
<p>
However,
it does provide a simple tool to have clients do some form of permissions
checking that only the <tt>lpd</tt> server could normally do.
<sect1>The fx Allowed Formats Option
<label id="fx">
<p>
Options used:
<itemize>
<item> <tt>fx=</tt><em>supported formats for printing</em>
</itemize>
<p>
The <tt>fx</tt> option restricts the formats supported by
a spool queue.
The <tt>lpr</tt> program uses these to check if a requested format
is supported.
By default, all formats are supported.
<sect1>Fixing Bad Control Files and Metacharacters
<label id="safechars">
<p>
Options used:
<itemize>
<item> <tt>safe_chars=</tt><em>additional safe characters for control file </em>
</itemize>
<p>
RFC1179 defines a simple protocol and standard for print jobs to be
interchanged between print spooling systems.
Unfortunately,
there were some major mistakes in not specifying the exact form
that text would take when placed in the control file.
<p>
In addition,
there are some simple coding errors that have been made,
but due to their wide distribution in major vendors software,
need to be accommodated.
See
<ref id="reverselpqformat" name="reverse_lpq_format">
for an example.
<p>
By default,
LPRng will brutally convert a non-conforming RFC1179 control file
into one that is acceptable to most,
if not all,
existing RFC1179 implementation.
<p>
In order to prevent problems with
LPRng ruthlessly purges all characters but
upper and lower case letters,
spaces, tabs, and <tt>-_.@/:()=,+-%</tt> from the control file,
replacing suspicious characters with '_'.
<p>
For some installations,
the default set of safe characters may be overly restrictive.
For example,
<em>vintage</em> software may generate files with <tt>#</tt> characters
in the <tt>J</tt> line of the control file.
The replacement of this character may cause other things to stop
working.
<p>
The <tt>safe_chars</tt> option allows the user to specify an additional
set of safe characters in the <tt>lpd.conf</tt> configuration file(s).
For example, <tt>safe_chars=#"</tt> would allow the
<tt>#</tt>
and
<tt>"</tt>
characters to appear in the control file.
<p>
In addition,
LPRng will ruthlessly regenerate control file entries and data file names
so that they are compliant with all known RFC1179 implementations.
<sect1>Using the bk Option and Control File Filters
<label id="bk">
<label id="controlfilterbk">
<p>
Options:
<itemize>
<item> <tt>bk</tt><em>&nbsp;&nbsp;Berkeley compatible control file</em>
<item> <tt>control_filter=</tt><em>Control file filter</em>
</itemize>
<p>
One of the more serious problems is when a print spooler (LPR) program
does not generate print jobs in a manner compatible with a remote system.
<p>
While LPRng performs checks for improper implementations of RFC1179,
it will try to accept a job
even under the most severe abuse of the protocol.
However,
other spoolers are not so forgiving.
<p>
Some spoolers require that the contents of the control file
be in <bf>exactly</bf> the order that the original 1988 BSD LPR software
generated them.
While some entries can be missing,
all the entries present in the file must be in an explicit order.
<p>
The <tt>bk</tt> (Berkeley LPD compatible control file) option
causes LPR and LPD to reformat the control file,
removing objectionable entries.
The control file of a job being sent to
a remote printer will have its control file entries restricted to
letters in (and the same order) as  HPJCLIMWT1234.
<p>
However,
there are some very odd commercial implementations that require
<em>more</em> information than is present.
To assist with this,
the <tt>control_filter</tt> option can be used.
This specifies a program that will process the control file
before it is sent to a remote destination.
See
<ref id="secfilter" name="Filters"> for details on filter
operation,
and
<ref id="controlfilter" name="Control Filters"> for details on the
point during job processing when the
<tt>control_filter</tt>
is used.
<p>
The <tt>control_filter</tt> program is run with the standard set of filter options.
STDIN is attached to the control file and
the STDOUT will be used as the control file value
sent to the remote host.
<p>
The
<tt>control_filter</tt>
can rewrite the control file.
The only restriction is that it cannot modify the
<bf/names/ or delete datafiles.
Here is a small snip of PERL code that shows how to
rewrite the control file:
<tscreen>
<verb>
# you need to get PERL to do a 'dup' call on FD 0
$status = 0;
@cf_lines = &lt;STDIN>;
# mess about with the control file
foreach $line (@cf_lines) &lcub;
   # or whatever you want
   print STDOUT $line;
&rcub;
exit $status;
</verb>
</tscreen>
<p>
The exit code of the
<tt>control_filter</tt>
is used to determine whether to proceed in processing.
See
<ref id="errorcodes" name="Errorcodes"> for details.
<sect1>Maximum Copies
<label id="mc">
<p>
Options used:
<itemize>
<item> <tt>mc#</tt><em>maximum copies </em>
</itemize>
<p>
The <tt> mc</tt> value specifies the maximum number of
copies of a job that can be printed on a printer using the
<tt>lpr -Knn </tt> or
<tt>lpr -#nn </tt> option.
<sect1>The minfree Minimum Spool Queue Space Option
<label id="minfree">
<p>
Options used:
<itemize>
<item> <tt>minfree=</tt><em>Size in Kbytes</em>
</itemize>
<p>
If this value is non-zero,
then the <tt>lpd</tt> receiving server checks to see that there is the
specified number of Kbytes of file space available before
accepting a job.
<sect1>Debugging
<label id="db">
<label id="fulltime">
<label id="mstimeresolution">
<label id="syslogdevice">
<label id="usedate">
<label id="useinfocache">
<p>
Options used:
<itemize>
<item> <tt>debugging=</tt><em>debugging options</em>
<item> <tt>full_time</tt><em>&nbsp;&nbsp;full or extended time format</em>
<item> <tt>ms_time_resolution</tt><em>&nbsp;&nbsp;millisecond time resolution</em>
<item> <tt>syslog_device=</tt><em>syslog alternative device</em>
<item> <tt>use_date</tt><em>&nbsp;&nbsp;put date information in control file</em>
<item> <tt>use_info_cache</tt><em>&nbsp;&nbsp;cache printcap and other information</em>
</itemize>
<p>
The LPRng software has a very powerful debugging capability.
Since most printing problems occur on remote systems where it is impossible
to run debuggers,  and since most systems do not do core dumps of SETUID ROOT
programs,
the LPRng software provides a very verbose set of log file trace messages.
<p>
First,
serious errors or other information are logged using the
<em>syslog()</em> facilities.
If these are not present on a system,
then the messages are logged to the device specified by
<tt>syslog_device</tt>.
<p>
For client programs, the debugging options are specified on the command
line and output is directed to STDERR.
For the <tt>lpd</tt> server,
debugging commands can be specified on the command line OR as the
<tt>db=options</tt> printcap value.
Output is directed to the log file (<tt>lf</tt> option value, default log).
<p>
A typical debug entry has the format <tt>2,network+1,database</tt>.
This sets the general
debugging level to 2, network debugging to 1 and the database debugging level
to the default.  The following debugging options and levels are supported.
<itemize>
<item>nnn - general purpose debugging level
<item>network - network debugging
<item>database - database debugging
<item>receive - job or command reception debugging
<item>print - detailed job printing debugging
</itemize>
<p>
The <tt>full_time</tt> flag forces the logging and other information
which has timestamps to have a full (year, month, day, etc.) timestamp.
The
<tt>ms_time_resolution</tt> flag forces millisecond time resolution
in the time stamp.
The
<tt>use_date</tt> flag forces a date value to be placed in a control file
if there is none.
<p>
The <tt>use_info_cache</tt> (default ON) causes <tt>lpd</tt>
to cache printcap and configuration information.
This is desirable except when trying to change values in printcap files and
test the results.
By using <tt>use_info_cache@</tt> in the configuration information,
you can get immediate responses.
Also, see
<ref id="lpcreread" name="lpc reread">
for another method.
<sect1>LPD Specific
<label id="ipv6">
<label id="lockfile">
<label id="spooldirperms">
<label id="spoolfileperms">
<label id="spreadjobs">
<label id="reportserveras">
<p>
Options used:
<itemize>
<item> <tt>ipv6</tt><em>&nbsp;&nbsp;use IPV6 Network facilities </em>
<item> <tt>lockfile=</tt><em>lpd server lock file</em>
<item> <tt>report_server_as=</tt><em>server name for status reports</em>
<item> <tt>spool_dir_perms#</tt><em>spool directory permissions </em>
<item> <tt>spool_file_perms#</tt><em>spool file permissions </em>
<item> <tt>spread_jobs#</tt><em>job number spread</em>
</itemize>
<p>
These options are usually LPD specific.
For example,
the <tt>ipv6</tt> specifies that the IPV6 protocol,
rather than IPV4 will be used.
In future versions,  this may not be necessary.
<p>
The <tt>lockfile</tt> specifies the location of the
lock file used by the <tt>lpd</tt> server.
This file has the <tt/lpd_port/ value appended to form a unique
lock file name.
<p>
The <tt>spool_dir_perms</tt> and <tt>spool_file_perms</tt>
(default 0700 and 0600 respectively)
values are the (numeric) permissions for the spool directory and
spool files.
<p>
The <tt>spread_jobs</tt> option is obsolete.
The <tt> spread_jobs</tt> option was a desperation fix to handle
difficulties with the arrival of a large number of jobs with the same or
close job number.  The LPD server would fork children,
each of whom tried to lock the job files.  The spread value randomly
chose a new number in the range about the original job number.
However,
it is still preserved for legacy systems which still have problems with
file locking.
<p>
The <tt>report_server_as</tt> option allows an administrator to
masquerade a server with another name.
This could be useful if various load sharing activities are
being carried out,  or if there are problems reconfiguring DNS
to cause the correct server name to be reported.
<sect1>Legacy Compatibility
<p>
The following arguments have been provided for compatibility with
legacy systems.
<sect2>The allow_duplicate_args Option
<label id="allowduplicateargs">
<p>
Options used:
<itemize>
<item> <tt>allow_duplicate_args</tt><em>&nbsp;&nbsp;allow lpr to have duplicate arguments </em>
</itemize>
<p>
Some users would like duplicate LPR and LPRM command line
arguments to override earlier ones,
i.e. -
<tt>lpr -a x -a y </tt> should be equivalent to
<tt>lpr -a y</tt>
<p>
The <tt>allow_duplicate_args</tt> option
allows the various client programs to have duplicate arguments.
The last specified argument on the command line will override
previous values.
<sect2>The class_in_status Options
<label id="classinstatus">
<p>
Options used:
<itemize>
<item> <tt>class_in_status</tt><em>&nbsp;&nbsp;show class name in status</em>
</itemize>
<p>
Setting the <tt>class_in_status</tt> option causes the class name rather
than priority to be displayed in the status information.
<sect2>The reverse_lpq_format Option
<label id="reverselpqformat">
<p>
Options used:
<itemize>
<item> <tt>reverse_lpq_format=</tt><em>&nbsp;reverse LPQ status format for specified remote systems</em>
</itemize>
<p>
Various Solaris and other System V implementations support an RFC1179 interface
to remote printers.
Unfortunately,  there is a problem in that when they send a status request,
the status format is reversed.
That is,
when LONG status format is wanted,
they send SHORT,
and vice versa.
<p>
The <tt>reverse_lpq_format=</tt> specifies a list of printers or IP addresses
for which the <tt>lpd</tt> server will return LONG status when SHORT is
requested,
and vice versa.
For example:
<tscreen>
<verb>
reverse_lpq_format=*.eng.com,130.192.0.0/16
</verb>
</tscreen>
<p>
will cause hosts whose Fully Qualified Domain Name (FQDN) ends in
<tt>eng.com</tt> or from subnet <tt>130.192.0.0</tt> to have reversed
status returned.
<sect2>The return_short_status and short_status_length Options
<label id="shortstatuslength">
<label id="returnshortstatus">
<p>
Options used:
<itemize>
<item> <tt>return_short_status=</tt><em>&nbsp;return short LPQ status for specified remote systems</em>
<item> <tt>short_status_length#</tt><em>&nbsp;short LPQ status length in lines</em>
</itemize>
<p>
In order to be compatible with non-LPRng client programs,
some administrators would like <tt>lpd</tt> to return a short or brief
status to normal status queries.
<p>
The <tt>return_short_status=</tt> specifies a list of printers or IP addresses
for which the <tt>lpd</tt> server will return an abbreviated
status when LONG status is requested.
For example:
<tscreen>
<verb>
return_short_status=*.eng.com,130.192.0.0/16
short_status_length#3
</verb>
</tscreen>
<p>
will cause hosts whose Fully Qualified Domain Name (FQDN) ends in
<tt>eng.com</tt> or from subnet <tt>130.192.0.0</tt> to get only
3 lines of detailed status returned.
<sect2>The force_lpq_status Options
<label id="forcelpqstatus">
<p>
Options used:
<itemize>
<item> <tt>force_lpq_status=</tt><em>&nbsp;force LPQ status format for specified remote systems</em>
</itemize>
<p>
In order to be compatible with non-LPRng client programs which
are totally unpredictable,
this allows the administrator to specify the format for LPQ
status when requests arrive.
<p>
The <tt>force_lpq_status=</tt> specifies a list of formats
and printers or IP addresses
for which the <tt>lpd</tt> server will return status
in the specified format.
The entry has the format
<tt/KEY=list;KEY=list.../ where
<tt/KEY/ is
<tt/s/ for short and
<tt/l/ for long format,
and list is a list of hosts or IP addresses.
For example:
<tscreen>
<verb>
force_lpq_status=s=pc*.eng.com,130.192.12.0/24,l=sun*.eng.com
</verb>
</tscreen>
<p>
will cause hosts whose Fully Qualified Domain Name (FQDN) matches
<tt>pc*eng.com</tt> or from subnet <tt>130.192.12.0</tt> to get short
status returned and hosts which match <tt/sun*.eng.com/ get
long status.
<sect2>The ignore_requested_user_priority and force_fqdn_hostname Options
<label id="ignorerequesteduserpriority">
<label id="forcefqdnhostname">
<p>
Options used:
<itemize>
<item><tt>ignore_requested_user_priority</tt><em>prevent users from queue jumping</em>
<item><tt>force_fqdn_hostname</tt><em>force FQDN hostname in control file</em>
</item>
</itemize>
<p>
Some students... um... users... will request a high priority for their job
in order to jump the queue of waiting jobs.
This option will cause the <tt>lpd</tt> server to ignore the
requested user priority.
However, the <tt>topq</tt> operation will still be effective.
<p>
Similarly,  some print spoolers do not put a FQDN host name in their control file.
The <tt>force_fqdn_hostname</tt> flag will cause <tt>lpd</tt> to put a FQDN
host name in the control file.
This option will assume that the domain is where the connection originated from.
<sect2>The lpr_bsd Options
<label id="lprbsd">
<p>
This will force the <tt>lpr -m</tt> (send mail to user)
option not to take an argument, as in the BSD lpr.
<sect>Job Processing
<label id="jobsteps">
<p>
Much of the flexibility of the LPRng software is obtained
from the ability to control the details of each step of job processing.
The following section details each step in the processing of a job,
and explains the printcap options used to control each operation.
<p>
Assume the <tt>pr</tt>
printcap entry has the form:
<tscreen>
<verb>
pr
    :lp=/dev/lp  OR  :lp=rp@rm
    :sd=/var/spool/lpd/pr
    :lf=log
    :of=/usr/local/bin/lpf
    :if=/usr/local/bin/lpf
</verb>
</tscreen>
<p>
Assume that we have used the following command to print
a set of files.
<tscreen>
<verb>
lpr -Ppr file1 file2
</verb>
</tscreen>
<p>
This will create a control file
in the
<tt>/var/spool/lpd/pr</tt>
directory with the following contents (this is an example -
in practice there may be minor differences between the example
and an actual control file):
<tscreen>
<verb>
Hastart4.astart.com
J/tmp/file1 /tmp/file2
CA
Lpapowell
Ppapowell
fdfA002230astart4.astart.com
N/tmp/file1
UdfA002230astart4.astart.com
fdfB002230astart4.astart.com
N/tmp/file2
UdfB002230astart4.astart.com
</verb>
</tscreen>
<p>
<sect1>Opening the Output Device
<label id="achk">
<label id="af">
<label id="as">
<label id="ff">
<label id="fo">
<label id="lk">
<label id="lpdev">
<label id="la">
<label id="ar">
<label id="ld">
<label id="rw">
<label id="connectgrace">
<label id="networkconnectgrace">
<label id="connectinterval">
<label id="connecttimeout">
<label id="connecttry">
<label id="controlfilter">
<label id="nb">
<label id="servertmpdir">
<p>
Options used:
<itemize>
<item> <tt>achk</tt><em>&nbsp;&nbsp;Accounting check at start</em>
<item> <tt>af=</tt><em>Accounting File</em>
<item> <tt>ar</tt><em>&nbsp;&nbsp;Remote printer accounting enabled</em>
<item> <tt>as=</tt><em>Accounting at start</em>
<item> <tt>connect_grace#</tt><em>&nbsp;&nbsp;Time between jobs</em>
<item> <tt>connect_interval#</tt><em>&nbsp;&nbsp;Connection interval</em>
<item> <tt>connect_timeout#</tt><em>&nbsp;&nbsp;Connection timeout</em>
<item> <tt>control_filter=</tt><em>Control file filter</em>
<item> <tt>ff</tt><em>&nbsp;&nbsp;form feed</em>
<item> <tt>fo</tt><em>&nbsp;&nbsp;form feed on open</em>
<item> <tt>la</tt><em>&nbsp;&nbsp;Local printer accounting enabled</em>
<item> <tt>ld=</tt><em>leader on open (initialization string)</em>
<item> <tt>lk</tt><em>&nbsp;&nbsp;Lock IO device</em>
<item> <tt>lp=</tt><em>IO device pathname</em>
<item> <tt>nb</tt><em>&nbsp;&nbsp;Nonblocking device open</em>
<item> <tt>network_connect_grace#</tt><em>&nbsp;&nbsp;Time between jobs</em>
<item> <tt>of=</tt><em>of filter</em>
<item> <tt>retry_econnrefused#</tt><em>&nbsp;&nbsp;Retry if open failed</em>
<item> <tt>retry_nolink#</tt><em>&nbsp;&nbsp;Retry if open failed</em>
<item> <tt>rm</tt><em>&nbsp;&nbsp;the remote machine to send the job to</em>
<item> <tt>rp</tt><em>&nbsp;&nbsp;the remote print queue to send the job to</em>
<item> <tt>rw</tt><em>&nbsp;&nbsp;device opened RW flag</em>
<item> <tt>server_tmp_dir=</tt><em>temporary directory</em>
</itemize>
Sequence of Operations:
<enum>
<item>
During the server operations,
it will try to create temporary files in the print queue spool directory.
If this is not desirable,
it will create them in the <tt>server_tmp_dir</tt> directory.
<item>
If the accounting file specified by
<tt>af</tt>
exists,
it is opened (af_fd) and the af_fd is passed as file descriptor
3 to all filters.
If the <tt>af</tt> value has the form <tt>af=|/program</tt>
then the program is started and the program STDIN is used as af_fd.
If the <tt>af</tt> value has the form <tt>af=host%port</tt>,
then a TCP/IP connection to the corresponding port on the remote host
is made and the port used as af_fd.
In the latter two cases,  the filter STDIN (file descriptor 0)
is actually opened read/write, and is used when information is needed
from the accounting filter or remote server.
See
<ref id="accountingserver" name="Accounting Printcap Options">
for more information on the LPRng accounting support.
<item>
<label id="accountstart">
If <tt>la</tt> (local accounting) is true and we are printing a job
or <tt>ar</tt> (remote accounting) is true and we are transferring a job,
the <tt>as</tt> value is examined.
If it is a filter (program) specification,
then the program is started with its STDIN attached to
<tt>/dev/null</tt>, STDOUT will be read by the print spooler,
STDERR output will be written to the error log,
and file descriptor 3 output will be appended to the accounting file.
The lpd program will wait until the accounting filter program terminates,
and examine the error code for action, as for the filters
(see
<ref id="errorcodes" name="errorcodes"> below).
If the exit status is 0,
(JSUCC) then the printing process will continue,
if JHOLD the job will be held,
if JREMOVE the job will be removed,
if JFAIL the job processing will terminate with a JFAIL indication,
otherwise
the job processing will terminate with a JABORT indication.
<item>
If the accounting filter exited with a JSUCC (no error code)
and the <tt>achk</tt> (accounting check) flag is set,
the line read from the accounting filter STDOUT will be examined.
This line should be
<tt>accept</tt>,
<tt>hold</tt>,
<tt>fail</tt>,
<tt>remove</tt>,
otherwise the job processing terminates with a JABORT indication.
An <tt>accept</tt> will allow the job to be printed,
<tt>hold</tt> will hold the job,
<tt>fail</tt> will cause the job to fail,
<tt>remove</tt> will cause the job to be removed.
<item>
If the
<tt>connect_grace</tt>
value is non-zero and the server is opening a device or
<tt>network_connect_grace</tt> is non-zero and a network connection
is being made,
the server will pause the specified time.
This is to accommodate devices which need a recovery time between jobs.
<item>
The <tt>lp</tt> option is checked to determine the type of IO device.
<table>
<tabular ca="|l|l|">
Format
|
Meaning
@
<tt>/pathname</tt>
|
Absolute pathname of IO device
@
<tt>pr@host</tt>
|
transfer to <tt>pr</tt> on remote <tt>host</tt>
@
<tt>host%port</tt>
|
open a TCP/IP connection to port on host.  host can be name or IP address
@
<tt>|filter</tt>
|
run the filter program; it STDIN will be used as device
@
</tabular>
</table>
<item>
The IO device specified by
<tt>lp</tt> is opened write-only or read-write if the
<tt>rw</tt>
flag is true, and the resulting file descriptor is io_fd.
If the <tt>nb</tt> flag is set,
a non-blocking open will be done as well.
If the <tt>lk</tt> (lock device) flag is true,
the device will be locked against use by other LPD servers.
<item>
If a <tt>host%port</tt> combination,
a TCP/IP connection will be opened to the remote port and the connection will
be used as io_fd.
<item>
If a filter program is specified,
the filter program will be run and the STDIN of the filter will be
used as the device file descriptor.
<item>
If a <tt>rp@rm</tt> combination,
or none of the above combinations are true and the
<tt>rm</tt> and <tt>rp</tt> values are non-zero,
then the job will be transferred to a remote printer.
The type of operation will be a job transfer,
rather than printing operation.
<item>
If the <tt>connect_timeout</tt> value is non-zero,
a timeout is setup for the device or socket open.
If the device or connection open does not succeed within the timeout,
then the open operation fails.
<item>
If a connection is to a network address
(i.e. - <tt>connect()</tt> system call)
and the connection attempt fails with an <tt>ECONNREFUSED</tt>
error,
if the <tt>retry_econnrefused</tt>
flag is set then the connection attempt is retried,
but this time using an alternative port number.
See
<ref id="rfc1179ref" name="RFC1179"> for details.
This is repeated until all of the possible originating port numbers
are exhausted.
<item>
If the open or connect operation fails,
and the <tt>retry_nolink</tt> flag is set,
then the server will pause for a minimum of
<tt>connect_grace</tt> plus a multiple of
<tt>connect_interval</tt> seconds
based on the number of attempts
before retrying the open operation.
Note that the interval may increase as the number of attempts
increases.
<item>
If printing a job and the
<tt>of</tt> filter is specified,
it is created with its STDOUT (fd 1) attached to the io_fd.
Its stdin (of_fd) will be used in the steps listed below.
If there is no
<tt>of</tt> filter,
then the of_fd value will be the io_fd descriptor.
<item>
If transferring a job and the <tt>control_filter</tt> option is specified,
then the program specified by the <tt>control_filter</tt>
value will be run. It will have its STDIN set to the control file,
and its STDOUT output will be used as the new value of the control file
to transfer to the remote host.
See
<ref id="filtercmd" name="Filter Command Line Flags">
for details of options passed to the control filter,
and
<ref id="errorcodes" name="errorcodes"> for the exit codes of the filter.
<item>
If the operation is a job transfer, the operation proceeds as outlined in
<ref id="rfc1179ref" name="RFC1179">,
and then the
<ref id="normalterm" name="Normal Termination"> operations are
carried out.
<item>
If the operation is a print operation
and the
<tt>ld</tt> (leader on open) value is provided,
the string
is translated (escapes removed)
and written to the of_fd file descriptor.
<item>
If the
<tt>fo</tt> (form feed on open) flag is true, then the
<tt>ff</tt> (form feed) string
is translated (escapes removed)
and written to the of_fd file descriptor.
</enum>
<sect1>Printing Banner At Beginning
<label id="ab">
<label id="hl">
<label id="be">
<label id="bl">
<label id="bp">
<label id="bs">
<label id="sb">
<label id="sh">
<label id="of">
<label id="bannerprinting">
<label id="generatebanner">
<p>
Options used:
<itemize>
<item> <tt>ab</tt><em>&nbsp;&nbsp;Always print banner (default FALSE)</em>
<item> <tt>be=</tt><em>End banner generator program</em>
<item> <tt>bl=</tt><em>Short banner line format</em>
<item> <tt>bp=</tt><em>Banner generator program</em>
<item> <tt>bs=</tt><em>Start banner generator</em>
<item> <tt>generate_banner</tt><em>&nbsp;&nbsp;Generate banner for forwarded jobs</em>
<item> <tt>hl</tt><em>&nbsp;&nbsp;Banner (header) Last</em>
<item> <tt>of=</tt><em>Banner and File Separator Filter</em>
<item> <tt>sb</tt><em>&nbsp;&nbsp;Short banner (default FALSE)</em>
<item> <tt>sh</tt><em>&nbsp;&nbsp;Suppress header (banners) (default FALSE)</em>
</itemize>
<p>
Banner printing is one of the more complicated configuration options
of LPRng.
This is due mainly to historical evolution of the software,
as well as a lack of a well defined standard for
filter responsibilities.
In the original BSD print spoolers,
the philosophy was that banner printing should be delegated to the
filters,
as they were the most aware of the capabilities of the printers.
This required an
<em/out of band/
method to convey banner printing information to the filter,
and resulted in a complicated interface.
The original interface was:
<enum>
<item>
The filter doing banner printing was invoked as a special
<tt/of/ filter,
or passed a special flag.
<item>
The print spooling software would send a special
<bf>single line</bf>
of information telling it what the banner information should be.
Note that this line was never documented except for the source code,
and was inconsistent from version to version.
Also,
there was no indication of what to do with additional lines,
if any.
<item>
The filter would generate the banner,
discard the line,
and then pass other lines to the output device.
</enum>
<p>
Adding to the confusion,
the original print spoolers had a <tt/:sh/ (suppress header or banner)
flag,
which was supposed to suppress banner printing.
It did this by having the print spooler not generate the magic banner
information line.
<p>
A more sophisticated banner printing system would allow the
print spooler software to generate the banner,
and would then have the <tt/of/ filter act as a pass through.
Thus, we need configure the <tt/of/ filter NOT to use the first
line as banner printing information,
and to pass through all information to the device.
<p>
Complicating this whole mess is the
<tt/ld/  (leader option)
and
<tt/tr/  (trailer option)
which is a string sent to the output device (<tt/of/ filter)
when the device (filter) is initialized or terminated.
This can sometimes be interpreted as the banner line,
leading to unexpected results.
<p>
Sequence of Operations:
<enum>
<item>
If the
<tt>sh</tt> (suppress header) flag is true, no banner is
printed,
and the actions in this section are skipped.
No <it/banner information line/
is generated for the <tt/of/ filter,
and no banner printing program is invoked.
If there is an <tt/of/ filter and it is expecting such a line
and you have <tt/ld/ or <tt/tr/ information then
you may get unexpected results
(actually, catastrophic failure is a better term, but I digress).
<item>
If the <tt>hl</tt> (header last) flag is true the banner is printed at the end
of the job
and the actions in this section are done at the end of the job.
<item>
If the user does not want banner pages she can use the
<tt/lpr -h / option.
This will cause the <tt/lpr/ program
to delete the <tt>L</tt> (banner name) line in the control file.
If there is no <tt/L/ line in the control file
and
<tt>ab</tt> (always print a banner) is false
(the default),
then no banner is printed
and the other actions in this section are skipped.
If
<tt>ab</tt> is true
and the <tt/L/ line is missing then the <tt/N/ (user login name) is used;
if it is missing as well,
then ANONYMOUS is used for the user name.
<item>
If a banner printing program is specified by <tt/bp/, tt<tt/bs/,
or <tt/be/ options,
then LPRng will invoke the
program to generate a banner and then send the generated
banner to the printer
via the <tt/of/ filter.
The banner printing program will be invoked using
the standard filter command line flags
(see
<ref id="filtercmd" name="Filter Command Line Flags">
for details),
with is STDIN attached to /dev/null
and STDOUT attached to a file to hold the output banner.
<item>
If no banner printing program is specified
and the
<tt/sb/ (short banner) option is TRUE (default is true),
then the <tt/bl=.../ (banner line) option value
is expanded and sent to the <tt/of_fd/  (<tt/of/ filter or
device.
The default <tt>bl</tt> value is:
<tt>bl=$-'C:$-'n Job: $-'J Date: $-'t</tt>.
Using our example, this will get translated to:
<tscreen>
<verb>
papowell:A Job: file1 file2 Date: Thu Nov 27 23:02:04 PST 1997
</verb>
</tscreen>
<item>
If no banner printing program is specified and we have <tt/sb@/
(no short banner)
then we skip banner generation,
i.e. - we do <em/not/ send a banner generation line
to the output (<tt/of/ filter).
<item>
If the queue is a normal forwarding queue,
then the
<tt>generate_banner</tt>
option will invoke the
<tt/bp/, <tt/bs/ or <tt/be/
program as appropriate to create a banner page file which is then made the
first (default) or last (<tt/hl/ flag or <tt/be=.../ present)
file in a job.
This option has no effect in other types of queues.
See the <tt><ref id="translateformat" name="translate&lowbar;format"></tt>
option as well.
</enum>
<sect1>Printing Job Files
<label id="sendjobrwtimeout">
<label id="sendqueryrwtimeout">
<label id="sf">
<label id="format">
<p>
Options used:
<itemize>
<item> <tt>Xf=</tt><em>Format Filter</em>
<item> <tt>if=</tt><em>Default F Format Filter</em>
<item> <tt>pr=</tt><em>pr formatting program</em>
<item> <tt>send_job_rw_timeout=</tt><em> print job read/write timeout </em>
<item> <tt>send_query_rw_timeout=</tt><em> status query operation read/write timeout </em>
<item> <tt>sf</tt><em>&nbsp;&nbsp;Suppress FF Print File Separators</em>
</itemize>
<p>
Sequence of Operations:
for each job in listed in the control file,
the following operations are done in turn.
<enum>
<item>
If there is an <tt>of</tt> filter present,
the suspend string <tt>\031\001</tt> is written to of_fd
and the no further action is taken until the of filter is suspended.
<item>
The control file line for the job is examined,
and the first letter of the data file specification is used as the format.
<item>
If the format is
<tt>p</tt>,
the job is first processed by the program specified by the
<tt>pr</tt>
program,
and the program output used as the print file.
<item>
If the format is
<tt>f</tt>,
<tt>l</tt>,
or
<tt>p</tt>
then the <tt>if</tt> filter is used,
otherwise the keyword
<tt>Xf</tt> is used.
Note that certain formats such as
<tt>p, a, l</tt>, may not be used as formats.
<item>
The filter program is started with an appropriate set of command line options
(see
<ref id="filtercmd" name="Filter Command Line Flags">),
and with its STDOUT attached to the printing device (io_fd),
STDERR to a pipe which results in the output being written
to the status file,
and file descriptor 3 to the accounting file or program.
If debugging is enabled,
then the STDERR output is also written to the error log file (lf).
<item>
When doing a read/write operation to a device or remote system,
a timeout can be specified.
When doing a print or job transfer operation,
the <tt>send_job_rw_timeout</tt> value is used.
When doing a status or query operation,
the <tt>send_query_rw_timeout</tt> value is used.
If a write or write operation does not complete within
the specified timeout seconds, then we have an error
condition and job processing or the query operation
is terminated with JFAIL status.
If the timeout value is 0, then no timeout is done.
<item>
<label id="errorcodes">
<tt>lpd</tt> will then wait for the filter to exit.
The exit status can be as follows:
<tscreen>
<verb>
Key      Value   Meaning
JSUCC    0       Successful
JFAIL    1, 32   Failed - retry later
JABORT   2, 33   Abort - terminate queue processing
JREMOVE  3, 34   Failed - remove job
JHOLD    6, 37   Failed - hold this job
Other            Abort - terminate queue processing
</verb>
</tscreen>
<item>
If the filter exit status was JSUCC (0), or no error indicated,
then processing will continue otherwise the job termination takes
(see
<ref id="termination" name="Abnormal Termination">).
<item>
If the <tt>of</tt> filter is present,
then it is reactivated with a <tt>kill -CONT</tt> signal.
<item>
If the <tt>sf</tt> (suppress FF print file separators ) is false,
then the
<tt>ff</tt> (form feed) string
will be interpreted and sent to the of_fd.
</enum>
<sect1>Printing Banner At End
<p>
Options used:
<itemize>
<item> <tt>hl</tt><em>&nbsp;&nbsp;Header (Banner) Last</em>
</itemize>
<p>
The actions taken in this step are identical to those for the
<ref id="bp" name="Printing Banner At Beginning">,
with the exception that the
<tt>be</tt> (end banner program) is used to select the banner generation program
rather than the
<tt>bs</tt> (start banner program).
<p>
If we have <tt/hl/ true,
then we print a banner at the end of the job,
rather than start.
<p>
<sect1>Normal Termination
<label id="ae">
<label id="fq">
<label id="savewhendone">
<label id="tr">
<label id="normalterm">
<label id="waitforeof">
<label id="exitlingertimeout">
<p>
Options used:
<itemize>
<item> <tt>fq</tt><em>&nbsp;&nbsp;Form Feed on Close</em>
<item> <tt>la</tt><em>&nbsp;&nbsp;Local Printer Accounting</em>
<item> <tt>tr=</tt><em>Trailer on Close</em>
<item> <tt>ae=</tt><em>Accounting at end</em>
<item> <tt>save_when_done</tt><em>&nbsp;&nbsp;Save when done</em>
<item> <tt>wait_for_eof</tt><em>&nbsp;&nbsp;Wait for EOF before closing device</em>
<item> <tt>exit_linger_timeout</tt><em>&nbsp;&nbsp;connection linger on close timeout</em>
</itemize>
<p>
Sequence of Operations:
<enum>
<item>
If we are printing and the <tt>fq</tt> flag is set and the
<tt>sf</tt> (suppress interfile FF) flag is set,
then the
<tt>ff</tt> (form feed) string
will be interpreted and sent to the of_fd.
<item>
If we are printing, the <tt>tr</tt> (trailer) string
will be interpreted and sent to the of_fd.
<item>
If printing and the <tt>la</tt> (local printer accounting) flag is set
or transferring a job and the <tt>ar</tt> (remote accounting) flag is set,
the
<tt>ae</tt> is examined and accounting is done as described
for the
<tt><ref id="accountstart" name="as"> field.</tt>
<item>
If the <tt>of</tt> filter is present,
its STDIN is closed,
and the <tt>lpd</tt> server waits for it to exit.
The exit status is used as described above.
<item>
If the device is a socket or network connection,
the socket linger time is set to
<tt/job_send_rw_timeout/ value if nonzero or the
<tt/exit_linger_timeout/ value if nonzero,
a write <tt/shutdown/ is done,
and if the <tt/wait_for_eof/ option is true (default)
then a read is done on the connection until an EOF is found.
The device (io_fd) is then closed.
<item>
The job is marked as completed in the spool queue.
<item>
If the <tt>save_when_done</tt> flag is not specified,
the job is removed.
</enum>
<sect1>Abnormal Termination
<label id="saveonerror">
<label id="sendtry">
<label id="sendfailureaction">
<label id="mailfrom">
<label id="mailoperatoronerror">
<label id="sendmail">
<label id="stoponabort">
<label id="maxconnectinterval">
<label id="termination">
<p>
Options used:
<itemize>
<item> <tt>mail_from=</tt><em>Mail from user name</em>
<item> <tt>mail_operator_on_error=</tt><em>Mail to operator on error</em>
<item> <tt>send_try#</tt><em>&nbsp;&nbsp;Maximum Print or Transfer Attempts</em>
<item> <tt>save_on_error</tt><em>&nbsp;&nbsp;Do not delete on error</em>
<item> <tt>send_failure_action=</tt><em>Action on Failure</em>
<item> <tt>sendmail=</tt><em>sendmail path name and options</em>
<item> <tt>stop_on_abort</tt><em>&nbsp;&nbsp;Stop processing queue on filter abort</em>
</itemize>
<p>
If the job processing terminates abnormally,
the following sequence of events occurs:
<enum>
<item>
The job is marked as having an error during processing.
<item>
The LPD server will attempt to kill all filters and other associated processes
by sending a SIGINT and SIGCONT (<tt>kill -INT</tt> and <tt>kill -CONT</tt>)
to them.
<item>
If there is a <tt>mail_operator_on_error</tt> value,
the specified operator will be mailed an error indication.
The <tt>sendmail</tt> option specifies the pathname of the
<em>sendmail</em> program and the options needed to have it read
mail addresses from its standard input.
For example, <tt>sendmail=/usr/sbin/sendmail -oi -t</tt>
is a commonly used set of options.
<item>
The <tt>mail_from</tt> value specifies the user name used for
mail origination.  If not specified, the default is to use the print spool
queue or printer name.
<item>
If there is a <tt>send_failure_action</tt> specified,
then it is decoded and the corresponding action taken.
If the value is
<tt>remove</tt>,
<tt>hold</tt>,
<tt>abort</tt>,
or
<tt>retry</tt>,
then the job is removed, held, aborted, or retried.
If the value is <tt>|/program</tt>,
the program is executed and
the number of attempts are written to the filter STDIN.
The exit status of the filter will be used to determine the consequent actions.
That is, JSUCC (0) will be success, and the standard success action will
be taken;
JFAIL will cause retry,
JREMOVE will cause the job to be removed,
JHOLD will cause the job to be held,
JABORT or other status will abort processing.
<item>
If the status is ABORT and the
<tt>stop_on_abort</tt>
flag is set,
then further processing of jobs is terminated.
The job is not removed from the queue.
<item>
If the error status indicates removal,
and the <tt>save_on_error</tt> flag is clear
then the job is removed from the spool queue.
<item>
If the error status indicates that no further operations should
be performed on the queue,
then the <tt>lpd</tt> server will stop processing jobs.
<item>
If the error code indicated that the job should be retried,
and the
<tt>send_try</tt> value is 0 or the number of attempts is less than
the <tt>send_try</tt> value,
then the job is retried.
Between each attempt to transfer a job to a remote site.
This pause will double after each attempt,
reaching a maximum of <tt>max_connect_interval</tt> seconds.
If <tt>max_connect_interval</tt> is 0, there is no limit on the interval value.
</enum>
<sect1>LPD Spool Queue Processing
<label id="lpdforcepoll">
<label id="lpdpolltime">
<label id="maxserversactive">
<p>
Options used:
<itemize>
<item> <tt>lpd_force_poll=</tt><em>Force LPD to periodically poll print queues </em>
<item> <tt>lpd_poll_time#</tt><em>Time between polls</em>
<item> <tt>max_servers_active#</tt><em>Maximum number of active servers</em>
</itemize>
<p>
When the <tt>lpd</tt> server starts,
it will fork a set of subserver processes,
each which will handle an individual queue.
<p>
If a system has a large number of queues,
then this forking operation may result in the <tt>lpd</tt> server
exhausting the process resources.
To control this,  the
<tt>max_servers_active</tt> value restricts the number of active
children to the specified value.
If this value is 0,
then 50% of the maximum system processes value will be used.
<p>
Due to the limits on the number of processes,
there may be times when a job is placed in a queue,
but the <tt>lpd</tt> server is unable to start handling the job.
When all of the children of the main <tt>lpd</tt> server have
exited,
the server starts a timer.
After <tt>lpd_poll_time</tt> seconds,  it will scan the queues,
looking for jobs to process,
and starts a process to service them.
If it does not find any jobs it remains idle.
<p>
The <tt>lpd_force_poll</tt> flag causes the server to periodically
poll the queues.
This is useful when there is a high possibility that jobs could fail to be
printed due to high loads on the server.
<sect>Filters
<label id="secfilter">
<p>
This section gives an overview of how LPRng uses filter programs,
and gives a detailed discussion of how the printcap options and
filters interact.
<sect1>Filter Functions
<p>
Print filters are one of the most powerful tools in BSD-style printer
systems.
<p>
In general UNIX terms, a <em>filter</em> is a program that takes its input
file(s), does something with it, and sends the result to its standard
output. Most UNIX utilities are designed as filters.
(But since you are a system manager, you should already know that :))
<p>
In the context of a BSD-style print spooler (and also LPRng), the term
<em>filter</em> refers to a program that processes file while it is
being transferred to a printer.
<p>
The filter is executed with STDIN reading from the file to be
printed
STDOUT to the printer device or a temporary file.
STDERR (file handle 2) is redirected to the status file,
and file handle&nbsp;3 to an accounting file or program.
<p>
A filter can be as simple as a <tt>LF</tt> to <tt>CR/LF</tt>
translator,
or it can incorporate a complete
accounting system, automatic file type translations,
or even redirect the job to another printing system.
<p>
The <tt/lpf/
filter supplied as part of the LPRng distribution is a
a very simple CR to CR/LF conversion filter.
The <tt/ifhp/ filter provides support for more complex PostScript,
PCL,
and text printers.
<sect1>Print Job Formats
<label id="if">
<label id="printjobformats">
<p>
Options used:
<itemize>
<item>
<tt>if</tt>,
<tt>cf</tt>,
<tt>df</tt>,
<tt>gf</tt>,
<tt>nf</tt>,
<tt>of</tt>,
<tt>rf</tt>,
<tt>tf</tt>,
<tt>vf</tt>,
<em>X</em><tt>f</tt>,
<em>&nbsp;&nbsp;Filter programs </em>
</itemize>
<p>
LPRng has inherited a set of so-called `<bf>print formats</bf>' from its
BSD ancestor.
The format was used to specify the type of file that was being printed.
The <tt>lpd</tt> server
used the print format to select the filter for processing the file.
The de<bf/f/ault format is <tt>f</tt>.
<p>
The user can specify the format (i.e., the file type) by giving
the appropriate option to <tt>lpr</tt>:
<p>
<itemize>
<item>
<tt>-b</tt> or <tt>-l</tt>: Binary (literal) file. No processing should
be done.
The
<tt>l</tt> format is recorded as the file format.
</item>
<item><tt>-c</tt>: cifplot(1) output.</item>
<item><tt>-d</tt>: TeX DVI file.</item>
<item><tt>-g</tt>: Output from the plot(3X) routines.</item>
<item><tt>-n</tt> or <tt>-t</tt>: (di)troff output.</item>
<item><tt>-p</tt>: Text file that should be pre-processed by the <tt>pr</tt>
command, and then by the standard text filter.</item>
<item><tt>-v</tt>: Benson Varian raster image.</item>
</itemize>
<p>
Alternatively, one can also use
<tt>-Fx</tt>, where <tt>x</tt> is the format specifier.
(E.g., <tt>-Fc</tt>
instead of <tt>-c</tt>.)
This last form also allows you to use other
(non-standard) format specifiers.
<p>
The filter for format
<tt>X</tt>
is the value for the
<tt>Xf</tt> printcap
option,
with some minor exceptions.
The following
<tt>Xf</tt>
options have a pre-defined meaning.
<p>
<itemize>
<item>
<tt>if</tt>
The <tt>f</tt>
format filter,
i.e. - for the default
<tt>f</tt>
format.
All print jobs are passed
through this one, unless another format is selected.</item>
<item>
<label id="cf">
<tt>cf</tt> Cifplot data filter (for <tt>-c</tt> format).</item>
<item>
<label id="df">
<tt>df</tt> Filter for DVI files (<tt>-d</tt>).</item>
<item>
<label id="gf">
<tt>gf</tt> Graph data filter (<tt>-g</tt>).</item>
<item>
<label id="nf">
<tt>nf</tt> Ditroff data filter (<tt>-n</tt>).</item>
<item><tt>of</tt> This filter is used for processing the (optional)
banner at the start and/or end of the print job,
and also for the interjob separators.
See
<ref id="ofdetails" name="of"> filter for details.
<item>
<label id="rf">
<tt>rf</tt> Filter for Fortran style files (<tt>-r</tt>).</item>
<item>
<label id="tf">
<tt>tf</tt> Troff filter (<tt>-t</tt>).</item>
<item>
<label id="vf">
<tt>vf</tt> (Versatek) raster image filter (<tt>-v</tt>).</item>
</itemize>
<label id="ofdetails">
<sect1>OF Filter
<p>
The
<tt>of</tt>
filter is used to process banners and job separators.
The
<tt>of</tt> filter is responsible for performing appropriate
processing of this information and sending to the printer
for action.
<p>
While the various file filters are invoked on a once per print file basis,
the
<tt>of</tt>
filter is invoked on a once per print job basis.
<p>
This filter is the first one to be started,
and should perform whatever specialized device initialization
is needed.
It should also do whatever accounting procedure is desired
for start of job accounting.
<p>
The
<tt>of</tt>
filter will be given any banner printing or job separation
information for a job.
As part of its operation,
it can detect a specific string,
corresponding to a banner print request,
and generate a banner.
(See the
<ref id="jobsteps" name="Job Processing Steps and Printcap Options">
for details.)
<p>
During operation,
the
<tt>lpd</tt> server will send the special
<bf>stop</bf> sequence of <tt>\031\001</tt> to the
<tt>of</tt> filter.
The filter must then suspend itself using a
<tt>kill -STOP</tt> operation.
The <tt>lpd</tt> server will detect that the
<tt>of</tt> filter has suspended itself and then
will perform other printing operations.
<p>
After the other printing operations have been completed,
the <tt>of</tt> will then be sent a
<tt>kill -CONT</tt> signal.
<p>
This sequence will continue until all information has been printed,
and then the <tt>of</tt> filter's STDIN will be closed.
The filter will then perform whatever cleanup operations are needed,
update accounting or other information,
and exit.
<sect1>LPR -p format
<label id="pr">
<p>
Options used:
<itemize>
<item><tt>pr=</tt><em>pr program for p format</em>
</itemize>
<p>
The <tt>-p</tt> format is requires filtering the
the input files by the <tt>pr</tt> utility
and then passing the result through the
<tt>if</tt> filter.
<p>
This is widely regarded as a kludge and may not be supported
on your print spooler.
<sect1>LPR binary (-l) format
<p>
The binary (or literal) format is <tt>-l</tt>.
The <tt>if</tt> filter
is used to process the file,
and is invoked with the
<tt>-c</tt>
(<tt>c</tt>ancel processing?) flag.
<p>
The filter will not modify the file when sending it to the printer,
but may apply various setups to the printer.
<sect1>Filter Command Line Flags
<label id="bkfilteroptions">
<label id="bkoffilteroptions">
<label id="bkf">
<label id="filteroptions">
<label id="offilteroptions">
<label id="filterldpath">
<label id="filterpath">
<label id="passenv">
<label id="pl">
<label id="pw">
<label id="px">
<label id="py">
<label id="filtercmd">
<p>
Options used:
<itemize>
<item> <tt>bk_filter_options=</tt><em>Backwards Compatible Filter options</em>
<item> <tt>bk_of_filter_options=</tt><em>Backwards Compatible OF Filter options</em>
<item> <tt>bkf</tt><em>&nbsp;&nbsp;Backwards Compatible Filters</em>
<item> <tt>filter_ld_path=</tt><em>Filter LD_LIBRARY_PATH environment</em>
<item> <tt>filter_options=</tt><em>Filter options</em>
<item> <tt>filter_path=</tt><em>Filter PATH environment</em>
<item> <tt>of_filter_options=</tt><em>OF Filter options</em>
<item> <tt>pass_env=</tt><em>Environment variables to copy to Filter environment</em>
<item> <tt>pl#</tt><em>line count for page</em>
<item> <tt>pw#</tt><em>column count for page</em>
<item> <tt>px#</tt><em>pixel width for page</em>
<item> <tt>py#</tt><em>pixel length for page</em>
</itemize>
<p>
A filter (or program) specification in the LPRng printcap database
usually has the form:
<tscreen>
<verb>
:option=| [flags] /path [argument | "argument" | 'argument' ]*
:option=[flags]   /path [argument | "argument" | 'argument' ]*
</verb>
</tscreen>
<p>
The first case is used where the option value can be a string or filter,
and the second where a program is always expected.
The following procedure is used to run a filter program.
Arguments in single or double quotes are passed as a single value,
as for a shell.
<p>
The sequence of operations to run a filter is as follows:
<enum>
<item>
The program must be specified with an absolute path name.
<item>
By default, the program is run as the user if invoked from a client
program such as <tt>lpr</tt>, <tt>lpc</tt>, etc.
If invoked from <tt>lpd</tt>,  it is run as the
<tt>server_user</tt>
user
(default <tt>daemon</tt>) configuration entry.
<item><bf>ROOT</bf> Flag.
If the ROOT flag is specified the
filter is executed with Userid and Effective Userid ROOT (User ID 0).
By default it is executed with the <tt/user/ and <tt/group/
configuration option user and group ids.
Running a filter as ROOT is extremely dangerous,
and should only be used for programs that require
root permissions to open files or make network connections
from priviledged ports.
<item><bf>$- or -$</bf> Flag.
This flag suppresses appending options to the filter command line.
If the
<bf>$-</bf> or <bf>-$</bf> flag
is not specified,
the arguments determined by the value of the <tt>bkf</tt>
(Berkeley LPD filter compatible flag) flag are added to the
filter command line.
If <tt>bkf</tt> is false the
<tt>filter_options</tt> are added for OF filters and
<tt>of_filter_options</tt>
are added for non-OF filters;
if it is true, then the
<tt>bk_filter_options</tt> and <tt>bk_of_filter_options</tt> are added for
OF and non-OF filters respectively.
<p>
<table>
<tabular ca="|l|l|">
Option
|
DefaultValue
@
<tt>filter&lowbar;options</tt>
|
$C $F $H $J $L $P $Q $R $Z $a $c $d $e $f $h $i $j $k $l $n $p
$r $s $w $x $y $-a
@
<tt>of&lowbar;filter&lowbar;options</tt>
|
(same as <tt>filter&lowbar;options</tt>)
@
<tt>bk&lowbar;filter&lowbar;options</tt>
|
$P $w $l $x $y $F $c $L $i $J $C $0n $0h $-a
@
<tt>bk&lowbar;of&lowbar;filter&lowbar;options</tt>
|
$w $l $x $y
@
</tabular>
</table>
<p>
<item>
By default,
for programs that are not being invoked as print job file filters,
the
<tt>filter_options</tt>
arguments are added.
For print job filters, if the <tt>bkf</tt> flag is set,
then the
<tt>bk_filter_options</tt>
and
<tt>bk_of_filter_options</tt>
entries are used.
The default <tt>bk</tt> filter options are the same as originally used
with the BSD LPR filters.
For the <tt>of</tt> filter,
either the <tt>of_filter_options</tt>
or <tt>bk_of_filter_options</tt> arguments will be added.
<item>
The program arguments will then be scanned and interpreted.
Arguments of the form <tt>$</tt><em>letter</em> will be
translated into values from the
print job control file and/or printcap entry.
The letters have the following meaning:
<table>
<tabular ca="|l|l|">
Letter
|
TranslatedValue
@
<tt>a </tt>
|
printcap <tt>af</tt> (accounting file name)
@
<tt>b </tt>
|
job size (in K bytes)
@
<tt>c </tt>
|
binary file (<tt>l</tt> format for print file)
@
<tt>d </tt>
|
printcap <tt>cd</tt> or <tt>sd</tt> entry
@
<tt>e </tt>
|
print job data file name (currently being processed)
@
<tt>f </tt>
|
print job original name when spooled for printing (N info from control file)
@
<tt>h </tt>
|
print job originating host (H info from control file)
@
<tt>i </tt>
|
indent request (I info from control file)
@
<tt>j </tt>
|
job number in spool queue
@
<tt>k </tt>
|
print job control file name
@
<tt>l </tt>
|
printcap <tt>pl</tt> (page length)
@
<tt>m </tt>
|
printcap <tt>co</tt>
@
<tt>n </tt>
|
user name (L info from control file)
@
<tt>p </tt>
|
remote printer (when processing for bounce queue)
@
<tt>r </tt>
|
remote host (when processing for bounce queue)
@
<tt>s </tt>
|
printcap <tt>sf</tt> (status file)
@
<tt>t </tt>
|
time in common UNIX format
@
<tt>w </tt>
|
printcap <tt>pw</tt> (page width)
@
<tt>x </tt>
|
printcap <tt>px</tt> (page x dimension)
@
<tt>y </tt>
|
printcap <tt>py</tt> (page y dimension)
@
<tt>F </tt>
|
print file format
@
<tt>P </tt>
|
printer name
@
<tt>S </tt>
|
printcap <tt>cm</tt> (comment field)
@
Capital letter
|
Corresponding line from control file
@
&lcub;key&rcub;
|
printcap value for <tt>key</tt>
@
</tabular>
</table>
<item>
If there is no value for the specified argument,
then the argument is removed from the list.
If there is a value, the actual form of the substitution is
controlled by additional flags as follows.
<table>
<tabular ca="|l|l|">
Form
|
TranslatedValue
@
<tt> $x </tt>
|
<tt>'-x<em>value</em>' </tt>
@
<tt> $-x </tt>
|
<tt> '<em>value</em>' </tt>
@
<tt> $0x </tt>
|
<tt> -x '<em>value</em>' </tt>
@
<tt> $'x </tt>
|
<tt> -x <em>value</em> </tt>
@
</tabular>
</table>
<p>
Each entry in quotes is treated as a single value,
as in /bin/sh.
The <tt>$'x</tt> does not quote the value.
Combinations of the various flags are allowed.  For example,
<tt>$-x</tt> would simply substitute the value for <tt>x</tt>,
and then pass the whitespace separated components as individual arguments.
This last form is useful for adding in additional flags on the command line.
<item>
The command line is parsed,
metacharacters are ruthlessly stripped from all arguments and pathnames
and replaced by <tt>_</tt> (underscores),
and an argument list suitable for the <tt>execve</tt> system call
is formed.
<item>
A sanitized environment is set up for the program execution,
with the following environment variables.
<p>
<table>
<tabular ca="|l|l|">
<tt> USER </tt>
|
User name (client only)
@
<tt> LOGNAME </tt>
|
L control file info
@
<tt> HOME </tt>
|
Home directory (client only)
@
<tt> LOGDIR </tt>
|
Home directory (client only)
@
<tt> PATH </tt>
|
<tt>filter&lowbar;path</tt> configuration information
@
<tt> LD&lowbar;LIBRARY&lowbar;PATH </tt>
|
<tt> filter&lowbar;ld&lowbar;path </tt> configuration information
@
<tt> SHELL </tt>
|
<tt>/bin/sh</tt>
@
<tt> IFS </tt>
|
<tt>" \t"</tt>
@
<tt> TZ </tt>
|
Time zone
@
<tt> SPOOL&lowbar;DIR </tt>
|
<tt>sd</tt> printcap info
@
<tt> CONTROL&lowbar;DIR </tt>
|
<tt>cd</tt> printcap info
@
<tt> PRINTCAP&lowbar;ENTRY </tt>
|
printcap info
@
<tt> CONTROL </tt>
|
control file
@
</tabular>
</table>
<p>
<item>
If the filter is to be run by a client program such as <tt>lpr</tt>,
then the environment variables specified by the
<tt>pass_env</tt> configuration or printcap option will be
extracted from the environment,
have any metacharacters removed,
and then placed in the environment variable list.
Commonly, the
<tt>PGPPASS</tt>,
<tt>PGPPASSFD</tt>,
and <tt>PGPPATH</tt> are specified.
<item>
The program is started,
with STDIN, STDOUT, and STDERR attached to the appropriate files or
file descriptors.
If none is specified, then they are attached to
<tt>/dev/null</tt>.
</enum>
<sect1>LPRng Supported Filters
<p>
There already exists a large library of ready-to-use filters. Some of
them have LPRng-specific versions, which can be found at the
<ref id="secftp" name="LPRng ftp mirror sites">.
<sect2>Filter Distribution Conventions
<p>
By convention,
most filters are either totally standalone (very rare),
or require a set of support files.
There are two types of support files: per print queue configuration information
and global support information.
<p>
Since a print filter will execute with the current directory set to the
spool queue directory,
most filters expect that per print queue configuration information
should be kept in the spool directory.
Most <em>vintage</em> filters insist on having these files <em>hidden</em>
with names such as <bf><tt>.setup</tt></bf>.
This can make it difficult for administrators to determine where the
configuration files are.
<p>
It is strongly recommended that filters and information
be placed in commonly accessible directories such as
<tt><bf>/usr/local/libexec/filters</bf></tt>,
and the executables in subdirectories.
This allows the LPRng administrator to set the privileges on these
directories such that only the <tt>lpd</tt> process can
access them.
<p>
Most of the LPRng supported filters can either be used as a
<tt>if</tt> or <tt>of</tt> filter.
The filter will examine the format type passed by the <tt>-F<em>X</em></tt>
command line argument,
and if it is <tt>o</tt> it will perform as an <tt>of</tt> filter.
<p>
Alternatively,
the filter will check the filename in the pathname by which is was invoked.
If the name has the substring <tt>of</tt> in the filename,
then it assumes it is to act as an <tt>of</tt> filter.
This allows symbolic links to be made to a common filter executable,
each of which corresponds to the filter name by which it is to be invoked.
<p>
When a filter is invoked,
it is passed a large number of options,
many of which are totally ignored in filter operation.
However,
for many purposes it is necessary to provide options to the
filters to tailor their operation to the particular spool queue needs.
<p>
By convention,
all LPRng supported filters use the
<tscreen>
<verb>
-Tkey=value[,key=value]
</verb>
</tscreen>
<p>
convention for specifying filter configuration option values.
<sect1>lpf
<label id="lpf">
<p>
Source code:
<ref id="secftp" name="LPRng Distribution">
<p>
This filter is distributed as part of the LPRng source code,
and has a very limited functionality.
By default,
it only translates <tt>\n</tt> to <tt>\r\n</tt>
sequences,
and detects the OF Filter Stop sequence when invoked as an OF filter.
<itemize>
<item>Options:
<newline><tt>-Tcrlf</tt> - suppress <tt>\n</tt> to <tt>\r\n</tt> translation
</itemize>
<sect1>IFHP Filter
<label id="ifhp">
<p>
Source code:
<ref id="secftp" name="LPRng Distribution, ifhp-<em>version</em>.tgz">
<p>
This filter supports a wide variety of <it/smart/ printers,
or to be more specific,
printers which support PostScript, PCL or PJL languages.
<p>
As explained in
<ref id="installref" name="Setting Up Your Printer">,
you can have a parallel (unidirectional),
serial (bidirectional),
or network (bidirectional) connection.
When using a bidirectional connection,
you can sometime obtain or gratuitously receive error and/or status
information from the printer.
<p>
Some printers will spontaneously generate error messages when printing
a job on a bidirectional interface.
Usually, though,
it it necessary to force the printer to provide status in a reasonable format.
<p>
Some printers have the capability of printing either PCL or PostScript;
some require special setup commands and some will <em>autosense</em> which
type of job is being printed.
<p>
If you are printing text,
and not using a Page Description Language like PostScript or PCL,
then you may want to download a font to the printer.
This is especially the case when you are trying to print text files
in a non-English font.
<p>
Some printers will provide a <em>hardware</em> page counter value when requested;
however,
the means of requesting differ from model to model.
<p>
Sometimes you want to generate a special banner for a particular printer,
and need to put in some dynamic information.
While this can be done by the <tt>lpd</tt> server using the
<tt>bp</tt> program specification,
it turns out that non-LPRng systems which want to use the <tt>ifhp</tt>
want to have the same facilities.
Thus,  you need to have some way to get the same effect as the <tt>bp</tt>
option,  but at the filter level.
<p>
Having done <tt>lpd</tt> banner generation and printing,
why not have the filter run an accounting script as well?
<p>
At this point,  I suspect that the reader is beginning to suspect that
making a general purpose filter to support all of these possibilities is
difficult.
That is incorrect.  It is <bf>extremely</bf> difficult.
<p>
However,
the <tt/ifhp/ filter greatly simplifies this,
as it uses a simple database together with some printer configuration options.
For details,
see the <tt/ifhp/ documentation for details on using the filter.
For the terminally impatient,
the following is a quick cookbook:
<tscreen>
<verb>
# network connection to jet direct box,
#   no banners, HP compatible
lp
  :lp=ipaddr%9100
  :/usr/local/libexec/filters/ifhp
  :sh:sf
#
# banner added
#
lp
  :bp=/usr/local/libexec/filters/pclbanner
  :of=/usr/local/libexec/filters/ifhp
  :if=/usr/local/libexec/filters/ifhp
  :sf
#
# for a parallel port printer or when you want VERY fast
#  throughput, no pagecounts, error messages, etc.  The
#
lp
  :ifhp=status@
  :/usr/local/libexec/filters/ifhp
  :sh:sf
</verb>
</tscreen>
<sect1>Using your own filters
<p>
If you already have a working setup, with its own specific filter
programs, you might want to keep them. Or, you might want to write a
set of your own.
<p>
See the source code in the
<ref id="secftp" name="LPRng Distribution, FILTERS_LPRng-&lt;version>.tgz"> files for examples.
<sect>Permissions and Authentication
<label id="lpdpermsref">
<p>
The contents of the <tt>/etc/lpd.perms</tt> file
are used to control access to the <tt/lpd/ server facilities.
The model used for permission granting is similar to packet filters.
An incoming request is tested against a list of rules,
and the first match found determines the action to be taken.
The action is either <tt/ACCEPT/ or the request is granted,
or <tt/REJECT/ and the request is denied.
You can also establish a default action.
<p>
The following is a sample <tt>lpd.perms</tt> file.
<p>
<tscreen>
<verb>
# allow root on server to control jobs
ACCEPT SERVICE=C SERVER REMOTEUSER=root
REJECT SERVICE=C
#
# allow same user on originating host to remove a job
ACCEPT SERVICE=M SAMEHOST SAMEUSER
# allow root on server to remove a job
ACCEPT SERVICE=M SERVER REMOTEUSER=root
REJECT SERVICE=M
# all other operations allowed
DEFAULT ACCEPT
</verb>
</tscreen>
<p>
Each line of the permissions file is a rule.
A rule will ACCEPT or REJECT a request
if all of the patterns specified in the rule match.
If there is a match failure,
the next rule in sequence will be applied.
If all of the rules are exhausted,
then the last specified default authorization will be used.
<p>
The sense of a pattern match can be inverted using the NOT keyword.
For example,
the rules with
<tt>ACCEPT NOT REMOTEUSER=john,bill</tt>
succeeds only if the REMOTEUSER value is defined and
is not <tt>john</tt> or <tt>bill</tt>.
<p>
Each entry in a rule is a keyword which has is assigned a value or
list of values followed by an optional set of patterns that are matched
against these values.
The following table is a summary of the available keywords.
<p>
<table>
<tabular ca="|l|l|">
Keyword
|
Match
@
<tt>DEFAULT</tt>
|
default result
@
<tt>SERVICE</tt>
|
Checking lpC, lpR, lprM, lpQ, and Printing
@
<tt>USER</tt>
|
P (logname) field name in print job control file.
@
<tt>REMOTEUSER</tt>
|
user name in request from remote host.
@
<tt>HOST</tt>
|
DNS and IP address information for the H (host) field name in print job control file
@
<tt>REMOTEHOST</tt>
|
DNS and IP address information for the connection from the remote host making the request
@
<tt>IP</tt>
|
Alias for HOST
@
<tt>REMOTEIP</tt>
|
Alias for REMOTEHOST
@
<tt>REMOTEPORT</tt>
|
Originating TCP/IP port for the connection from the remote host making the request
@
<tt>SAMEUSER</tt>
|
USER and REMOTEUSER matches
@
<tt>SAMEHOST</tt>
|
HOST and REMOTEHOST matches
@
<tt>SERVER</tt>
|
request originates on lpd server
@
<tt>FORWARD</tt>
|
destination of job is not host
@
<tt>REMOTEGROUP</tt>
|
REMOTEUSER is in the specified group or netgroup in the <tt/lpd/ server group database.
@
<tt>GROUP</tt>
|
USER is in the specified group or netgroup in the <tt/lpd/ server group database.
@
<tt>LPC</tt>
|
LPC command in the LPC request.
@
<tt>CONTROLLINE</tt>
|
match a line in control file
@
<tt>AUTH</tt>
|
authentication type
@
<tt>AUTHUSER</tt>
|
authenticated user
@
<tt>AUTHFROM</tt>
|
authenticated forwarder
@
<tt>AUTHJOB</tt>
|
authenticated job in queue
@
</tabular>
</table>
<sect1>Permission Checking Algorithm
<p>
The <tt>lpd</tt> server uses the following algorithm to do
permission checks.
<enum>
<item>
Each line of the permissions file is a lists of tests (patterns)
and a permission value that is used if all of the tests (patterns)
on the line are successful.
A DEFAULT line sets the default result if all lines fail.
<item>
Each line is executed in sequence until a match is found.
The first matching line terminates the permission checking
and the corresponding permission value is used.
<item>
Each keyword has a value (or set of values) that are matched against
a set of patterns.
If the keyword does not have a value (or the <it/null/ value)
then the match will fail.
Initially,
all the keywords have a <tt/null/ value.
<item>
When a connection is received by the <tt/lpd/ server,
REMOTEHOST
and
REMOTEPORT
are set to the the IP addresses and hostnames, and the TCP/IP port
of the host originating the IP address respectively.
REMOTEIP and IFHP are aliases for REMOTEPORT
and PORT is an alias for REMOTEPORT. Thes
are provided for backwards compatibility with older versions of LPRng.
For example,
a request originating from <tt/10.0.0.2/, port 1011 would set
REMOTEIP to 10.0.0.2 and PORT to 1011.
<item>
The REMOTEHOST value is set to the result of doing a reverse DNS lookup
on the REMOTEIP address.
This value is the list of names <it/and/ ip addresses in standard
IP notation (nnn.nnn.nnn.nnn) that are returned by the
lookup.
If the DNS lookup fails
then the REMOTEHOST value is set to the REMOTEIP value.
For example,
lookup of 10.0.0.2 would result in the names
<tt/h2.private/ and <tt/patrick.private/,
and the only IP address assigned to it was <tt/10.0.0.2/.
The REMOTEHOST value would then be the list
<tt/h2.private,patrick.private,10.0.0.2/.
<item>
The SERVICE value is set to <tt/X/
and then the permissions database is scanned for a matching entry.
The result is the permission value of the first matching line or the default
permission.
If the result is REJECT then the connection is closed.
<item>
Next, a single line is read from the connection.
This line contains the request type,
the print queue name,
and depending on the request type an optional user name and options.
The SERVICE value is set to
<tt/R,/
<tt/Q,/
<tt/M,/
and
<tt/C,/
for a
<tt/lpR/,
<tt/lpQ/,
<tt/lprM/,
and
<tt/lpc/
request respectively and PRINTER to the print queue name.
<item>
If the request is for an <tt/lpc/ operation,
the LPC value is set to the name of the operation.
For example,
and
<tt/lpc lpd/
operation
<item>
If the request contains a user name then REMOTEUSER is assigned the user name.
<item>
If the request originates from the <tt/lpd/ server as determined by
the connection arriving from the <tt/localhost/ address or an
address assigned to one of the network interfaces for this host
then the SERVER value is set to true (or matches).
<item>
If the request is for an authenticated transfer,
(see
<ref id="authref" name="Authentication and Encryption">),
then the authentication procedures are carried out.
After they have been performed,
the AUTH value is set to true,
AUTHTYPE is set to the name of the authentication method,
AUTHUSER to the authenticated identifier of the originator of the request,
and AUTHFROM to the authenticated identifier of the originator of the connection.
<item>
Other matching keywords such as REMOTEGROUP use values set at this time.
These are discussed in the next section.
<item>
The permission database is rescanned,
this time to see if there is permission to operate on the
specified spool queue.
The permission database is first checked to see
if the requesting user has control (SERVICE=C) permission.
If they do,
then they can permform any operation on the spool queue.
The scan is then repeated for the actual request.
<item>
If there is no permission to perform the operation
then an error code and messages is returned on the
requesting connection.
<item>
If the operation is for a spool queue or server,
no other permissions checking is done.
This includes the <tt/lpq/ command,
and most of the <tt/lpc/ commands control queue operations.
<item>
If the operation is for for individual jobs in a spool queue,
then the queue is scanned and job information is extracted
for each job in the queue.
The USER value is set to the job control file <tt/P/ line.
The value of the <tt/H/ line in the control file is used to perform a
DNS lookup,
and the HOST value is set to the results of this lookup.
IP is an alias for HOST,
and is retained for backwards compatibility.
<item>
The SAMEUSER value is set to true (or match) if the REMOTEUSER
value is identical to the USER value.
Similarly,
SAMEHOST is set to true if the REMOTEHOST value matches the HOST value.
See the following sections for other keywords such as GROUP.
<item>
The permission checking is done for each individual job in a
spool queue,
and if it succeeds the action is carried out on the job.
</enum>
<p>
These checks are applied on the arrival of a job from an external
connection.
Unfortunately,
there are a set of print spooler implementations that do not
handle job rejection due to lack of permissions.
These printers will continually and repeatedly attempt to send a job
for which there is no printing permission until the job is removed
by administrative action.
To accommodate these printers,
we must accept jobs for printing and then dispose of them.
This is done by using the SERVICE=P (printing) checks.
<p>
<enum>
<item>
When a print spool is active and is printing or forwarding jobs,
before it processes a job it will read the job control file
and set the <tt/USER/  and <tt/HOST/
values as discussed in the previous sections.
It will also set the <tt/AUTH/,
<tt/AUTHUSER/,
and <tt/AUTHJOB/
values as well,
if the job was spooled by using an authenticated method.
<item>
The permissions database will be scanned
and the resulting permission determined.
Note that the values of the REMOTE keys are undefined,
and tests using them will have unpredicitible effects.
<item>
If the job does not have permission to be printed,
it will normally be removed from the spool queue.
</enum>
<p>
While this model is very simple
it can handle a wide range of situations.
However,
it is really based on the simple <bf/trust/ that
users will not <it/impersonate/ other users or hosts.
If this is not the case,
then more elaborate proceedures based on encryption and
authentication are called for.
<p>
There is a problem with permissions checking for <tt/lpq/ (SERVICE=Q)
requests.
Since the user name is not passed as part of the request,
it is impossible to use the REMOTEUSER clause to restrict <tt/lpq/
operations.
<p>
The <tt>SERVICE=R</tt> and <tt>SERVICE=P</tt>
facilities are provided to handle problems with print spoolers that
do not recognize a <it>lack of permission</it> error code,
and will indefinately retry sending a job to the <tt>lpd</tt> server.
If this is the case,
then the <tt>SERVICE=R</tt> clause can be used to accept jobs,
and then the <tt>SERVICE=P</tt> clause will cause the <tt>lpd</tt>
server to remove of the job when it is scheduled for printing.
<sect1>Rule Matching Procedures
<p>
<tscreen>
<verb>
[not] key                                 assigned value
[not] key=pattern                         substring match
[not] key=pattern1,pattern2,pattern3,...  glob and exact
[not] key=IP1/mask1,IP2/mask2,...         IP address
</verb>
</tscreen>
<p>
Each of the indicated values is matched against a list of patterns.
The following types of matches are used:
<enum>
<item>
assigned value.
The keyword has an assigned value which is true (match) or false (no match).
Examples are SAMEHOST and SERVER.
<item>
substring match.
The indicated entry is present as a substring in the pattern.
<item>
GLOB matches.
The pattern is interpreted as a GLOB style pattern,
where * matches 0 or more characters,
and ? matches a single character,
and
<tt/[L-H]/
specifies a range of characters from
<tt/L/ to <tt/H/,
in ASCII order.
<item>IP address match.  The address must be specified in the
standard <tt>nn.nn.nn.nn</tt> format.
The mask must be either an integer number
corresponding to the number of significant bits,
or in the standard <tt>nn.nn.nn.nn</tt> format.
Addresses are compared by doing
<tscreen>
<verb>
( IPaddr XOR IP ) AND mask
</verb>
</tscreen>
<p>
If the result is 0, then a match results.
Note that there may be one or more addresses being checked for;
this can occur when a host may have multiple IP addresses assigned to it.
<item>integer range match.
The pattern has the form <tt>low-high</tt>,
where low and high are integer numbers.
The match succeeds if the value is in the specified range.
<item>Same IP Address Match.
This compares two lists of IP addresses;
a match is found when there is one or more common addresses.
</enum>
<sect2>DEFAULT
<p>
<tscreen>
<verb>
DEFAULT ACCEPT
DEFAULT REJECT
</verb>
</tscreen>
<p>
The DEFAULT rule specifies the default if no rule matches.
Normally,
there is one DEFAULT entry in a permissions file.
<tscreen>
<verb>
Example:

DEFAULT ACCEPT
</verb>
</tscreen>
<sect2>SERVICE
<p>
Match type: substring
<p>
The SERVICE key is based on the type of request.
<table>
<tabular ca="|l|l|">
Key
|
Request
@
<tt>C</tt>
|
LPC Control Request
@
<tt>M</tt>
|
LPRM Removal Request
@
<tt>P</tt>
|
Printing
@
<tt>Q</tt>
|
LPQ Status Request
@
<tt>R</tt>
|
LPR Job Transfer
@
<tt>X</tt>
|
Connection Request
@
</tabular>
</table>
<p>
Each of the above codes corresponds either directly to the user command,
or a set of subcommands.
<p>
If you have an LPC request,
you can add an <tt>LPC=xxx</tt> clause to refine the
permissions checking to allow or disallow
<tt/lpc/ commands such as <tt>lpc status, printcap, active, </tt>.
<tscreen>
<verb>
Example:

# control only from root on server
ACCEPT SERVICE=C SERVER USER=root
REJECT SERVICE=C
# accept all others
ACCEPT SERVICE=*
</verb>
</tscreen>
<sect2>USER
<p>
Match type: GLOB
<p>
The USER information is taken from the <tt>P</tt> (person or logname)
information in the print job control file.
<tscreen>
<verb>
Example:

# we allow jobs to be spooled
ACCEPT SERVICE=R
# now we do the checking at print time
ACCEPT SERVICE=P USER=root
REJECT SERVICE=P
</verb>
</tscreen>
<sect2>REMOTEUSER
<p>
Match type: GLOB
<p>
The REMOTEUSER information is taken from the user information sent
with a service request.
<p>
Note that one of the flaws of
<ref id="rfc1179" name="RFC1179">
is that an LPQ (print status)
request does not provide a REMOTEUSER name.
<tscreen>
<verb>
Example:

ACCEPT SERVICE=C REMOTEUSER=root,papowell,admin SERVER
ACCEPT SERVICE=C LPC=status,lpd REMOTEUSER=admin
REJECT SERVICE=C
</verb>
</tscreen>
<sect2>HOST
<p>
Match type: GLOB
<p>
The <tt>H</tt> (host) information in the print job control file
is used to do a DNS lookup,
and the resulting list of names and addresses is used for matching purposes.
<tscreen>
<verb>
Example:

# we allow jobs to be spooled
ACCEPT SERVICE=R
# now we do the checking at print time
# allow from our private subnet
ACCEPT SERVICE=P HOST=10.0.0.0/8,*.othernet.com
REJECT SERVICE=P
</verb>
</tscreen>
<sect2>REMOTEHOST
<p>
Match type: GLOB
<p>
The REMOTEHOST information is obtained by doing a reverse IP name lookup
on the remote host IP address
and the resulting list of names and addresses is used for matching purposes.
If there is no FQDN available,
then the IP address in text form will be used.
<tscreen>
<verb>
Example:

# allow from our private subnet
ACCEPT SERVICE=R REMOTEHOST=10.0.0.0/8,*.othernet.com
REJECT SERVICE=R
</verb>
</tscreen>
<sect2>REMOTEPORT
<p>
Match type: integer range
<p>
The REMOTEPORT value is the originating port of the TCP/IP connection.
The match succeeds if it is in the specified range.
<tscreen>
<verb>
Example:

# require connections to originate from priviledged port
ACCEPT SERVICE=X REMOTEPORT=1-1023
REJECT SERVICE=X
</verb>
</tscreen>
<sect2>PORT
<p>
Alias for REMOTEPORT.
<sect2>IP
<p>
Alias for HOST.
<sect2>REMOTEIP
<p>
Alias for REMOTEHOST.
<sect2>LPC
<p>
Match type: GLOB
<p>
The requested <tt/lpc/ command.
This allows the following permissions line to be used:
<tscreen>
<verb>
Example:

#allow remoteuser admin on server to use LPC topq and hold
ACCEPT SERVICE=C SERVER REMOTEUSER=root
ACCEPT LPC=topq,hold SERVER REMOTEUSER=papowell
REJECT SERVICE=C
</verb>
</tscreen>
<p>
<sect2>SAMEUSER
<p>
Match type: exact string match
<p>
Both the REMOTEUSER and USER information must be present and identical.
<tscreen>
<verb>
Example:

# LPC users can do anything
ACCEPT SERVICE=C SERVER REMOTEUSER=root
REJECT SERVICE=C
# allow users who sent jobs from the same host to remove them
ACCEPT SERVICE=M SAMEUSER SAMEHOST
REJECT SERVICE=M
</verb>
</tscreen>
<sect2>SAMEHOST
<p>
Match type: Same IP Address
<p>
The REMOTEHOST and HOST address lists are checked;
if there is a common value the match succeeds.
<tscreen>
<verb>
Example:

# allow root on the same host as user
# to remove files
ACCEPT SERVICE=M SAMEHOST REMOTEUSER=root
REJECT SERVICE=M
</verb>
</tscreen>
<sect2>SERVER
<p>
Match type: Matching IP Address
<p>
One of the REMOTEHOST addresses
must be the same as one of the addresses of the <tt>lpd</tt> server host,
or must be one of the addresses found by looking up the <tt>localhost</tt>
name using <tt>gethostbyname()</tt>.
<tscreen>
<verb>
Example:

# allow root on the server full LPC permissions
ACCEPT SERVICE=C SERVER REMOTEUSER=root
REJECT SERVICE=C
</verb>
</tscreen>
<sect2>FORWARD
<p>
Match type: Address Match
<p>
The list of REMOTEHOST and HOST addresses must not have a common entry.
This is usually the case when a remote <tt>lpd</tt> server is forwarding
jobs to the <tt>lpd</tt> server.
<tscreen>
<verb>
Example:

# do not accept forwarded jobs or requests
REJECT SERVICE=* FORWARD
</verb>
</tscreen>
<sect2>GROUP
<p>
Match type: modified GLOB
<p>
The USER must be present in
one of the groups in <tt>/etc/group</tt> or whatever permissions mechanism is used
to determine group ownership
which matches the GLOB pattern.
If the pattern has the form <tt/@name/,
then a check to see if the user is in the named netgroup is done.
<tscreen>
<verb>
Example:

ACCEPT SERVICE=P GROUP=admin,@netgroup
REJECT SERVICE=P
</verb>
</tscreen>
<sect2>REMOTEGROUP
<p>
The same rules as for GROUP,
but using the REMOTEUSER value.
<tscreen>
<verb>
Example:

ACCEPT SERVICE=R REMOTEGROUP=admin,@netgroup
REJECT SERVICE=R
</verb>
</tscreen>
<sect2>CONTROLLINE
<p>
Match type: GLOB
<p>
A <tt>CONTROLLINE</tt> pattern has the form
<tscreen>
<verb>
X=pattern1,pattern2,...
</verb>
</tscreen>
<p>
X is a single upper case letter.
The corresponding line must be present in a control file,
and the pattern is applied to the line contents.
<p>
This pattern can be used to select only files with specific control
file information for printing.
<sect2>AUTH
<p>
Match type: value
<p>
If the current transfer or the transfer used to send a job
was authenticated,
then AUTH is true or matches.
<tscreen>
<verb>
Example:

# reject all non-authenticated transfers
REJECT NOT AUTH
</verb>
</tscreen>
<sect2>AUTHTYPE
<p>
Match type: glob
<p>
If the current transfer or the transfer used to send a job
was authenticated,
then AUTHTYPE is set to the name of the authentication method.
<tscreen>
<verb>
Example:

# require kerberos, pgp, or md5 authentication
REJECT NOT AUTHTYPE=kerberos*,pgp,md5
</verb>
</tscreen>
<sect2>AUTHUSER
<p>
Match type: GLOB
<p>
The AUTHUSER rule will check to see if the authenticated user identification
matches the pattern.
<tscreen>
<verb>
Example:

ACCEPT SERVICE=C AUTHTYPE=kerberos* AUTHUSER=admin@ASTART.COM
</verb>
</tscreen>
<sect2>IFIP
<p>
Match type: IPmatch, but for IPV6 as well as IPV4
<p>
There is a subtle problem with names and IP addresses which are
obtained for 'multi-homed hosts', i.e. - those with multiple
ethernet interfaces,  and for IPV6 (IP Version 6),  in which a host
can have multiple addresses,  and for the normal host which can have
both a short name and a fully qualified domain name.
<p>
The IFIP (interface IP) field can be used to check the IP address
of the interface
that accepted the network connection,
as reported by the information
returned by the accept() system call.  Note that this information may
be IPV4 or IPV6 information,  depending on the origination of the
system.  This information is used by gethostbyaddr() to obtain the
originating host fully qualified domain name (FQDN) and set of IP addresses.
Note that this FQDN will be for the originating interface,  and may
not be the canonical host name.  Some systems which use the Domain Name Server
(DNS) system may add the canonical system name as an alias.
<p>
This entry is deprecated and may not be supported in future releases.
<sect1>Permission File Location
<label id="permspath">
<p>
Options used:
<itemize>
<item> <tt>perms_path=</tt><em> directory path list</em>
</itemize>
<p>
The <tt>perms_path=</tt> configuration variable specifies the
location of the default permissions file.
The default value is:
<tscreen>
<verb>
perms_path=/etc/lpd.perms:/usr/etc/lpd.perms
</verb>
</tscreen>
<p>
The <tt>lpd.perms</tt> file can be obtained by running a program,
in a similar manner to the <tt>/etc/printcap</tt> file.
See
<ref id="secfilter" name="Filters"> for details on how
the program would be invoked.
For example, assume the configuration information specified:
<tscreen>
<verb>
perms_path=|/usr/local/libexec/get_perms
</verb>
</tscreen>
<p>
The <tt/lpd/ server will write either a blank line
for connection (<tt/SERVICE=X/) and global <tt/lpc/ permissions
(<tt/SERVICE=C/ and <tt/LPC=reread,lpd,default/)
or the name of the spool queue to the <tt>get_perms</tt>
STDIN,
and expects to read permission information from its STDOUT.
If the filter method is used,
it should always return the complete set of connection (<tt/X/)
and control (<tt/C/ service values.
<sect1>Example Permission File
<p>
<tscreen>
<verb>
# allow root on server to control jobs
ACCEPT SERVICE=C SERVER REMOTEUSER=root
ACCEPT SERVICE=C LPC=lpd
REJECT SERVICE=C
#
# allow same user on originating host to remove a job
ACCEPT SERVICE=M SAMEHOST SAMEUSER
# allow root on server to remove a job
ACCEPT SERVICE=M SERVER REMOTEUSER=root
REJECT SERVICE=M
# all other operations allowed
DEFAULT ACCEPT
</verb>
</tscreen>
<p>
In the above sample, we first specify that
lp<tt>C</tt>
commands from user <tt>root</tt> on the lpd server will be accepted.
This is traditionally the way that most lpc commands operate.
We also allow anybody to use the <tt/lpc lpd/ command.
We reject any other <tt/lpc/ requests.
<p>
We accept
lpr<tt>M</tt>
requests from the host and user that submitted the job,
as well as from root on the server,
and reject any others.
<p>
Finally,
all other types of commands (lpq, lpr) are allowed by default.
<sect1>Complex Permission Checking
<p>
One of the more useful types of permission checking is to
restrict access to your printers from users outside your
networks.
The IP pattern can specify a list of IP addresses and netmasks
to apply to them.
<p>
For example
<tt>IP=10.3.4.0/24</tt> would match all hosts with the IP
addresses
<tt>IP=10.3.4.0</tt> to
<tt>IP=10.3.4.255</tt>.
<p>
Similarly, the HOST pattern can specify a set of hostnames
or patterns to match against based on the GLOB notation.
<p>
For example
<tt>REMOTEHOST=*.astart.com</tt>
would match all hosts with a DNS entry which ended with
<tt>astart.com</tt>.
<p>
The NOT keyword reverses the match sense.  For example
<tt>REJECT NOT REMOTEHOST=*.astart.com,*.murphy.com</tt>
would reject all requests from hosts which did not have a DNS entry
ending in
<tt>astart.com</tt>
or
<tt>murphy.com</tt>.
<sect1>More Examples
<p>
The following is a more complex lpd.perms file.
<tscreen>
<verb>
# All operations allowed except those specifically forbidden
DEFAULT ACCEPT
#Reject connections which do not originate from hosts with an
# address on 130.191.0.0 or from localhost,
# or name is not assigned to Engineering pc's
REJECT SERVICE=X NOT IFIP=130.191.0.0/16,127.0.0.1/32
REJECT SERVICE=X NOT REMOTEHOST=engpc*
#Do not allow anybody but root or papowell on
#astart1.astart.com or the server to use control
#facilities.
ACCEPT SERVICE=C SERVER REMOTEUSER=root
ACCEPT SERVICE=C REMOTEHOST=astart1.astart.com REMOTEUSER=papowell
#Allow root on talker.astart.com to control printer hpjet
ACCEPT SERVICE=C HOST=talker.astart.com PRINTER=hpjet REMOTEUSER=root
#Reject all others
REJECT SERVICE=C
#Do not allow forwarded jobs or requests
REJECT SERVICE=R,C,M FORWARD
# allow same user on originating host to remove a job
ACCEPT SERVICE=M SAMEHOST SAMEUSER
# allow root on server to remove a job
ACCEPT SERVICE=M SERVER REMOTEUSER=root
</verb>
</tscreen>
<sect1>Authentication
<label id="authref">
<p>
One of the major problems in a print spooler system is providing
privacy and authentication services for users.  One method is to
construct a specific set of protocols which will be used for
providing the privacy or authentication;  another is to provide a
simple interface to a set of tools that will do the authentication
and/or encryption.
<p>
LPRng provides native support for the MIT Kerberos 4 extensions and
Kerberos 5 authentication.
<p>
LPRng has native support for the PGP (Pretty Good Privacy) program
and can sign and optionally encrypt command and responses between servers
and clients.
Due to legal restrictions,
an external PGP program must be used for this purpose.
<p>
A simple MD5 hash based authentication scheme is also provided as an
example to illustrate how new or different authentication methods
can be adddd.
<p>
Finally,
LPRng provide a general purpose interface allowing users to insert their
own authentication methods,
either at the program level or at the code level.
<sect1>Authentication
<p>
A careful study of the authentication problem shows that it should be done
during reception of commands and/or jobs from a remote user and/or
spooler.  At this time the following must be done:
<enum>
<item>
The received command must be checked for consistency,  and the
remote user and host must be determined.
<item>
The remote user and host must be authenticated.
<item>
The command and/or spooling operation must be carried out.
<item>
The results must be returned to the remote system.
</enum>
<p>
<sect1>Identifiers
<p>
When a user logs into a system,  they are assigned a user name
and a corresponding UserID.  This user name is used by the LPRng
software when transferring jobs to identify the user.
<p>
When we look into the problem of authentication,  we will possibly
have a more global user identification to deal with, the
authentication identifier (AuthID).  One way to deal with this problem is to
give LPRng intimate knowledge of the UserID and AuthID relationship.
While this is possible it is difficult to deal with in a
simple and extensible manner.  An alternate solution is to provide
a mapping service,  where the authentication procedure provides
a map between the UserID and AuthID.
<sect1>RFC1179 Protocol Extensions
<p>
The RFC1179 protocol specifies that a LPD server command sent on
a connection has the form:
<tscreen>
<verb>
\nnn[additional fields]\n
</verb>
</tscreen>
<p>
<tt>\nnn</tt> is a one octet (byte) value with the following meaning:
<p>
<tscreen>
<verb>
REQ_START   1    start printer
REQ_RECV    2    transfer a printer job
REQ_DSHORT  3    print short form of queue status
REQ_DLONG   4    print long form of queue status
REQ_REMOVE  5    remove jobs
</verb>
</tscreen>
<p>
The LPRng system extends the protocol with the following additional
types:
<tscreen>
<verb>
REQ_CONTROL 6    do control operation
REQ_BLOCK   7    transfer a block format print job
REQ_SECURE  8    do operation with authentication
</verb>
</tscreen>
<p>
The REQ_CONTROL allows a remote user to send LPC commands to the
server.  The REQ_BLOCK provides an alternate method to transfer a
job.  Rather than transferring the control and data files individually,
this format transfers one file.  The REQ_AUTH provides a mechanism
for providing an authentication mechanism and is described in this
document.
<sect1>Authentication Operations
<label id="auth">
<label id="authforward">
<p>
Options used:
<itemize>
<item> <tt>auth=</tt><em>client to server authentication type</em>
<item> <tt>auth_forward=</tt><em>server to server authentication type</em>
<item> <tt>XX_id=</tt><em>server identification</em>
<item> <tt>XX_forward_id=</tt><em>Server identification</em>
</itemize>
<p>
A client (<tt/lpr, lpc, etc/ to <tt/lpd/ server authenticated transfer
proceeds as follows.
If an authenticated transfer is specified by the
<tt/auth=protocol/ entry in the printcap or configuration information,
the client sends a request for an authenticated transfer
to the server.
<p>
Part of the authentication request is the authentication type.
If authentication type <tt/XX/ is requested
the server will examine the information in the printcap and configuration
entries for an <tt/XX_id/ value.
If this value is present then the server supports authentication of this type.
Further permission checks are carried out and finally the
server will accept or reject the authentication request.
If the request is accepted the server returns a postive
acknowlegement (single 0 byte) to the requester,
otherwise it returns a nonzero value and an error message.
<p>
If the request is accepted
then an authentication specific protocol exchange is carried out between
client and server.
The commands and/or data files
are encrypted and/or signed and transferred to the server.
The protocol specific software on the server will then decrypt and/or check
signatures,
perform the requested actions,
and in turn generate a status information.
The status information is encrypted and/or signed by the server
and sent to the client,
where the client decrypts and/or checked for correct signature.
<p>
A <tt/lpd/ server to <tt/lpd/ server authenticated transfer
proceeds as follows.
If an authenticated transfer is specified by the
<tt/auth_forward=protocol/ entry in the printcap or configuration information,
the originating server sends a request for an authenticated transfer
to the destination server.
The originating server plays the part of the client
and performs the same set of actions.
<p>
The following printcap or user level information needs to be provided
for an authenticated exchange.
<enum>
<item>
The <tt>auth</tt> option specifies the authentication type to be used
for client to server transfers.
For example,
<tt/auth=kerberos/ or
<tt/auth=kerberos5/ or
would specify Kerberos 5 authentication,
<tt/auth=kerberos4/ would specify Kerberos 4 authentication,
<tt/auth=pgp/ would specify PGP authentication,
<tt/auth=md5/ would specify MD5 authentication,
etc.
The special form <tt/auth@/ specifies no authentication.
<item>
The <tt>auth_forward</tt> option specifies the authentication type to be used
for server to server transfers.
For example,
<tt/auth_forward=kerberos5/ would specify Kerberos 5 authentication,
etc.
The special form <tt/auth@/ specifies no authentication.
<item>
The authenticated transfer request sent to a server has one of the
following forms, depending on the orginator:
<tscreen>
<verb>
\008printer C user_id authtype \n     - for commands (lpq, lpc, etc.)
\008printer C user_id authtype size\n - for print jobs (lpr)
\008printer F server_id authtype \n     - forwarded commands (lpq, lpc, etc.)
\008printer F server_id authtype size\n - forwarded print jobs (lpr)
</verb>
</tscreen>
<p>
The single character with the <tt/\008/ value signals that this
is an authentication request
the <tt/printer/ is the name of a print queue,
and the <tt/C/ (client) or <tt/F/ indicates that the request is from
a client program or is a forwarded request from a server.
The <tt/user_id/ or <tt/server_id/ field is an identifier supplied by
the originator and is dicussed below.
If the <tt/size/ value is present then the request
is for a job transfer and this value represents the job size.
It is used to determine if there is sufficient space in the spool queue
for the job.
<item>
The <tt/user_id/ or <tt/server_id/ fields in the authentication
request are obtained as follows.
If the request originates from a client,
then the <tt/user_id/ is the user name of the originator obtained from
password information.
If the request originates from a server,
then the  <tt/server_id/ is the printcap or configuration
<tt/xx_id=server_id/ value,
where <tt/xx/ is the value of the <tt/auth_forward=xx/ entry.
<item>
When the authenticated transfer request is received,
the destination will either return a single zero byte,
or a non-zero byte value followed by additional refusal information.
A refusal terminates the protocol exchange.
<item>
Further exchanges are then determined by the authentication
protocol specific requirements.
<item>
Once the initial exchanges have been completed
a user file and/or command will be transferred to the destination server.
<item>
An authentication protcol specific <tt/AUTHFROM/ and <tt/AUTHUSER/
strings will be supplied
to the lpd server for purposes of permission checking.
<item>
The lpd server then carries out the requested operation,
and will write error and status information into a file.
<item>
After the requested activity has finished,
protocol specific module transfer the status information in the
file to the requesting system
and terminate the protocol exchange.
</enum>
<sect1>Permission Checking
<p>
When an authenticated transfer has been performed,
the following permission information will be provided.
<itemize>
<item>
AUTH
<newline>
This value is <tt/true/ or <tt/match/ if an authenticated request
was received.
<item>
AUTHTYPE=authtype
<newline>
This has the value of the <tt/authtype/ field in the authentication
request.
<item>
AUTHUSER=userinfo
<newline>
This is the <tt/AUTHUSER/ information provided by the authentication
protocol,
and is usually the originating user's identification.
<item>
AUTHFROM=frominfo
<newline>
This is the <tt/AUTHUSER/ information provided by the authentication
protocol,
and is usually the originating system (user or lpd server) identification.
<item>
AUTHSAMEUSER
<newline>
This item has effect only when checking jobs in a spool queue.
The <tt/AUTHUSER/ information from the request is compared to the
<tt/AUTHUSER/ information from the request that created a job.
If they are identical,  the match succeeds.
<item>
AUTHJOB
This item has effect only when checking jobs in a spool queue.
If the job was transfered using an authentication protocol the match succeeds.
<newline>
</itemize>
<p>
For example,  to reject non-authenticated operations, the following
line could be put in the permissions file.
<tscreen>
<verb>
REJECT NOT AUTH
</verb>
</tscreen>
<p>
If a remote server has id information FFEDBEEFDEAF,  then the
following will accept only forwarded jobs from this server.
<tscreen>
<verb>
ACCEPT AUTH AUTHFROM=FFEDBEEFDEAF
REJECT AUTH
REJECT NOT AUTH
</verb>
</tscreen>
<p>
To allow only authenticated users to remove jobs you can use:
<tscreen>
<verb>
ACCEPT AUTH SERVICE=R,M,L,P AUTHSAMEUSER
REJECT AUTH
REJECT NOT AUTH
</verb>
</tscreen>
<sect1>PGP Authentication Support
<p>
PGP is a well known encryption and authentication program.
For more details see the web site
<htmlurl url="http://www.pgp.net" name="http://www.pgp.net">
or the ftp site
<htmlurl url="ftp://ftp.pgp.net" name="ftp://ftp.pgp.net">.
<p>
LPRng has greatly simplified the use of PGP for authentication
by building in support as follows.
<itemize>
<item>
The <tt/user/ and <tt/group/ configuration entry (defaults
<tt/daemon/ and <tt/daemon/ respectively) specify the user and group id
used by the <tt/lpd/ server for file and program execution.
PGP uses the current user id of the PGP process to determine the locations
of various configuration files and information.
In this discussion we will assume that <tt/lpd/ runs as uid <tt/daemon/.
<item>
By default,
the PGP program expects the public and secret key rings to be in the
<tt>$HOME/.pgp/</tt> directory
to be readable only by the user.
In order to set up PGP authentication,
make sure that the <tt/daemon/ account has a home directory.
Then use the <tt/su daemon/ command to change effective UID to daemon
and run the
<tt/pgp -kg/
(generate key)
command as daemon.
The <tt/daemon/ user should not have a password.
<item>
Each PGP key has an associated identifier.
It is recommended that the <tt/lpd/ key be <tt/lpr@hostname/,
where hostname is the fully qualified domain name of the server.
A public and a private key file will be created.
<item>
Next,
place the passphrase for the <tt/daemon/
user in
<tt>~daemon/.pgp/serverkey</tt>,
and make sure it has owner <tt/daemon/
and <tt/600/ permissions (read/write only by <tt/daemon/).
This is extremely important.
If other users can read this file then security will be severely compromised.
<item>
Next, distribute the <tt/lpr@hostname/ public key to all users of the
LPRng server.
This is usually done by placing the public key in a well known file location
or making it available to users by some form of Public Key Distribution system
(PKD).
The key can be extracted and put into a text file using the following commands:
<tscreen>
<verb>
pgp -kxa userid destfile keyfile

Example:
> pgp -kxa lpr@astart /tmp/lprkey ~daemon/.pgp/pubring.pgp
Key for user ID: lpr@astart
512-bit key, key ID BB261B89, created 1999/01/01

Transport armor file: /tmp/lprkey.asc
Key extracted to file '/tmp/lprkey.asc'.
</verb>
</tscreen>
<item>
To allow a user to send files to the server,
their public key must be put into the <tt/daemon/ public key ring.
This can be done using:
<tscreen>
<verb>
pgp -ka /tmp/lprkey.asc
</verb>
</tscreen>
<item>
Finally,  the administrator will need to add users public keys to the
<tt/daemon/ users public key ring.  This can most easily be done by
copying all the keys (in ASCII text form) to a single file
(<tt>/tmp/keyfile</tt>)and using:
<tscreen>
<verb>
su daemon
pgp -ka /tmp/keyfile ~daemon/.pgp/pubring.pgp
</verb>
</tscreen>
<item>
If the <tt/lpd/ server is using PGP to forward jobs or requests,
the destination server's public key must be put in the originating
servers public keyring.  For example:
<tscreen>
<verb>
su daemon
pgp -ka /tmp/lpd.keyfile ~daemon/.pgp/pubring.pgp
</verb>
</tscreen>
</itemize>
<sect2>Printcap Configuration
<label id="pgppath">
<label id="pgppassphrase">
<label id="pgpserverkey">
<p>
Options used:
<itemize>
<item><tt>pgp_path=</tt><em>path to PGP program</em>
<item><tt>pgp_id=</tt><em>destination server key used by clients</em>
<item><tt>pgp_forward_id=</tt><em>destination server used by server</em>
<item><tt>pgp_server_key=</tt><em>path to server passphrase file</em>
</itemize>
<p>
Example printcap entry:
<tscreen>
<verb>
pr:
    :lp=pr@wayoff
    :auth=pgp
    :pgp_id=lpr@wayoff.com
    :pgp_path=/usr/local/bin/pgp
pr:server
    :lp=pr@faroff
    :auth_forward=pgp
    :pgp_id=lpr@wayoff.com
    :pgp_path=/usr/bin/pgp
    :pgp_forward_id=lpr@faroff.com
</verb>
</tscreen>
<p>
The <tt/pgp_path/ value is the path to the PGP program.
The progam must be executable by all users.
<p>
The <tt/pgp_id/ value is the id used by PGP to look extract keys from
key rings.
When doing a client to server transfer this will be supplied as the id
to be used for the destination,
and the user's public keyring will be checked for a key corresponding to
this id.
When a request arrives at the server,
the server will use this value as the id of a key in its private key ring.
Finally,
when a server is forwarding a request to a remote server,
it will use this value
as the id of the key in its private key ring to be used to sign
or encode the destination information.
<p>
The <tt/pgp_forward_id/ value is used by the <tt/lpd/ server as the id
to use to find a key for the destination.
<p>
The <tt/pgp_server_key/ is the path to the file containing the server passphrase.
This file will be read by <tt/lpd/ to get the passphrase to unlock the server's
keyring.
<sect2>User Files and Environment Variables
<p>
Options used:
<itemize>
<item><tt>PGPPASSFILE=</tt><em>File to read PGP passphrase from</em>
<item><tt>PGPPASSFD=</tt><em>File descriptor to read PGP passphrase from</em>
<item><tt>PGPPASS=</tt><em>PGP passphrase</em>
</itemize>
<p>
One problem with using PGP is the need to have users input their
passphrases.
The following methods can be used.
<itemize>
<item>
Put the passphrase in a file,
say <tt>$(HOME)/.pgp/.hidden</tt>,
and set the <tt/PGPPASSFILE/ environment variable to the file name.
This file will be opened and read by PGP to get the passphrase.
This file should be owned by the user and have <tt/0600/ or read/write
only by user permissions.
<item>
A more subtle solution is to use the <tt/PGPPASSFD/ environment variable
facility.
This causes PGP to read the passphrase from a file descriptor.
If the user puts his passphrase in a file,  say
<tt>$(HOME)/.pgp/.hidden</tt>,
then the following shell script can be used:
<tscreen>
<verb>
#!/bin/sh
#  /usr/local/bin/pgplpr script - passphrase in $(HOME)/.pgp/.hidden
#
PGPASSFD=3 3<$(HOME)/.pgp/.hidden lpr "$@"
</verb>
</tscreen>
<item>
The least desirable method is to put the passphrase in the
<tt/PGPPASS/ environment variable.
Since the <tt/ps/ command can be used to list the environment variables
of processes,
this is highly undesireable and should not be used under any circumstances.
</itemize>
<sect1>Using Kerberos 5 for Authentication
<p>
LPRng Kerberos 5 authentication is
based on the
Kerberos5-1.1.1 release as of December 28, 1999.  This was obtained
from MIT from the
<tt>
<htmlurl url="http://web.mit.edu/kerberos/www/"
name="http://web.mit.edu/kerberos/www/" >
</tt>
Website.
<p>
The following sections briefly describes
how to set up and test the Kerberos software
and then how to configure LPRng to use Kerberos.
<sect2>LPRng Configuration
<p>
By default,
LPRng will search for the <tt/krb5.h/ file and the <tt/krb5/ libraries.
If it finds these,
then Kerberos authentication will be included.
If it also finds the <tt/krb.h/ file then MIT Kerberos 4 compatibility will
also be enabled.

<sect2>Kerberos Installation Procedure
<label id="kerberoskeytab">
<label id="kerberoslife">
<label id="kerberosrenew">
<label id="kerberosservice">
<label id="kerberosserverprincipal">
<label id="kerberosforwardprincipal">
<p>
<enum>
<item> Get the Kerberos 5 distribution.
<item> Compile and install the distribution.
<item> Create the
<tt>/etc/krb5.conf</tt> and
<tt>/usr/local/var/krb5kdc/kdc.conf</tt>,
files using templates from the files in the
Kerberos distribution's
<tt>src/config-files</tt> directory.
See the Installation notes and the System Administrators Guide for
details.
<item> Start up the KDC and KADMIN servers - you might want to put
the following in your
<tt/rc.local/
or equivalent system startup files:
<tscreen>
<verb>
if [ -f /etc/krb5.conf -a -f /usr/local/var/krb5kdc/kdc.conf  ]; then
    echo -n ' krb5kdc ';    /usr/local/sbin/krb5kdc;
    echo -n ' kadmind ';    /usr/local/sbin/kadmind;
fi
</verb>
</tscreen>
<item> Use kadmin (or kadmin.local) to create principals for your users.
<item> Use kadmin (or kadmin.local) to create principals for the
<tt/lpd/ servers.  I have been using
<tt>lpr/hostname.REALM</tt>
as a template-
i.e.
<tt>lpr/astart1.astart.com@ASTART.COM</tt>
for an example.
You should use fully qualified domain names for the principals.
Since it will never be used by an individual,
you do not have to give it a password.
<tscreen>
<verb>
Example:

kadmin ...
addprinc -randkey lpr/wayoff.astart.com@ASTART.COM

</verb>
</tscreen>
<item> Extract the keytab for each server:
<tscreen>
<verb>
kadmin ...
ktadd -k keytab  lpr/hostname.REALM

Example:
ktadd -k /tmp/lpr.wayoff.astart.com  lpr/wayoff.astart.com@ASTART.COM
</verb>
</tscreen>
<item>
The <tt/keytab/ file contains the keytab information, which is the
equivalent information for the server.
<item> Copy each <tt/keytab/ file  to the
appropriate server (you might want to encrypt
or use a secure transfer for this).
Put it in the <tt>/etc/lpd.keytab</tt> file on the server.
This file should have <tt/0400/ permissions and owned by
<tt/daemon/ or the user that <tt/lpd/ will run as.
<tscreen>
<verb>
#> ls -l /etc/lpd.keytab
-rw-------  1 daemon  wheel  128 Jan 16 11:06 /etc/lpd.keytab
</verb>
</tscreen>
<item>
If you want to have MIT Kerberos4 printing compatibility,
then you will need to set up Kerberos 4 <tt/servertabs/
instead of Kerberos 5 keytabs.
Assuming that you have put the Kerberos 5 keytab in <tt>/etc/lpd.keytab</tt>,
then you extract the Kerberos 4 srvtab version of the Kerberos 5 keytab using
the following commands.
You must put the key in the <tt>/etc/srvtab</tt> file
in order to be compatible with the Kerberos 4 support.
<tscreen>
<verb>
%&gt; su
#&gt; ktuil
rkt /etc/lpd.keytab
wst /etc/srvtab
</verb>
</tscreen>
</enum>
<sect2>LPRng Configuration
<p>
The LPRng  software needs to be configured so that it can find the
Kerberos libraries and include files.
By default,
the include files are installed in
<tt>/usr/local/include</tt>
and the libraries in
<tt>/usr/local/lib</tt>.
Use the following steps to configure LPRng so that it uses these
directories during configuration and installation:
<tscreen>
<verb>
cd .../LPRng
rm -f config.cache
CPPFLAGS="-I/usr/local/include -I/usr/include/kerberosIV" \
  LDFLAGS="-L/usr/local/lib -L/usr/lib/kerberosIV" \
  ./configure
make clean all
su
make install
</verb>
</tscreen>
<sect2>Printcap Entries
<p>
Options used:
<itemize>
<item><tt>auth=kerberos5=</tt><em>use Kerberos5 authentication</em>
<item><tt>kerberos_id=</tt><em>destination server key used by clients</em>
<item><tt>kerberos_server_principal=</tt><em>alias for kerberos_id</em>
<item><tt>kerberos_forward_id=</tt><em>destination server used by server</em>
<item><tt>kerberos_forward_principal=</tt><em>alias for kerberos_forward_id</em>
<item><tt>kerberos_keytab=</tt><em>location of the lpd server keytab file</em>
<item><tt>kerberos_service=</tt><em>service to be used</em>
<item><tt>kerberos_life=</tt><em>lpd server ticket lifetime</em>
<item><tt>kerberos_renew=</tt><em>lpd server ticket renew</em>
</itemize>
<p>
Example printcap entry:
<tscreen>
<verb>
pr:
    :lp=pr@wayoff
    :auth=kerberos5
    :kerberos_id=lpr/wayoff.astart.com@ASTART.COM
pr:server
    :lp=pr@faroff.private
    :auth_forward=kerberos5
    :kerberos_id=lpr@wayoff.astart.com@ASTART.COM
    :kerberos_forward_id=lpr/faroff.astart.com@ASTART.COM

OR If you want to use Kerberos 4 authentication to the server
pr:
    :lp=pr@wayoff
    :auth=kerberos4
    :kerberos_id=lpr/wayoff.astart.com@ASTART.COM
# support both Kerberos 4 and 5 on server
pr:server
    :lp=pr@faroff.private
    :auth_forward=kerberos5
    :kerberos_id=lpr@wayoff.astart.com@ASTART.COM
    :kerberos_forward_id=lpr/faroff.astart.com@ASTART.COM
    :kerberos_keytab=/etc/lpd.keytab

</verb>
</tscreen>
<p>
The printcap configuration for Kerberos authentication is very simple.
<p>
The <tt/kerberos_id/ is the principal name of the lpd server
that clients will connect to.
For backwards compatibility,
<tt/kerberos_server_principal/ can also be used.
This values is used to obtain a ticket for the <tt/lpd/ server,
and is the only entry required for client to server authentication.
<p>
The other entries are used by the <tt/lpd/ server.
<tt/kerberos_keytab/
entry is the location of the keytab file to be used by the server.
This contains the passphrase used by the server to authenticate itself
and get a ticket from the ticket server.
<p>
The <tt/kerberos_id/ value is also used by the server during the
authentication process to make sure that the correct principal name
was used by the request originator.
This check has saved many hours of pain in trying to determine why
authentication is failing.
<p>
The
<tt/kerberos_life/ and <tt/kerberos_renew/
set the lifetime and renewability
of the lpd server Kerberos tickets.
These values should not be modified unless you are familiar with the
Kerberos system.
There are extensive notes in the LPRng source code concerning these values.
The <tt/kerberos_service/ value supplies the name of the service
to be used when generating a ticket.
It is stronly recommended that the <tt/kerberos_id/ entry
be used instead.
<sect2>User Environment Variables and Files
<p>
In order to use kerberos authentication,
the user will need to obtain a ticket from the Kerberos ticket server.
This is done using <tt/kinit/.
<p>
No other actions are required by the user.
<sect1>Using Kerberos 4 for Authentication
<p>
LPRng has built-in support for the Project Athena extensions to the
RFC1179 protocol.
These provide an extremely simple authentication protocol
using an initial credential exchange.
After the initial exchange the usual RFC1179 protocol is used.
<p>
During configuration,
if the <tt/krb.h/ (Kerberos 4) include file is found,
then this is enabled by default.
<sect2>Printcap Entries
<p>
Options used:
<itemize>
<item><tt>auth=kerberos4</tt><em>use Kerberos4 authentication</em>
<item><tt>kerberos_id=</tt><em>destination server key used by clients</em>
<item><tt>kerberos_server_principal=</tt><em>alias for kerberos_id</em>
</itemize>
<p>
Example printcap entry:
<tscreen>
<verb>
pr:
    :lp=pr@wayoff
    :auth=kerberos4
    :kerberos_id=lpr/wayoff.astart.com@ASTART.COM
</verb>
</tscreen>
<p>
The configuration information for Kerberos4 and Kerberos5 is identical
and differ only in the authentication type.
Note that only client to server authentication is supported.
<sect1>Using MD5 for Authentication
<p>
LPRng has built-in support for using MD5 digests as an
authentication method.
The implementation is provided as an example of how to
add user level authentication into the LPRng system.
<p>
The method used to do authentication is very simple.
Each user has a file containing a set of keys that are used to salt an
md5 hash.
The information being transferred has its md5 checksum calculated using
this salt,
and is then transferred to the destination,
along with the md5 hash result.
At the destination the server will get the user id,
obtain the salt value from a key file,
and then calculate the md5 hash value.
If the two are in agreement,
authentication is successful.
<p>
The keyfile used for md5 authentication contains an id followed by
a text string whose binary value is used as a hash key:
<tscreen>
<verb>
id1=key
id2=key

Example:

lpr@h2=tadf79asd%^1asdf
lpr@h1=fdfa%$^&^%$

</verb>
</tscreen>
<p>
<sect2>Printcap Entries
<p>
Options used:
<itemize>
<item><tt>auth=md5</tt><em>use MD5 authentication</em>
<item><tt>auth_forward=md5</tt><em>forward using MD5 authentication</em>
<item><tt>md5_id=</tt><em>id for server</em>
<item><tt>md5_forward_id=</tt><em>id for server</em>
<item><tt>md5_server_keyfile=</tt><em>server keyfile</em>
</itemize>
<p>
Example printcap entry:
<tscreen>
<verb>
pr:
    :lp=pr@wayoff
    :auth=md5
    :md5_id=lpr@wayoff.com
pr:server
    :auth_forward=md5
    :md5_id=lpr@wayoff.com
    :md5_server_keyfile
    :md5_forward_id=lpr@faroff.com
</verb>
</tscreen>
<p>
The <tt/md5_id/ value is used by the client to obtain
a hash key that is used to salt the md5 calculation for client to server
transfers.
The <tt/md5_forward_id/ value is used by the server to obtain
a hash key that is used to salt the md5 calculation for server to server transfers.
<p>
The <tt/md5_server_keyfile/ contains the keys of users;
the id sent as the connection information is used to obtain the key from the file.
<p>
To set up md5 authentication,
all that is needed is the following.
<itemize>
<item>
For each user generate a key and place it in the server keyfile.
This file should have the form:
<tscreen>
<verb>
user1@host1=asdfasdfadf
user2@host2=a8789087asddasdf
</verb>
</tscreen>
<item>
Assign a key to the server, and set its printcap entry to this key.
<tscreen>
<verb>
pr:
    :lp=pr@wayoff
    :auth=md5
    :md5_id=lpr@wayoff.com
</verb>
</tscreen>
<item>
For each user, create a user key file with the following format:
<tscreen>
<verb>
lpr@wayoff = user1@host1 asdfasdfadf
</verb>
</tscreen>
The first entry corresponds to the <tt/md5_id/ value in the printcap.
The second field is the <tt/AUTHUSER/ value supplied to the server
and which will be used to look up the key in the servers key file.
Finally,
the last field is the salt value for the md5 calculation.
</itemize>
<sect2>User Environment Variables and Files
<p>
Options used:
<itemize>
<item><tt>MD5KEYFILE=5</tt><em>location of user keyfile</em>
</itemize>
<p>
The <tt/MD5KEYFILE/ environment variable contains the path to the
user keytab file.
<sect1>Adding Authentication Support
<p>
Additional types of authentication support can be added very easily to
LPRng by using the following conventions and guidelines.
<p>
First,
the authentication method can be connection based or transfer based.
Connection based authentication involves the LPRng client or server
opening a connection to the remote server,
having the authentication protocol provide authentication information,
and then having no further interaction with the system.
This is the easiest to implement and understand method.
Code needs to be provided to do a simple authentication exchange
between the two ends of the connection,
after which no other action needs to be taken.
<p>
Transfer based authentication is more complex,
but allows encrypted transfers of information between the two systems.
A connection is established between client and server (or server and server),
and an initial protocol exchange is performed.
Then the authentication module transfers the command or job information
to the destination,
where is it unpacked and/or decrypted.
The internal LPD server facilities are then invoked by the authentication
module,
which also provides a destination for any error message or information
destined for the client.
The authentication module will encrpt or encode this information and then
send it to the client program.
This type of authentication is more complex,
but provides a higher degree of security and reliability than the
simple connection based system.
<sect2>Printcap Support
<p>
By convention,
printcap entries
<tt/auth=XXX/
and
<tt/auth_forward=XXX/
specifies that authentication protocol <tt/XXX/
is to be used for client to server
and for server to server transfers respectively.
<p>
Similarly,
the server receiving an authentication request must have a
<tt/XXX_id=name/ entry in the printcap or configuration information.
This allows several different authentication protocols to be accepted
by a server.
<p>
By convention,
printcap and configuration entries of the form
<tt/XXX_key/
contain configuration information for the <tt/XXX/ authentication protocol.
As part of the authentication support process the <tt/XXX_key/ values
are extracted from the printcap and configuration files
and placed in a simple database for the authentication support module.
<p>
If you are using a routing filter,
then you can also place
<tt/XXX_key/
information in the routing entry for each file,
and this will be used for sending the job to the specified destination.
<sect2>Code Support
<p>
The <tt>LPRng/src/common/sendauth.c</tt>
file has the following entries at the end.
<tscreen>
<verb>
#define SENDING
#include "user_auth.stub"

struct security SendSecuritySupported[] = &lcub;
  /* name,       config_tag, connect,    send,   receive */
  &lcub; "kerberos4", "kerberos", Send_krb4_auth, 0, 0 &rcub;,
  &lcub; "kerberos*", "kerberos", 0,           Krb5_send &rcub;,
  &lcub; "pgp",       "pgp",      0,           Pgp_send &rcub;,
#if defined(USER_SEND)
 USER_SEND
#endif
  &lcub;0&rcub;
&rcub;;
</verb>
</tscreen>
This is an example of how to add user level authentication support.
The <tt/user_auth.stub/
file contains the source code for the various modules authentication
modules.
You can replace this file with your own version
if desired.
The following fields are used.
<descrip>
<tag> name </tag>
The authentication name.
The <tt/auth=XXX/ printcap or configuration value will cause the
<tt/name/ fields to be searched using a
glob match.
<tag> config_tag</tag>
When a match is found,
the <tt/config_tag/ value is used to search
the printcap and configuration entries for information.
If the <tt/config_tag/ field has value <tt/XXX/,
then entries with keys <tt/XXX_key/ will be extracted for use
by the authentication code.
<tag>connect</tag>
Routine to call to support <tt>connection</tt>
level authentication.
This routine is responsible for connection establishment and
protocol handshake.
If the value is 0,
then the <tt/send/ field value will be used.
<tag>send</tag>
Routine to call to support <tt>transfer</tt>
level authentication.
The <tt/send/
routine is provided a file and a connection to the remote server,
and is responsible for the transferring files.
</descrip>
<p>
The
<tt>LPRng/src/common/lpd_secure.c</tt>
file has the following information at the end:
<tscreen>
<verb>
#define RECEIVE 1
#include "user_auth.stub"

 struct security ReceiveSecuritySupported[] = &lcub;
    /* name, config_tag, connect, send, receive */
#if defined(HAVE_KRB_H) && defined(MIT_KERBEROS4)
    &lcub; "kerberos4", "kerberos",  0, 0, 0 &rcub;,
#endif
#if defined(HAVE_KRB5_H)
    &lcub; "kerberos*", "kerberos",   0, 0, Krb5_receive &rcub;,
#endif
    &lcub; "pgp",       "pgp",   0, 0, Pgp_receive, &rcub;,
#if defined(USER_RECEIVE)
/* this should have the form of the entries above */
 USER_RECEIVE
#endif
    &lcub;0&rcub;
&rcub;;
</verb>
</tscreen>
<p>
This information matches the same information in the <tt/sendauth.c/
file.
When the authentication request arrives at the server,
the <tt/name/ field values are searched for a match,
and then the <tt/config_tag/ value is used to get extract configuration
information from the database for the protocol.
<p>
The <tt/receive/
routine is then called and is expected to handle the remaining
steps of the authentication protocol.
If the routine exits with a 0 value then the lpd server expects
<tt/connection/ level authentication has been done and proceeds to
simply transfer information using the standard RFC1179 protocol steps.
A non-zero return value indicates an error and an error is reported
to the other end of the connection.
<p>If the <tt/receive/ module is to perform <tt/transfer/ level authentication,
then the module carries out the necessary steps to transfer the command and/or
job information.
It then calls the necessary internal LPRng routine to implement the desired
services.
After finishing the requested work,
these routines return to the calling authentication module,
which then will transfer data, close the connection to the
remote system,
and return to the calling system.
The combination of 0 return value and closed connection
indicates successful transfer level authentication to the server.
<p>
The <tt/user_auth.stub/ file contains the following code that sets the
<tt/USER_SEND/ variable:
<tscreen>
<verb>
#if defined(SENDING)
extern int md5_send();
#  define USER_SEND \
  &lcub; "md5", "md5", md5_send, 0, md5_receive &rcub;,
#endif
</verb>
</tscreen>
<p>
If the <tt/SENDING/ value has been defined,
this causes the prototype for <tt/md5_send()/ to be place in the file
and the <tt/USER_SEND/ value to be defined.
This will cause the <tt/md5/ authentication information to be placed in the
correct table.
<sect2>Connection and Transfer Authentication
<p>
Rather than go into a detailed description of the code,
the <tt/user_auth.stub/ file contains extremely detailed examples
as well as several working versions of authentication information.
It is recommended that the user start with one of these and then
modify it to suit themselves.
<sect>Accounting
<label id="accountingref">
<p>
The LPRng method for doing accounting is based on experiences in a
Academic environment,  where avoiding printing accounting procedures
has long been practiced.  While the LPRng procedures are not bombproof,
they do provide a wide range of facilities,  with various degrees
of trust built into them.
<sect1>Printer Accounting Reality Check
<p>
The following was written
by Patrick Powell
<tt>&lt;papowell@astart.com></tt>
in response to the expressions of frustration
that are periodically vented in the
<tt>
<ref id="maillist" name="lprng@lprng.org">
</tt>
mailing list.
While this addresses the use of a particular set of printer filters,
i.e. - the
<ref id="ifhp" name="ifhp">
set,
the comments are appropriate to other issues.
<p>
In Academic institutions, avoiding printing accounting has been
regarded as a challenge,  an ongoing game of fat cat and poor starving
mouse, between the Administration and the downtrodden, poor, over charged
student.  The following is a lighthearted ramble down the dark lane of
printing accounting.
<p>
We will disregard the fact that if most students put as much effort
into their studies as in finding ways to avoid accounting procedures
then they would be Rhodes Scholar material,  but I digress...
<p>
The accounting procedures put into the LPRng and the hpif filters may
appear to be extraordinarily complex,  but believe me, they are not.
Firstly, we make the assumption that the printer has some sort of
non-volatile page counter mechanism that is reliable and impervious to
power on/off cycles.  Without this mechanism the enterprising student
ummm... user will simply turn off the printer.  Software that prescans
jobs for line counts and pages is notoriously unreliable,  given even
the most modest efforts of users to hide these procedures.   The cost
of running a PostScript simulator simply to do accounting has its
flaws; without ensuring that the simulator has all of the interesting
security loopholes closed, such as opening files, etc.,  it can become
a trap door to hell for the system administrator.
<p>
Secondly,  we must make the assumption that the student... uhhh...
user will not be able to tinker with the page counter mechanism, i.e.-
they will not be able to roll back the odometer on the printer, FOR THE
DURATION OF A SINGLE JOB.  I will digress and point out that a student
actually did this for a challenge;  it only took him a couple of weeks
of study and a fully equipped microcontroller lab, and two (2) laser
printers which he ruined in the experiment.  HP was not amused when we
sent them back under warranty,  claiming that this our 'normal lab usage.'
<p>
Lastly,  you should not mind a small amount of pilferage, or a few
pages here and there being charged to the wrong account.
<p>
<bf>How Does It Work?</bf>
<p>
The <tt/ifhp/ filter records the page
counter value at the start and end of each part of a print job. Each
record has the form:
<tscreen>
<verb>
start -ppagecounter -Ff -kjob -uuser -hhost -R...
end  -ppages -qpagecounter -Ff -kjob -uuser -hhost -R...
</verb>
</tscreen>
<p>
When we use the OF filter and/or banners,  we will see the
individual jobs bracketed by the OF filter records:
<tscreen>
<verb>
start -p100 -Fo -kcfA100taco -uuser -hhost -R...
start -p101 -Ff -kcfA100taco -uuser -hhost -R...
end  -p1 -q102 -Ff -kcfA100taco -uuser -hhost -R...
start -p102 -Ff -kcfA100taco -uuser -hhost -R...
end  -p3 -q105 -Ff -kcfA100taco -uuser -hhost -R...
end  -p5 -q105 -Fo -kcfA100taco -uuser -hhost -R...
</verb>
</tscreen>
<p>
It should be clear from the above that all we need to do is to add up
the values for the -Fo (OF) filter lines and we are done.
<p>
Unfortunately,  this is too simplistic.  If for some reason the job is
killed or terminates due to error conditions,  the OF filter may not
get to finish its work.  Thus,  we may see the following:
<tscreen>
<verb>
start -p100 -Fo -kcfA100taco -uuser -hhost -R...
start -p101 -Ff -kcfA100taco -uuser -hhost -R...
start -p110 -Fo -kcfA101taco -uuser -hhost -R...
</verb>
</tscreen>
<p>
This is a clear indication that the user's job has been terminated.  In
this case we need to use the differences between pagecounters of the start
records to do accounting.
<p>
There is a caveat to all of this;  that is the problem of the last dead
job in the list.  If the last line in the accounting file is:
<tscreen>
<verb>
start -p110 -Fo -kcfA101taco -uuser -hhost -R...
</verb>
</tscreen>
is the last job finished or did it abort?
<p>
<bf>Who Used Up 2000 Pages of Paper Today?</bf>
<p>
Now we move on to the problem of real time accounting.  Due to limited
budgets, etc., many institutions would like to strictly enforce limits
on paper use by students. As jobs are printed their accounts should be
docked for the amount of paper use.  One way to do this is to have an
external accounting procedure update a shared database.  The <tt/ifhp/ filter
has provision for a shell script to be called at the end of print job;
this is done by both the OF and IF filter.  Thus, we can blithely
assume that there is a central database carefully getting updates
from the LPRng software, probably from dozens of different printers,
and updating the accounting information.
<p>
The first question to be asked is simple:  is this worth it?
Perhaps doing accounting as a batch job once an hour/four times
a day/once a day is cheaper than building an running such a database.
If it costs $5K/year for the database software, you might just consider
ignoring the 10,000 pages that get lost in the shuffle and use
a simple set of awk/sed/perl scripts to update a database once
an hour.
<p>
<bf>BAD JOBS - Who Do We Bill?</bf>
<p>
We inevitably run into an interesting question:
what happens if a job does not complete correctly?
<p>
If you use the completion of the OF filter as a success status, I have
to point out that many students... ummm... users soon find ways to send
jobs to the printer that will cause it to lock up after their output
has been printed. These jobs require power cycling of the printer and
restarting the filter; a bit extreme, perhaps, but it has happened.
<p>
I suggest that you simply adopt a 'bill to last user of record'
attitude,  using the pagecount information as follows:
<tscreen>
<verb>
start OF -- starting point for THIS job
start IF --  nice information, but not useful
start IF --
end   OF -- ending point for this job - can record information
start OF --
if no end OF for previous job,  then treat as end OF and
  update accounting.
</verb>
</tscreen>
<p>
Now somebody is sure to complain that they got charged for a bunch of
pages that they did not use.  This is inevitable;  always carry a
can of oil for the squeaky wheels.  I might make the observation that
once is accident, twice is coincidence, but three times is malice;
be wary of the constant complainer and check out not only him or her but
also their co-workers.
<p>
<bf>How Do We Update the Database?</bf>
<p>
I suggest that database update be done as follows:
<p>
You maintain a 'last page reported' counter for each printer in the
database.  When a successful job reports in,  check to see that
<newline>
pagecount + joblength ==  newpagecount;
<p>
If this is not the case,  then you have had a some unsuccessful jobs.
In this case I strongly recommend that you have a means to request the
accounting reporting program to go back through the accounting file and
find the last report for the page counter value and try to backtrack
through the accounting files.  The accounting file is one of the first
things to be attacked by students... Ummm...  users.  It should NOT be
kept on an NFS exported or mounted file system.  It should be
carefully pruned and copied, perhaps on an hourly basis.
<p>
Now some administrators have fallen in love with network based printers;
do not believe ANYTHING that comes over a network connection without
some form of authentication;  PGP has some very nice Public Key
mechanisms for handling this.  This is a major weakness in using a
database for keeping track of accounting - a weak authentication
mechanism may lead to denial of service attacks by students flooding
the database with bogus print usage reports;  suddenly NOBODY can print
and the administrator is driven to turning off accounting.
<p>
Good luck.  I am never surprised when I encounter yet another wrinkle in
this area.
<p>
Patrick ("You call me a Bean Counter?  Guido,  break this kid's fingers
<newline>
&nbsp; &nbsp; &nbsp; &nbsp; with an adding machine!") Powell
<sect1>How HP Printers Implement Page Counters
<p>
The following is from
<htmlurl
url="http://www.hp.com/cposupport/printers/support_doc/bpl02119.html"
name="http://www.hp.com/cposupport/printers/support_doc/bpl02119.html" >
<p>
<bf>HP LaserJet Printer Family - Page Count</bf>
<p>
Description Of The Page Count Feature On HP LaserJet 4 Family
Printers
<p>
All HP LaserJet 4/5/6 family printers have a page count feature
built into the firmware. However, this feature works differently
depending on which HP LaserJet printer is being used. The following
is a description of how the page count feature works for each
printer within the HP LaserJet 4/5/6 printer families.
<tscreen>
<verb>
HP LaserJet 4/4M printers
HP LaserJet 4 Plus/4M Plus printers
HP LaserJet 4P/4MP printers
HP LaserJet 4Si/4Si MX printers
HP LaserJet 4ML printers
HP LaserJet 5P/5MP printers
HP LaserJet 6P/6MP printers
</verb>
</tscreen>
<p>
All of the above printers use the same method for keeping track of
the number of copies. There are really two different page count
values: Primary and Secondary values. Every time a page is printed,
whether it is an internal job (such as a self-test) or a standard
print job, the Secondary page count increases by one. This value
is stored in standard RAM. Once the Secondary page count value
reaches 10, the Primary page count will increase by 10. The Primary
page count value is stored in a type of memory called NVRAM
(Non-Volatile RAM). This is important, since NVRAM is not cleared
when the printer is powered off. Standard RAM, on the other hand,
is cleared when the printer is turned off or reset. Thus, the
Primary page count only increases in increments of 10.
<p>
Example
<p>
You have a brand new HP LaserJet 6P printer and you print a self-test
page. When you look on the test page for the Page Count value, you
will see that it says 1. Next, you decide to print a two page letter
and, after that, another self-test. The page count value now says
4. Internally, the printers Secondary page count (stored in RAM)
has the value of 4 while the Primary page count (stored in NVRAM)
still has the value of 0. Now, you turn the printer off, then back
on, and print another self-test. The page count value again says
1 since the previous value of 4, stored in RAM, was cleared when
the printer was powered off. Finally, print a ten page document
and then turn the printer off. Upon turning the printer back on
and printing out another self test, you see that the page count
value is 11.  Internally, the Secondary page count value is back
at 1 while the Primary page count value (stored in NVRAM) is 10.
Added together, you end up with the resulting value seen on the
self-test page.
<p>
HP LaserJet 4L/5L/6L Printers
<p>
The reason that the page count method for the HP LaserJet 4L/5L/6L
printers differ from that of the other printers is that the HP
LaserJet 4L/5L/6L printers do not have any NVRAM available. Thus,
no way exists for the printer to retain a page count value once
the printer is powered off. The HP LaserJet 4L/5L/6L printers have
only a single page count value that increases in increments of one
until the printer is powered off. At that point, the page count
value is reset and begins from 0 once again.
<p>
<sect1>Accounting Printcap Options
<label id="accountingserver">
<p>
The accounting facilities are controlled and enabled by the following
entries in the printcap file.  The default value is indicated.
<p>
<table>
<tabular ca="|l|l|l|">
Tag
|
Default Value
|
Purpose
@
af
|
NULL
|
accounting file name
@
as
|
"jobstart $H $n $P $k $b $t"
|
accounting info for job start
@
ae
|
"jobend $H $n $P $k $b $t"
|
accounting info for job end
@
accounting&lowbar;server
|
NULL
@
achk
|
FALSE
@
la
|
TRUE
|
do accounting for 'local' printer
@
ar
|
FALSE
|
do accounting for 'remote' transfers
@
</tabular>
</table>
<p>
<sect1>Accounting File
<p>
The most common method of accounting is to record the start and end
times of a job and its size to the accounting file. A typical entry
for the printcap defaults are shown below.
<tscreen>
<verb>
jobstart '-Htaco.astart.com' '-nroot' '-Pps' '-kcfA938taco.astart.com' \
'-b1093' '-tNov  5 19:39:59'
start '-p12942' '-kcfA938taco.astart.com' '-nroot' '-htaco.astart.com' '-Pps' \
'-c0' '-Fo' '-tSun Nov  5 19:39:25 1995'
start '-p12944' '-kcfA938taco.astart.com' '-nroot' '-htaco.astart.com' '-Pps' \
'-c0' '-Ff' '-tSun Nov  5 19:39:27 1995'
end '-p12944' '-kcfA938taco.astart.com' '-nroot' '-htaco.astart.com' '-Pps' \
'-b3' '-c0' '-Ff' '-tSun Nov  5 19:39:58 1995'
end '-p12942' '-kcfA938taco.astart.com' '-nroot' '-htaco.astart.com' '-Pps' \
'-b2' '-c0' '-Fo' '-tSun Nov  5 19:39:59 1995'
jobend '-Htaco.astart.com' '-nroot' '-Pps' '-kcfA938taco.astart.com' \
'-b1093' '-tNov  5 19:39:59'
</verb>
</tscreen>
<p>
The <tt>jobstart</tt> and <tt>jobend</tt> lines are added by the LPD server,  as
specified by the <tt>as</tt> and <tt>ae</tt> printcap options;
the -b (byte count) indicates the numbers of bytes in the job.
<p>
The <tt>start</tt> and <tt>end</tt>
lines are produced by the filters;
the of filter has an -Fo, and the if filter a -Ff entry.
The filters in the LPRng distribution produce the
indicated output format by default.
The -p value is the current value of a page counter device (if any),
and the -b value indicates the total number of pages used.
<p>
It should be clear that a simple AWK or Perl script will be able to
process an accounting file and update accounting information for
accounting purposes;  the usual problems with truncation, time stamps,
etc., are left as an exercise for the system administrator.
However,
for those who are exercise challenged,
the LPRng distribution
<tt>.../LPRng/UTILS/accounting.pl</tt>
file is a template that can be used to process the accounting information.
The printcap for using this file should resemble:
<tscreen>
<verb>
pr:
  :as=|/.../accounting.pl START
  :ae=|/.../accounting.pl END
  :if=/.../ifhp
  :of=/.../ofhp
  # set this to the printing device
  :lp=prdevice
  :sd=/.../%P
</verb>
</tscreen>
<p>
Note that the accounting file must exist and will not be created by the
<tt/lpd/ server.
The accounting file should be periodically truncated.
<sect1>Accounting Using an Accounting Server
<p>
To accommodate even more aggressive and centralized accounting,
a method to make a connection to a print server and send information
to the server has been provided as well.
If <tt>achk</tt> option is set,
it is assumed that the <tt>af</tt> entry specifies a connection to
server on a remote host.
The <tt>lpd</tt> server will send the <tt>as</tt> string to the server,
and then wait for a single line of text from the remote server.
If the first word on the return line is
<tt>accept</tt> or <tt>hold</tt>,
the job will be either accepted for printing or held.
Any other value will cause the job to be deleted.
<p>
At the end of the job the <tt>ae</tt> string will be sent to the server.
No response is expected.  Example:
<p>
<tscreen>
<verb>
:af=accounting.site.com%2300,tcp
:achk
:as=starting
:ae=ending
</verb>
</tscreen>
<p>
The port that the connection originates from will be in the range
set by the configuration or printcap
<tt>
<ref id="originateport" name="originate_port">
</tt>
option.
<sect1>Using Filters For Accounting
<p>
Some sites have expressed interest in using a central accounting
mechanism to check that users have permissions.  This can be done by
using the an alternative form of the as (accounting start) and ae
(accounting end) printcap tags.  If the as and ae are filter
specifications,  then a filter is invoked.  If the as (accounting
start) filter returns a non-zero exit status,  then its value
is used to handle the job as indicated by
the
<ref id="termination" name="Abnormal Termination">
codes for filters.
At the end of the job the :ae: filter will be invoked in a similar manner,
but its exit status is ignored.
<p>
When using an accounting filter,
the STDIN is attached to <tt>/dev/null</tt>,
STDOUT to an output file,
and STDERR to a pipe or socket that is read by the <tt/lpd/
server.
The program is invoked with the default filter options.
<p>
For example, here is a sample entry to check and update accounting
<tscreen>
<verb>
printer:
 :af=acct
 :as=|/usr/local/libexec/filters/accounting.pl start
 :ae=|/usr/local/libexec/filters/accounting.pl end
</verb>
</tscreen>
<sect1>Accounting Utility accounting.pl
<p>
In order to provide a framework for doing using the outlined accounting
methods,  the LPRng distribution
<tt>UTILS</tt> directory has a <tt>accounting.pl</tt> script.
This script does the following.
<enum>
<item>
It is assumed that the accounting filter is invoked with the
following printcap entry.
The start and end is used by the filter to determine at which point in
the accounting process it is invoked.
<tscreen>
<verb>
printer
 :af=acct
 :as=|/usr/local/libexec/filters/accounting.pl start
 :ae=|/usr/local/libexec/filters/accounting.pl end
</verb>
</tscreen>
</item>
<item>
It maintains the accounting file as a set of entries in the following format:
<tscreen>
<verb>
START [job identification]
start -pnn ...
...
end -pnn+pagecount ...
END -ppagecount [job identification]
</verb>
</tscreen>
</item>
<item>
Each time the filter is invoked with the <tt>start</tt>
tags,
it will add a <tt>START</tt> record to the end of the accounting file.
</item>
<item>
When it is invoked with the <tt>end</tt> option,
it will update the accounting file and add an <tt>END</tt> entry.
</item>
<item>
It will handle aborted jobs by looking for jobs with have a <tt>START</tt>
entry and a following <tt>start</tt> line and assuming that they
progressed to the point of starting print operations,
i.e. - the printer page counter was accessed and reported.
It will then look for the next <tt>START</tt> entry with a
following <tt>start</tt> line,
and assume that the pages between the two points were used by the
aborted job.
</item>
</enum>
<p>
Administrators can use this script as a starting point for more advanced
accounting.
For example,
rather than just recording the information,
at the job start the script can query either a local database
or a remote server to see if the user has permissions to access the printer.
At the end of the job or when an <tt>END</tt> line is written to the
accounting file,
the local database or remote accounting server can be updated.
<sect>Status Monitoring and Logging
<label id="statusref">
<label id="stalledtime">
<p>
Options used:
<itemize>
<item><tt>stalled_time#</tt><em>time after which to report a stalled active job
</em></itemize>
<p>
The most commonly used tool for LPRng status is LPQ.
However,
the LPC command can be used,
and you can also get real time logging of status to a remote host.
<p>
<sect1>LPQ status reporting
<p>
The LPQ status display produced by LPRng has three formats.
<sect1>LPQ Short Format (lpq -s)
<p>
This is one line per spool queue:
<tscreen>
<verb>
% lpq -sa
t1@astart110  (printing disabled) 1 job
t2@astart110  (routed/bounce to t1@astart110.astart.com) 0 jobs
t3@astart110  (forwarding to t3a@astart110.astart.com)
t3a@astart110  (forwarding to t2@astart110.astart.com)
t4@astart110  (subservers t5, t6)  0 jobs
t5@astart110  (serving t4) 0 jobs
t6@astart110  (serving t4) 0 jobs
</verb>
</tscreen>
<p>
Note that the name of the printer/host is first,
followed by optional status information, followed by
the number of jobs.  Only printcap entries with
spool queues have a jobs word in the last position.
The
<tt>-a</tt> option forces status for all queues or the
queues in the <tt>all</tt> printcap entry to be returned.
<p>
The <tt>stalled_time</tt> (default 120 seconds) printcap option can be used to set a
time after which active jobs will be reported as stalled.
<sect1>LPQ Long Format (lpq default, lpq -l, lpq -L)
<p>
This is the default status display.
It is a nicely formatted, extremely verbose format
that is suitable for humble human interpretation. For example:
<tscreen>
<verb>
% lpq -a
Printer: t1@astart110  'Test Printer 1' (printing disabled)
 Queue: 1 printable job
 Server: no server active
 Status: finished operations at 09:44:00
 Rank   Owner/ID                   Class Job  Files               Size Time
1       papowell@astart110+202228663    A 10663 /tmp/hi               3 20:22:29
Printer: t2@astart110  'Test Printer 2' (routed/bounce to t1@astart110.astart.com)
 Queue: no printable jobs in queue
 Status: finished operations at 16:30:08
Printer: t3@astart110  (forwarding to t3a@astart110.astart.com)
Printer: t3a@astart110  (forwarding to t2@astart110.astart.com)
Printer: t4@astart110  (subservers t5, t6)
 Queue: no printable jobs in queue
 Status: finished operations at 09:44:06
Server Printer: t5@astart110  (serving t4)
 Queue: no printable jobs in queue
 Status: finished operations at 09:44:06
Server Printer: t6@astart110  (serving t4)
 Queue: no printable jobs in queue
 Status: finished operations at 09:10:00
</verb>
</tscreen>
<p>
The <tt/lpq -l/ (longer information)
option causes more of the status information to be printed.
You can use increasing numbers of <tt/lpq -l/ options
(<tt/ lpq -ll/ also works) to get more status.
Use <tt/ lpq -L/ for the maximum amount of status information.
<sect1>LPQ Verbose Format (lpq -v)
<p>
This uses an extension to the RFC1179 protocol,
and is supported only by LPRng.
The amount of information displayed is the brutal,
and in effect does a total database dump
of the LPD.
This has been developed in order to provide diagnostic
and status information for databases that need to keep track of
job progress through a spool queue.
<tscreen>
<verb>
% lpq -v
Printer: t1@astart110
 Comment: Test Printer 1
 Printing: no
 Spooling: yes
 Queue: 1 printable job
 Server: no server active
 Status: accounting at end 'papowell@astart110+094352860' at 09:44:00
 Status: printing 'papowell@astart110+094352860', closing device at 09:44:00
 Status: printing 'papowell@astart110+094352860', finished  at 09:44:00
 Status: subserver status 'JSUCC' for 'papowell@astart110+094352860' \
            on attempt 1 at 09:44:00
 Status: finished operations at 09:44:00
 Job: papowell@astart110+202228663 status= 1
 Job: papowell@astart110+202228663 CONTROL=
 - Hastart110.astart.com
 - Ppapowell
 - J/tmp/hi
 - CA
 - Lpapowell
 - Apapowell@astart110+202228663
 - Qt1
 - fdfA010663astart110.astart.com
 - N/tmp/hi
 - UdfA010663astart110.astart.com
 Job: papowell@astart110+202228663 HOLDFILE=
 - active 0
 - done 0
 - hold 0
 - move 0
....
</verb>
</tscreen>
<sect1>lpc status
<p>
The LPC status command is used to show the status of the queues
currently being managed by the LPRng server.
Note that this form of the command is supported only by LPRng,
and is not backwards compatible with BSD LPR implementations.
<tscreen>
<verb>
%lpc status all
 Printer           Printing Spooling Jobs  Server   Slave Redirect Status/Debug
lw4@astart4         enabled  enabled    0    none    none
lw5@astart4         enabled  enabled    0    none    none
</verb>
</tscreen>
<p>
The status display has a heading line and summary of the server status.
<sect1>Remote Logger Operation
<p>
Several sites have wanted a way to provide central logging of job
status and/or information.  In order to do this,  the following functionality
is provided with LPRng.
<sect2>Logger Network Communication
<label id="loggerdestination">
<label id="loggerpathname">
<label id="loggertimeout">
<label id="loggermaxsize">
<p>
Options used:
<itemize>
<item><tt>logger_destination=</tt><em>logger information destination</em>
<item><tt>logger_pathname=</tt><em>pathname of temp file for log information</em>
<item><tt>logger_max_size=</tt><em>max size in K of temp file for log information</em>
<item><tt>logger_timeout=</tt><em>time between connection attempts</em>
</itemize>
<p>
The printcap/configuration variable <tt>logger_destination</tt> specifies
a destination in the standard
<tt/host%port/
notation used by LPRng.
Host is the destination host, and can be a name or IP address.
Port is the port on the destination host.
A TCP/IP connection is made to the indicated port.
<p>
Log information is save in a temporary file specified by
<tt/logger_path/,
and up to
<tt/logger_max_size/  K bytes of data will be saved.
<p>
If a connection cannot be made to the
<tt/logger_destination/,
then every
<tt/logger_timeout/ seconds a new connection attempt will be made.
If <tt/logger_timeout/ is 0,
then a connection attempt will be made every time new data arrives to be logged.
<sect2>Logger Messages
<p>
Log messages consist of a single line
terminated with a newline (<tt>\n</tt>) character.
<p>
Each log message reports a system event or status change of the
LPD server.
When the connection is first established,
a complete dump of the status of the LPD server is sent.
After this,
only status update messages are sent.
The remote monitor can force a status dump by simply closing and
reopening the connection.
<sect2>Message Format
<p>
Each message is encoded as a URI escaped string.
That is, non-alphanumeric characters are encoded as the 3 character
sequence <tt/%xx/,  where <tt/xx/ is the hexadecimal value of the character.
The message has the format <tt/key=value/,
where <tt/key/ indicates the message type.
For example:
<tscreen>
<verb>
dump=host=astart4.astart.com%0aprinter=t1%0aprocess=1613%0aupdate_time=1999-03-2
  3-20:32:17.148%0avalue=queue=holdall 0%25250aprinting_aborted=0x0%25250aprinting
  _disabled=0x0%25250aspooling_disabled=0x0%25250a%250a%0a
</verb>
</tscreen>
<p>
The following keys are used:
<enum>
<item>
dump
<newline>
A status dump of the current contents of a print queue.
</enum>
<p>
Each message has a set of headers and a value.
For example,
the decoded dump message from the previous section would be:
<tscreen>
<verb>
host=astart4.astart.com
printer=t1
process=1613
update_time=1999-03-23-20:32:17.148
value=queue=holdall 0%250aprinting_aborted=0x0%250aprinting_disabled=0x0%250aspo
  oling_disabled=0x0%250a%0a
</verb>
</tscreen>
<p>
Each line consists of a key and a value.
The
<tt/host/ key indicates the host name,
<tt/printer/ is the print queue,
<tt/process/ is the process which generated the report or action,
<tt/update_time/ is the time at which the report was generated,
and
<tt/value/ is the value of the report.
<p>
The decoded <tt/value/ of the above report is:
<tscreen>
<verb>
queue='holdall 0%0aprinting_aborted=0x0%0aprinting_disabled=0x0%0aspooling_dis
  abled=0x0%0a
</verb>
</tscreen>
<p>
The <tt/queue/ key provides the current value of the queue control file.
<sect2>Dump Messages
<p>
Dump messages are generated at the start of operations,
and consist of a list of queue status messages.
<sect2>LPD Messages
<p>
These are used to indicate LPD startup or change in operation.
<tscreen>
<verb>
Decode: lpd=host=astart4.astart.com%0aprocess=1672%0aupdate_time=1999-03-23-20:5
1:10.507%0avalue=Starting%0a
host=astart4.astart.com
process=1672
update_time=1999-03-23-20:51:10.507
value=Starting
lpd: 'Starting'
</verb>
</tscreen>
<sect2>Job Status Messages - UPDATE
<p>
Update messages are used to report changes in the queue contents,
such as job arrival.
<tscreen>
<verb>
Decode: update=host=astart4.astart.com%0aidentifier=papowell@astart4+676%0anumber=
 ...
host=astart4.astart.com
identifier=papowell@astart4+676
number=676
printer=t1
process=1677
update_time=1999-03-23-20:51:17.197
value=bnrname=papowell%0acf_esc_image=Apapowell@astart4+676%250aCA%250aD1999-03-
  ...
</verb>
</tscreen>
<p>
This update message reports the arrival of a new job at the queue.
The <tt/value/ field reports the control file contents:
<tscreen>
<verb>
cf_esc_image=Apapowell@astart4+676%0aCA%0aD1999-03-23-20:51:17.151%0aHastart4.as
   tart.com%0aJ/tmp/hi%0aLpapowell%0aPpapowell%0aQt1%0aN/tmp/hi%0afdfA676astart4.as
   tart.com%0aUdfA676astart4.astart.com%0a
class=A
date=1999-03-23-20:51:17.151
file_hostname=astart4.astart.com
fromhost=astart4.astart.com
held=0x0
hf_name=/var/tmp/LPD/t1/hfA676
hold_class=0x0
hold_time=0x0
identifier=papowell@astart4+676
job_time=0x36f86f45
jobname=/tmp/hi
logname=papowell
number=676
priority=A
queuename=t1
size=3
transfername=cfA676astart4.astart.com
update_time=1999-03-23-20:51:17.187
</verb>
</tscreen>
<p>
The <tt/update_time/ field in the section above is the time that the
job information was last updated.
The <tt/cf_esc_image/ value is the URL escaped control file information.
<sect2>Printer Status Messages - PRSTATUS
<p>
These messages report printing or other activity related to a job.
<tscreen>
<verb>
Decode: prstatus=host=astart4.astart.com%0aidentifier=papowell@astart4+676%0anumber=
676%0aprinter=t1%0aprocess=1692%0aupdate_time=1999-03-23-21:02:04.855%0avalue=
finished 'papowell@astart4+676'%252c status 'JSUCC'%0a

host=astart4.astart.com
identifier=papowell@astart4+676
number=676
printer=t1
process=1692
update_time=1999-03-23-21:02:04.855
value=finished 'papowell@astart4+676'%2c status 'JSUCC'
PRSTATUS: 'finished 'papowell@astart4+676', status 'JSUCC''
</verb>
</tscreen>
<sect1>LPR -mhost%port and user logging support
<label id="allowuserlogging">
<label id="mail">
<p>
The <tt>lpr -m</tt> option is used to request that <tt>lpd</tt>
send mail to the user when a job has completed.
LPRng extends this to allow mail addresses of the form
<tt> host[%port][/(TCP|UPD)]</tt> to request that logging information
be sent to the user as well.
<p>
The administrator should be aware that this is a possible security loophole,
and that the
<tt>allow_user_logging</tt>
flag must be enabled to
allow this operation.
<sect>RFC 1179 - Line Printer Daemon Protocol
<label id="rfc1179ref">
<p>
RFC1179 can be obtained from the LPRng distribution, in the LPRng_DOC/rfc1179 directory,
or from one of many sites which mirror the RFCs.
<p>
This RFC is an <em>informational</em> RFC,
which means that the information in it is meant as a guide to users,
and not as a fixed standard.
In addition,
the RFC tried to document the behavior of the BSD LPD print server,
and left out many details dealing with error recover,
error messages,
extensions to the protocol,
etc.
<p>
In this section,
I will try to explain what RFC1179 specifies as a protocol,
and many of the problems encountered in trying to use it.
<sect1>Ports and Connections
<label id="lpdport">
<label id="originateport">
<label id="reuseaddr">
<label id="retryeconnrefused">
<label id="retrynolink">
<label id="socketlinger">
<p>
Options used:
<itemize>
<item> <tt>lpd_port=</tt><em>Port for LPD to accept connection</em>
<item> <tt>originate_port=</tt><em>Ports to originate connections on</em>
<item> <tt>reuse_addr</tt><em>&nbsp;&nbsp;Set SO_REUSEADDR flag on connection</em>
<item> <tt>retry_econnrefused</tt><em>&nbsp;&nbsp;Retry on connect ECONNREFUSED error</em>
<item> <tt>retry_nolink</tt><em>&nbsp;&nbsp;Retry on device open or connection ffailure</em>
<item> <tt>socket_linger#</tt><em>&nbsp;&nbsp;Linger time for sockets</em>
</itemize>
<p>
RFC1179 requires that the <tt>lpd</tt> server listen for TCP/IP connections
on port 515.
This port is registered with the Internet Naming Authority,
and the <tt>/etc/services</tt> file or TCP/IP services database usually has an entry:
<tscreen>
<verb>
printer     515/tcp     spooler     # line printer spooler
</verb>
</tscreen>
<p>
RFC1179 explicitly states that all connections to port 515 must originate from
ports 721-731.
The reason for this restriction is due to the UNIX concept of <em>reserved</em>
and <em>privileged</em> ports.
By convention,
ports in the range 1-1023 can only <bf>bound</bf> by processes whose Effective User ID (EUID)
is 0 (root).
This,
ordinary users could not originate a connection from the reserved or privileged port range.
<p>
In a UNIX environment,  this means that the user programs
<tt>lpr</tt>,
<tt>lprm</tt>,
<tt>lpq</tt>,
and
<tt>lpc</tt>
would have to be SETUID root.
<p>
As experience has shown, for security purposes,
the fewer programs that need to have privileged status,
the better.
LPRng uses the
<tt>lpd_port=printer</tt> configuration option to set the actual port to be use.
By default, this is port 515, but can be set to other values.
<p>
The restriction of originating ports to 721-731 causes another set of problems.
Part of the TCP/IP protocol is concerned with avoiding communications problems
resulting from the arrival of old or <em>stale</em> packets.
When a connection between
<tt>sourcehost, sourceport</tt> and <tt>desthost, destport</tt>
is made,
a set of sequence numbers is established and used for sending and acknowledgement of data.
When the connection terminates,
the TCP/IP protocol restricts the establishment of a new connection between
<tt>sourcehost, sourceport</tt> and <tt>desthost, destport</tt> for a period long
enough for all <em>stale</em> packets to be removed from the system.
This is approximately 10 minutes long.
<p>
In order to simplify assignments of ports,
timing out connections, and other matters,
many TCP/IP packages do keep track of explicit connections
<em>originating</em> from a port,
but simply prevent the port from being reused for either origination
or reception of a connection.
They do,
however,
keep track of the active connections <bf>to</bf> a port,
and perform timeouts on these.
This is usually much simpler to implement,
as it can be done with a list attached to the port.
<p>
This implementation method creates some problems when
a large number of connections must be originated from a
relatively small number of port numbers.
Observe what happens when host 1 tries to send a large number of jobs to a server 2.
The following connections are established and terminated:
<newline><tt>host 1, port 721</tt> and <tt>host 2, port 515</tt>
<newline><tt>host 1, port 722</tt> and <tt>host 2, port 515</tt>
<newline><tt>host 1, port 723</tt> and <tt>host 2, port 515</tt>
<newline><tt>host 1, port 724</tt> and <tt>host 2, port 515</tt>
<newline><tt>host 1, port 725</tt> and <tt>host 2, port 515</tt>
<newline><tt>host 1, port 726</tt> and <tt>host 2, port 515</tt>
<newline><tt>host 1, port 727</tt> and <tt>host 2, port 515</tt>
<newline><tt>host 1, port 728</tt> and <tt>host 2, port 515</tt>
<newline><tt>host 1, port 729</tt> and <tt>host 2, port 515</tt>
<newline><tt>host 1, port 730</tt> and <tt>host 2, port 515</tt>
<newline><tt>host 1, port 731</tt> and <tt>host 2, port 515</tt>
<p>
Now according to the RFC1179 rules and the TCP/IP protocol,
we will have to wait until one of these connections terminates before we
can make another.
On the originating system,
if the TCP/IP implementation does timeouts on the originating port,
we will have to wait for the timeout to elapse before we can make a new
connection.
Unfortunately,  there is no way to find out what the status of the port
is,  so we will have to try them each in turn until we get
a successful connection.
<p>
The LPRng code has tried to provide several methods to deal with
these problems.
Firstly,
the
<tt>originate_port=512 1023</tt>
option specifies the range
of ports used to originate connections
when the software is running either as ROOT or SETUID root.
By strict RFC1179 rules,
this should be
<tt>originate_port=721 731</tt>,
but it turns out that most BSD LPD based implementations only
check for a <em>reserved</em> originating port.
By using 512 ports we get a greatly reduced rate of errors due
to lack of ports due to pending timeouts.
<p>
However,
on some systems which are acting as servers for a large number of
printers even increasing this port range is insufficient,
and steps need to be taken use the originating port numbers
more efficiently.
The Berkeley TCP/IP implementation
<tt>getsockopt()</tt>
and
<tt>setsockopt()</tt>
allows the user to manipulate some of the underlying timeouts and options
of the TCP/IP network.
When a TCP/IP connection is established,
the
<tt>setsockopt()</tt>
facility can be used to set the
<tt>SO_REUSEADDR</tt>
flag on the connection.
This flag effectively sets the timeout value on the ports
and connections to 0,
allowing immediate reuse of the ports.
When done on an originating end of a connection,
this will allow the originating port number to be reused immediately.
<p>
It would appear that by setting
<tt>SO_REUSEADDR</tt>
on the originating end that we have solved our problems.
However,
unless the destination end of the connection sets its
<tt>SO_REUSEADDR</tt>
flag on the connection,
it will still do a timeout.
Thus when we try to make a connection from a port
that was active within a short period of time to the
same host,
then it will reject the connection until the
timeout is over.
<p>
The
<tt>reuse_addr</tt>
flag (default off) forces
the LPRng software to set the
<tt>SO_REUSEADDR</tt>
flag on originating connections.
As indicated,
this will allow ports to be reused immediately for outgoing connections,
rather than waiting for a timeout.
<p>
While the
<tt>reuse_addr</tt>
flag usually allows us to reuse ports,
there is still the problem of dealing with connections failing due to the
remote site rejecting the connection due to a pending timeout
from a previous connection.
A careful study of the original BSD TCP/IP network code and of some
others indicates that when a connection fails due to a pending timeout,
an ECONNREFUSED error code is returned to a
<tt>connect()</tt> system call.
If this happens and we suspect that the remote site is rejecting
the connection due to a timeout problem,
then we should retry making the connection but from a new port,
and continue retrying until all possible ports are used.
<p>
The <tt>retry_econnrefused</tt> (default on) flag is used to
specify that we retry connections in this manner.
When this is set,
a <tt>connection refused</tt>
error causes the connection to be retried using a new port.
This will be repeated until all available ports have been tried.
<p>
When
printing a job and the <tt>lpd</tt> server connection to a remote
site or device open fails,
the <tt>retry_nolink</tt> (default on)
will cause the attempt to be retried indefinitely.
The combination of <tt>retry_econnrefused</tt> and <tt>retry_nolink</tt>
will provide robust connection attempts to remote systems.
<p>
While the above problems cause difficulties when making connections,
there are also problems when terminating connections.
After closing a socket,
the TCP/IP software will try to flush any pending data to the destination.
Unfortunately,
on some systems it will only do this while the process is active.
This has caused problems on systems which terminate
a process it has received an abnormal (signal caused) termination.
<p>
The <tt>setsockopt()</tt> SO_LINGER option allows the user to specify
that when a socket is closed normally,
that the process should block until pending data is flushed or
for the <tt>socket_linger</tt> period.
If <tt>socket_linger</tt> is 0,
then no SO_LINGER operation is done.
<p>
In summary, if you experience problems with connection failures due
to port exhaustion,
first try setting the
<tt>reuse_port</tt> flag,
and you should see a reduction.
Check to ensure that the <tt>retry_econnrefused</tt>
and <tt>retry_nolink</tt> flags are set,
and the error code in the log and status files.
If the failures continue,  then the problem is caused by the
remote end having timeout limitations and there is little you
can do except to set a very long <tt>connect_retry</tt>
interval, say <tt>connect_retry=120</tt> (2 minutes).
<sect1>Protocol Requests and Replies
<label id="remotesupport">
<p>
Options used:
<itemize>
<item> <tt>remote_support=</tt><em>Remote operations supported</em>
</itemize>
<p>
After a connection has been established,
a request can be sent to the <tt>lpd</tt>
server.
The request consists of a single octet indicating the request type,
followed by the printer (or print queue) name, followed by
a set of options for the request,
followed by a LF (line feed) character.
<tscreen>
<verb>
\NNNprinter[ options]\n
  NNN    Operation
</verb>
</tscreen>
<p>
<table>
<tabular ca="|l|l|l|l|">
NNN
|
RFC1179
|
Operation
|
program
@
1
|
yes
|
start print
|
<tt>lpc</tt>
@
2
|
yes
|
transfer a printer job
|
<tt>lpr</tt>
@
3
|
yes
|
print short form of queue status
|
<tt>lpq</tt>
@
4
|
yes
|
print long form of queue status
|
<tt>lpq</tt>
@
5
|
yes
|
remove jobs
|
<tt>lprm</tt>
@
6
|
LPRng
|
do control operation
|
<tt>lpc</tt>
@
7
|
LPRng
|
transfer a block format print job
|
<tt>lpr</tt>
@
8
|
LPRng
|
secure command transfer
|
<tt>lpc</tt>
@
9
|
LPRng
|
verbose status information
|
<tt>lpq</tt>
@
</tabular>
</table>
<p>
After the request has been sent,
then a reply will be returned.
In general the reply has the following form:
<tscreen>
<verb>
\000\n    Success
\NNN\n    Failure (NNN is error code)
text\n    Text or status information
</verb>
</tscreen>
<p>
As can be seen,
this protocol is extremely simple,
but there are a set of problems due to the loosely written language of RFC1179.
<enum>
<item>
Firstly,
while RFC1179 sets limits on the lengths of commands,
it does not strictly set limits on the characters set used in the commands.
This can result in problems when trying to print status information,
headers on banners,
and other details.
<item>
The original RFC1179 protocol did not provide any way to do remote control
of queues or LPD servers.
This has been added to the protocol.
As a side effect,
if you try to use
<tt>lpc</tt> to control a non-LPRng printer,
it will not work.
<item>
You can specify that a network printer is non-LPRng by using the
<tt>remote_support=RQVMC</tt> option and specify the operations
supported by the printer.
The letters R, Q, V, M, and C stand for
<tt>lpr</tt>,
<tt>lpq</tt>,
<tt>lpq -v</tt> (verbose),
verbose <tt>lpq</tt>,
<tt>lprm</tt>,
and <tt>lpc</tt> operations respectively,
and indicate that these are supported.
If <tt>remote_support</tt> does not allow a particular operation,
then the LPRng software will not send a corresponding request to the printer.
For example,
<tt/remote_support=R/
would restrict operations to spooling jobs only,
and the LPRng software would not query the printer for status.
</enum>
<sect1>Job Transfer
<label id="senddatafirst">
<label id="longnumber">
<label id="useshorthost">
<p>
Options used:
<itemize>
<item> <tt>longnumber</tt><em>&nbsp;&nbsp;Long job number (6 digits)</em>
<item> <tt>send_data_first</tt><em>&nbsp;&nbsp;Send data files first</em>
<item> <tt>use_shorthost</tt><em>&nbsp;&nbsp;Use short hostname</em>
</itemize>
<p>
A job transfer operation starts with a job transfer request,
followed by several file transfer operations.
At the end of the file transfers,
the connection should be closed.
<p>
A file transfer request has the form:
<table>
<tabular ca="|l|l|l|l|">
Command
|
Purpose
@
\001\n
|
abort
@
\002nnnn cfname
|
control file transfer
@
\003nnnn dfname
|
data file transfer
@
</tabular>
</table>
<p>
The abort operation is used to terminate job transfer and indicate that
the job should not be processed for printing.
The connection will be closed and the partly transferred job
will be discarded.
<p>
The control file and data file transfer commands have a length (in bytes)
of the file and the name of the file to be transferred.
When the command is received,
the server will reply with a status line:
<table>
<tabular ca="|l|l|l|l|">
Status
|
Purpose
@
\000
|
Accepted, proceed
@
\nnn
|
Rejected with error code
@
</tabular>
</table>
<p>
The reply is only a single octet.
Some defective implementations of RFC1179 send a LF after the octet,
which makes life very difficult.
LPRng makes an effort to detect these non-conforming RFC1179 systems
and will accept jobs from them.
However,  it will not send jobs to them.
<p>
If LPRng sends a reject code, as an extension to RFC1179 it also
sends an error message.   Note that the values for error codes
are not defined,
nor are their causes.
LPRng uses the following values for error codes,
which appear to be compatible with many,
but not all, of the BSD LPD based systems:
<table>
<tabular ca="|l|l|l|l|">
Code
|
Error
@
\000
|
Accepted, proceed
@
\001
|
Queue not accepting jobs
@
\002
|
Queue temporarily full, retry later
@
\003
|
Bad job format, do not retry
@
</tabular>
</table>
<p>
When the sender gets the reply indicating success,
it sends the <tt>nnnn</tt> bytes of the control or data file,
followed by a <tt>\000</tt> octet.
The receiver will then reply as above;
a single <tt>\000</tt> octet indicating success.
<p>
The above procedure is carried out until all data files and the control
file of a job are transferred.
<p>
RFC1179 is silent on the following issues:
<enum>
<item>
When sending a job,
do you send the control file first, followed by the data file(s),
or the data files first?
<item>
When sending multiple jobs,
can you send them on a single connection,
or do you have to establish a new connection for each job?
</enum>
<p>
LPRng will <em>accept</em> jobs whether they are sent control or data files
first.
By default,
it sends the control file first,
followed by the data file.
If the destination system requires that the data files
be sent first,
the <tt>send_data_first</tt> printcap option can be used to force
data files to be sent first.
<p>
RFC1179 states that:
<quote>
The name of the control file ... should start with ASCII "cfA", followed by a three
digit job number, followed by the host name which has constructed the
control file.
</quote>
<p>
The <em>should</em> in this wording indicates that this is simply a guideline,
and that other formats are possible.
Some of the major problems with this format are as follows:
<enum>
<item> The restriction to 3 digits means that at most 1000 jobs
can be in a queue.
Strangely,  some systems generate far more than 1000 jobs a day,
and need to archive them on a regular basis.
The <tt>longnumber</tt> option will allow LPRng to use a 6 digit
job number for files in the print queue.
<item>The host name format is not specified.
Some implementations consider that this is the short host name,
while others think it is the fully qualified domain name (FQDN).
LPRng,
by default,
will use the FQDN host name.
However,  the <tt>use_shorthost</tt> option will force it to
use short host names in control and data files.
<item>
The <tt>cfA</tt> control file name was modified to allow the
job priority to be used as the A letter of the control file.
By default,
this is A (lowest, i.e. <tt>cfA</tt>) and
but can range to Z (highest, i.e. <tt>cfZ</tt>).
All known spoolers except LPRng seem to ignore the actual value of
the letter.
</enum>
<sect1>Data File Transfer
<p>
As discussed,
a data file is transferred using the command below.
<table>
<tabular ca="|l|l|l|l|">
Command
|
Purpose
@
\003nnnn dfname
|
data file transfer
@
</tabular>
</table>
<p>
From RFC1179:
<quote>
The data file may contain any 8 bit values at all.  The total number
of bytes in the stream may be sent as the first operand, otherwise
the field should be cleared to 0.  The name of the data file should
start with ASCII "dfA".  This should be followed by a three digit job
number.  The job number should be followed by the host name which has
constructed the data file.  Interpretation of the contents of the
data file is determined by the contents of the corresponding control
file.
</quote>
<p>
There are several surprises in RFC1179.
<enum>
<item>
Apparently a job should only consist of a single data file.
This is a severe limitation,  and in fact the BSD LPR and other
print spoolers process jobs with multiple data files.
By convention, these data files have names of the form
<tt>dfA</tt>,
<tt>dfB</tt>,
...
<tt>dfZ</tt>,
<tt>dfa</tt>,
<tt>dfz</tt>.
<item>
The RFC does not specify that the control file and data file job numbers
must be identical.
Most implementations follow this convention, which simplifies life
tremendously.
<item>
The RFC does not specify that the control file and data file job host names
must be identical.
Most implementations follow this convention, which simplifies life
tremendously.
<item>
A zero length data file does not cause a data transfer to take place.
LPRng modifies this action to be slightly different.
When a zero length data file transfer is indicated,
all of the input until the connection is closed is used as the
contents of the data file.
<p>
When 'piping' into the <tt>lpr</tt> program,
this can be very useful as it eliminates the need to create temporary
files on the senders host.
The <tt>lpr -k</tt> option for details.
Note that some print spoolers do not use this interpretation,
and this option should be used carefully.
</enum>
<sect1>Control File Contents
<p>
The control file consists of a set of lines which either provide
printing information or specify data files to be printed.
The information lines start with upper case letters or digits,
while the data files lines start with lower case letters.
Here is a sample control file:
<tscreen>
<verb>
Hastart4.astart.com
J(stdin)
CA
Lpapowell
Apapowell@astart4+955
Ppapowell
fdfA955astart4.astart.com
N(stdin)
UdfA955astart4.astart.com
</verb>
</tscreen>
<p>
The following are the letters and their meanings in the control file.
<table>
<tabular ca="|l|l|l|l|">
X
|
RFC1179
|
Meaning
@
A
|
LPRng
|
Identifier for job
@
C
|
RFC1179
|
Class for banner page
@
H
|
RFC1179
|
Host name
@
I
|
RFC1179
|
Indent Printing
@
J
|
RFC1179
|
Job name for banner page
@
L
|
RFC1179
|
Print banner page
@
M
|
RFC1179
|
Mail When Printed
@
N
|
RFC1179
|
Name of source file
@
P
|
RFC1179
|
User identification
@
Q
|
LPRng
|
Queue name
@
R
|
LPRng
|
Accounting info
@
S
|
RFC1179
|
Symbolic link data
@
T
|
RFC1179
|
Title for pr
@
U
|
RFC1179
|
Unlink data file
@
W
|
RFC1179
|
Width of output
@
Z
|
LPRng
|
Filter options
@
1
|
RFC1179
|
troff R font
@
2
|
RFC1179
|
troff I font
@
3
|
RFC1179
|
troff B font
@
4
|
RFC1179
|
troff S font
@
c
|
RFC1179
|
Plot CIF file
@
d
|
RFC1179
|
Print DVI file
@
f
|
RFC1179
|
Print formatted file
@
g
|
RFC1179
|
Plot file
@
k
|
RFC1179
|
Reserved for use by Kerberized LPR clients and servers.
@
l
|
RFC1179
|
Print file leaving control characters
@
n
|
RFC1179
|
Print ditroff output file
@
o
|
RFC1179
|
Print Postscript output file
@
p
|
RFC1179
|
Print file with 'pr' format
@
t
|
RFC1179
|
Print troff output file
@
v
|
RFC1179
|
Print raster file
@
z
|
RFC1179
|
Reserved for future use with the Palladium print system.
@
</tabular>
</table>
<p>
The
<tt>A</tt> (Identifier)
line was introduced to record a unique
system wide job identifier for LPRng submitted jobs.
This is basically formed from the user name,
job number, and host at the time of submission.
For example: <tt>papowell@astart4+955</tt>
is job number 995 submitted by papowell from host astart4.
<p>
The
<tt>C</tt> (Class)
line is set by the <tt>lpr -C class</tt> option,
and the value can be used to control printing.
For example,
the <tt>lpc class zone </tt> command would restrict job printing to
only jobs with class <tt>zone</tt>.
<p>
The
<tt>H</tt> (hostname),
<tt>P</tt> (username),
and
<tt>J</tt> (jobname)
fields are used to identify the host and user which sent the job,
and to provide information to be displayed by <tt>lpq</tt>
when reporting job status.
<p>
The
<tt>L</tt> (print banner page) field is one that has caused many
problems for users.
RFC1179 indicates that its presence causes the banner page to be printed,
and its absence suppresses banner pages.
The <tt>lpr -h</tt> option suppresses putting this line into the
control file.
Usually the <tt>L</tt> field is a duplicate of the <tt>P</tt>
field.
<p>
The <tt>M</tt> (mail information)
field supplies a mail address for LPRng to send mail to when
a job is completed.
See
<ref id="mail" name="LPR -m and user logging">
for more details.
<p>
The <tt>N</tt> (file name) field is usually provided to identify
the file name corresponding to the data file.
This can be used to print names on page separators, etc.
LPRng largely ignores this line.
<p>
The
<tt>I</tt> (indent)
and
<tt>W</tt> (width)
fields are supposed to specify a page indent and width for printing.
These fields are passed to filters if they are present.
<p>
The <tt>Q</tt> (queue name)
field is an LPRng extension,
and contains the name of the print queue the job was originally sent to.
See
<ref id="qq" name="qq printcap option"> for details.
<p>
The <tt>R</tt> (accounting info) field was added by LPRng to allow
a specified account to be billed for job printing.
The <tt>lpr -Rname</tt> option can be used to specify the accounting name.
<p>
The
<tt>S</tt> (symbolic link)
and
<tt>U</tt> (unlink after printing)
lines were used by the original BSD LPD print system to control
how it passed files to the print server.
LPRng ignores these lines.
In fact, it will remove <tt>S</tt> lines and force the <tt>U</tt>
lines to refer only to job data files.
This closes a nasty security loophole on non-LPRng print spoolers.
<p>
The <tt>T</tt> (pr job title) is used with the <tt>lpr -p</tt>
operation to supply a banner to the <tt>pr</tt> program.
<p>
The <tt>Z</tt> (filter options) value is specified with
<tt>lpr -Zoption</tt> and is passed to the data file filters
during the printing operation.
See
<ref id="secfilter" name="Filters"> for details on how the
this is used during the printing process.
<p>
All of the lower case letters are reserved for format specifications for
data files.
In the control file, these are followed by the name of the data file
to which they correspond.
While in principle different data files in the control file can have
different formats,
this has not been implemented in any known spooling system.
See
<ref id="secfilter" name="Filters"> for details on how the
data file formats are used during the printing process.
<sect1>LPQ Requests
<p>
The RFC1179 protocol specifies that <tt>lpq</tt> print status
requests can be sent to the <tt>lpd</tt> server.
The lpq requests have the format:
<tscreen>
<verb>
\003printer [id]* \n    short
\004printer [id]* \n    long
\009printer [id]* \n    LPRng extension- verbose
</verb>
</tscreen>
<p>
The <tt>lpd</tt> print server will then return queue status
and close the data connection.
<p>
RFC1179 does not state in any manner what the format of the queue status
should be.
Thus, implementors have been free to augment or change the status as
they like.
Even the BSD LPR status format has been changed from different versions.
<p>
See
<ref id="statusref" name="Status Monitoring and Logging">
for information on the formats returned.
<p>
The <tt>id</tt> values are used to select the jobs to be displayed.
LPRng displays any job whose ID, hostname, or user name information
from the control file
<tt>A</tt>,
<tt>H</tt>,
or
<tt>P</tt> fields match any of the id values.
<p>
Note that since there is no identification of the information requestor,
then restriction of information is almost impossible.
<p>
<sect1>LPRM Requests
<p>
The RFC1179 protocol specifies that <tt>lprm</tt> job removal
requests can be sent to the <tt>lpd</tt> server.
The lpq requests have the format:
<tscreen>
<verb>
\005printer user [id]* \n
</verb>
</tscreen>
<p>
The <tt>lpd</tt> print server will search the specified print queue
and remove any job whose ID, hostname, or user name information
from the control file
<tt>A</tt>,
<tt>H</tt>,
or
<tt>P</tt> fields match any of the id values
and for which the user has permission to perform a removal operation.
See the
<ref id="lpdpermsref" name="/etc/lpd.perms"> file for details on
permissions.
<p>
Most RFC1179 compatible spoolers use the user information in the
request as the name of the user which spooled the job.
However,
in a network environment this is extremely easy to fabricate,
and is at best a weak type of authentication.
<sect1>LPC Requests
<label id="lpcreread">
<label id="lpccommand">
<p>
LPRng has extended the RFC1179 protocol to allow queue and printer control
commands to be sent to the LPD server.
The format of these commands are:
<p>
<tscreen>
<verb>
\006printer user key [options]
</verb>
</tscreen>
<p>
The following commands are supported.
<table>
<tabular ca="|l|l|l|l|">
Command
|
Operation
@
<tt> active [printer[@host]]</tt>
|
check to see if server accepting connections
@
<tt> abort   (printer[@host] | all)  </tt>
|
terminate server process printing job
@
<tt> disable (printer[@host] | all)  </tt>
|
disable queueing
@
<tt> debug   (printer[@host] | all) debugparms </tt>
|
set debug level for printer
@
<tt> enable  (printer[@host] | all)  </tt>
|
enable  queueing
@
<tt> hold    (printer[@host] | all) (name[@host] | job | all)* </tt>
|
hold job
@
<tt> holdall (printer[@host] | all)  </tt>
|
hold all jobs on
@
<tt> kill    (printer[@host] | all)  </tt>
|
stop and restart server
@
<tt> lpd [printer[@host]]  </tt>
|
get LPD PID for server
@
<tt> lpq (printer[@host] | all) (name[@host] | job | all)*     </tt>
|
invoke LPQ
@
<tt> lprm (printer[@host] | all) (name[@host]|host|job| all)*  </tt>
|
invoke LPRM
@
<tt> move printer (user|jobid)* target </tt>
|
move jobs to new queue
@
<tt> noholdall (printer[@host] | all)  </tt>
|
hold all jobs off
@
<tt> printcap (printer[@host] | all) </tt>
|
report printcap values
@
<tt> quit                            </tt>
|
exit LPC
@
<tt> redirect (printer[@host] | all) (printer@host | off )*    </tt>
|
redirect jobs
@
<tt> release  (printer[@host] | all) (name[@host] | job | all)* </tt>
|
release job
@
<tt> reread [printer[@host]]</tt>
|
LPD reread database information
@
<tt> start   (printer[@host] | all)  </tt>
|
start printing
@
<tt> status  (printer[@host] | all)  </tt>
|
status of printers
@
<tt> stop    (printer[@host] | all)  </tt>
|
stop  printing
@
<tt> topq    (printer[@host] | all) (name[@host] | job | all)* </tt>
|
reorder job
@
<tt> defaultq                         </tt>
|
default queue for LPD server
@
<tt> local    (printer | all)  </tt>
|
client printcap and configuration information
@
<tt> server    (printer | all)  </tt>
|
server printcap and configuration information
@
</tabular>
</table>
<p>
Many of these commands support extremely specialized operations for
print queue management,
However, the following are the most commonly used and are supported by
the BSD LPD print spooling system as well:
<itemize>
<item>
<tt> start, stop, enable, disable </tt>
<newline> Start and stop will start and stop printing for a specified queue.
Enable and disable enable and disable sending and/or accepting jobs
for the queue.
<item>
<tt> abort, kill </tt>
<newline>
Abort will cause the process doing the actual job printing to be terminated.
Kill does an abort, and then restarts the printing process.
These commands are used to restart a queue printing after some disaster.
<item>
<tt> topq </tt>
Places selected jobs at the top of the print queue.
<item>
<tt> status </tt>
<newline>
Shows a status display of the print spools on the server.
</itemize>
<p>
The following commands are extensions to the basic set provided by the
BSD LPD system.
<itemize>
<item>
<tt> lpq, lprm </tt>
<newline>
Invokes the lpq or lprm program from lpc.
Useful when in the interactive mode.
<item>
<tt> hold, holdall, release </tt>
<newline>
The hold command will cause the selected jobs to be held until
released.
The holdall jobs sets all jobs submitted to the queue to be held until
released.
The release command releases jobs for printing.
If a job has had an error and is in the error state,
the release command will cause it to be reprinted.
<item>
<tt> move, redirect </tt>
<newline>
The move command will move selected jobs to the specified spool queue.
The redirect command sends all jobs submitted to the queue to be
sent to the specified queue.
<item>
<tt> active, lpd, reread </tt>
<newline>
The active command will connect to the server for the printer.
This is used to check to see if non-LPRng print servers are active.
The lpd command will connect to the server and
get the process id (PID) of the <tt>lpd</tt> server.
The reread command causes a SIGHUP signal to be sent to the lpd process,
causing it to reread the
<tt>lpd.conf</tt>,
<tt>printcap</tt>,
and
<tt>lpd.perms</tt> files.
This is done when configuration information has
been modified and the administrator wants to have the server use the
new information.
<item>
<tt> debug </tt>
<newline>
This is a desperation facility for developers that allows dynamic enabling
of debug information generation.
Not normally used in general operation.
<item>
<tt> local, server  </tt>
<newline>
These commands will print out the configuration information in the
local
<tt>/etc/lpd.conf</tt> file,
as well as the printcap information for the specified printers;
<tt/client/
prints what the LPRng clients (<tt/lpr, lpq, .../) would use
while
<tt/server/
prints what the LPRng server (<tt/lpd/) would use if running on this host.
This is an extremely useful diagnostic tool for administrators.
Not normally used in general operation.
</itemize>
<sect1>Block Job Transfer
<label id="sendblockformat">
<label id="blocktransfer">
<p>
Options used:
<itemize>
<item> <tt>send_block_format</tt><em>&nbsp;&nbsp;Transfer job as a block</em>
</itemize>
<p>
In normal job transfer operations,
the sender and receiver have a handshake interaction in order to transfer
a print job.
Each file is sent individually.
The <tt>send_block_format</tt> option forces
a Block Job Transfer operation.
This causes the sender to transfer a single file containing all the
job printing information,
including control file and data files.
<p>
The transfer command line has the form:
<tscreen>
<verb>
\007printer size\n
</verb>
</tscreen>
<p>
The receiver will return any acknowledgement of a single 0 octet,
and then the size bytes of the job will be transferred by the sender.
At the end of the transfer a single 0 octet is added,
and the receiver will indicate success by returning a single 0 octet.
Any other value returned by the receiver indicates an error condition.
<p>
The file transferred by the sender is simply the command lines that it
would have normally sent for job transfer,
followed by the control or data file values.
<sect1>Authenticated Transfer
<p>
RFC1179 does not provide any authentication or encryption mechanism
for the transfer of jobs or commands to the <tt>lpd</tt>
print server.
The Authenticated Transfer operation was added to allow an encrypted
or authenticated transfer of print jobs or commands.
<p>
Since there are various restrictions on the incorporation of authentication
facilities into programs,
LPRng supports authentication by providing a simple interface to
encryption programs.
<p>
The idea is that when authentication is required when sending a job,
LPRng will generate a block transfer job as described for the
<ref id="blocktransfer" name="Block Transfer operation,">
and then invoke a set of programs to encryt and transfer the file,
and encrypt and transfer the returned status.
<p>
Similarly,
when sending a command,
the command information will be placed in a file
and the encrypted file will be transferred.
<p>
This technique means that the programs and support to do encryption
are external to LPRng,
and can use any type of method that they choose to implement the
secure and/or authenticated transfer.
<p>
See
<ref id="authref" name="Authentication and Encryption">
for details on the authentication interface.
<sect>Defective RFC1179 Implementations
<p>
Most printer (or print server box) manufacturers totally ignore the
details of the RFC1179 protocol and simply accept the data files for printing,
disregarding the control file <bf>until they need to print a banner
or provide status information</bf>.
<p>
At this point,
you suddenly discover all sorts of little details
that cause horrible problems.
For example,
the use of non-ASCII characters (i.e. - values are 128-255) in the
J (job) line of a control file has been known to crash one network
interface card in such a manner that a power-up is needed to restart
the printer.
<p>
Also,
if you send one particular RFC1179 compatible print spooler a
control file with a character whose value is 255 (i.e. 0xFF),
the job will never get printed,
and there is a mysterious diagnostic on the console:
<tscreen>
<verb>
unexpected end of input
</verb>
</tscreen>
<p>
This is due to the fact that the 0xFF eight bit value is getting sign
extended to a 16 bit value 0xFFFF,
which just turns out to be -1, or the error indication from a read.
<sect1> OS2 Print Spoolers
<p>
For various reasons,  some versions of the OS/2 <tt>lpd</tt>
print spooler have decided to make the control file and data file names
have different formats.
<p>
In addition,
the OS/2 spooler does not follow RFC1179 correctly,  and truncates
the data and job file protocol exchange.
<sect1>Serious Security Loophole
<p>
There is the subtle and nasty problem with some print filters
that are not
<em>meta-char-escape</em> proof.
For example,
suppose that a user decided to spool a job as follows:
<tscreen>
<verb>
lpr '-J; rm -rf /*;' /tmp/a
</verb>
</tscreen>
<p>
This would create a job file with the line:
<tscreen>
<verb>
J `rm /etc/passwd; echo Job;`
</verb>
</tscreen>
<p>
The job line ends up getting passed to a print filter:
<tscreen>
<verb>
pr:sd=/...
  :if=/usr/local/hack
    ... invoked as:
    /usr/local/hack '-J; rm -rf /*;'

/usr/local/hack is:

#!/bin/sh
while [ -n "$1" ] ; do
        case "$1" in
        -J  )  shift; args="$args -M$1";;
        esac;
        shift;
done;
# reformat the command line
eval /usr/local/realfilter $args

^^^^
</verb>
</tscreen>
<p>
The observant reader will notice that the above line gets expanded to:
<tscreen>
<verb>
eval /usr/local/realfilter -MJ; rm -rf /*;
</verb>
</tscreen>
<p>
<sect>The Most Frequently Asked Questions
<label id="FAQ">
<p>
In this section, the Most Frequently Asked Questions
have been placed, together with their answers.
You may notice that some questions have the same answer,
but the symptoms appear differently.
<p>
Some of these answers will reference other material in this FAQ,
or the LPRng man pages.
<sect1>Why do I get malformed from address errors?
<p>
This is the number one question asked by most LPRng users
who try to use LPRng with network printers or other systems
supporting
<ref id="rfc1179" name="RFC1179"> printing.
For details about LPRng and RFC1179, see
<ref id="rfc1179ref" name="RFC1179 and LPRng">.
<p>
The
<tt> malformed from address </tt> error is usually reported when
trying to send a print job from LPRng to other BSD LPR or RFC1179
LPR implementations, or with network connected printers
that have a built in LPR server.
This is due to the following RFC1179 rule:
<quote>
Servers originate a connection from ports in the range 721-731.
</quote>
<p>
WHY?  These are a subset of the 'reserved' ports in UNIX, and normal users
cannot open connections from them.  This provides a small amount
of security from UNIX users on the host 'spoofing' a server.
<p>
IMPLICATION:  in order to do use a reserved port,  the program
must have root privileges.  This means the LPR, LPD, LPQ, etc.,
programs must be installed SUID root.  This can open up a can
of worms with regard to security,  but LPRng has been designed to
take as much paranoid care as possible to avoid problems.
<p>
WHAT TO DO:
<newline>
When installing LPRng,  you will need to install the executables
SUID root.
In the <tt>src/Makefile</tt>,  you can remove the comment from the line
<tscreen>
<verb>
PERMS=SUID_ROOT_PERMS
</verb>
</tscreen>
and then do <tt> make install</tt>.
This will install the executables
SUID, and owned by root.
<sect1>It was working normally, then I get connection refused errors
<p>
This message usually appears when you have been sending a large number
of jobs to a network printer or a remote system.
The reason for this is a combination the above port 721-731 restriction
and the TCP/IP timeouts.
For details, see
<ref id="rfc1179ref" name="RFC1179 and LPRng">,
but here is a quick explanation.
<p>
A TCP/IP connection is usually specified as between
<tt>srchost:srcport, desthost:destport</tt>,
although in practice the order of source (src) and destination
(dest) is not important.
<p>
When a connection is established,  each end of the connection
exchanges the necessary flow control and error control information.
When a connection is terminated,
each end of the connection will not accept another connection from
the same <tt>host:port</tt> that was previously active
for a specified timeout period,
usually 10 minutes.
<p>
Some TCP/IP implementations go further:  they will not allow
<bf>ANY</bf> connection to be <bf>originated</bf>
(via the <tt>bind()</tt> system call or API)
from a port that was active,
or accepted on a port that was active for this timeout period.
<p>
Now let us see what happens when we have a client program,
which must originate a connection on port 721-731, connect
to the server, which waits for a connection on port 515.
We first try to make a connection from host:port
<tt>1.1.1.1:721</tt> to
<tt>1.1.1.2:515</tt>.
The first time that we make the connection (or the first connection)
we succeed.
We can transfer a file, etc., and then close the connection.
When we try to reconnect from
<tt>1.1.1.1:721</tt> to
<tt>1.1.1.2:515</tt>
we get an error such as
"address already in use"
or "connection refused".
<p>
Luckily,  we can use port 722 to originate a connection,
and we can connect from
<tt>1.1.1.1:722</tt> to
<tt>1.1.1.2:515</tt>.
We continue on, until we come to port 731,
and then we need to wait for our timeouts.
<p>
SOLUTION:
<p>
It appears that most RFC1179 implementations do not check for the exact
port
range 721-731,  but only that the connection originates from a
reserved port,
i.e. - in the range 1-1023.
You can extend the range of ports used by LPRng by changing the
<tscreen>
<verb>
originate_port=721 731
</verb>
</tscreen>
value in the defaults (<tt>LPRng/src/common/defaults.c</tt>) file or in the <tt>lpd.conf</tt>
file.  I recommend the following:
<tscreen>
<verb>
originate_port=512 1022
</verb>
</tscreen>
This is, in fact, now the default in LPRng software.
If you get the infamous
<tt>malformed from address</tt>
error message from your spooler, then
you will have to set originate_port=721 731,  and live with
a delayed throughput.
<sect1>Job is not in print queue, but it gets printed!
<p>
In the original BSD LPD implementation,
the LPR program copied users files to a special spool queue directory,
and then caused the LPD server to peek in the directory and print
the files.
<p>
This type of operation required spool directory space,
special SETUID programs,
and a slew of headaches in system security and management.
<p>
The LPR, LPQ, and other user programs in the LPRng suite use TCP/IP
connections and transfer jobs directly to a LPD server running on
a remote host,
or even the local host if appropriate.
Note that this type of operation does not require a LPD server to run
on each local machine.
In fact,  you can have a single host system performing all of your
printing.
This type of operation is very similar to a central mail server versus
individual systems, each having their own mail server and queues.
<p>
However,
some users require or want their jobs to be spooled on the local host system,
and then transferred to the remote printer.
This is usually the case when some type of processing (filtering)
is needed in order to print the job correctly.
There are several methods that can be used to force this.
<p>
Method 1: Explicit Printer Address
<p>
You can force a job to be sent directly to the <tt> pr </tt>
serviced by the LPD server on
<tt>host</tt>
by using the form:
<tscreen>
<verb>
lpr -Ppr@host file
</verb>
</tscreen>
<p>
You can also set the <tt>PRINTER</tt> environment variable to
a similar form, and get the same effect:
<tscreen>
<verb>
PRINTER=pr@host; export PRINTER;
lpr file
</verb>
</tscreen>
<p>
Method 2: User and Server Printcap Entries
<p>
If you want to have the benefits of a printcap file,
i.e. - you can use aliases or abbreviations for the names of printers,
then here is a couple of hints.
First,
the LPRng software scans the <tt>/etc/printcap</tt> file for printcap
entries, combining information for the same printer into a single entry.
Information found later in the printcap file will override earlier
information.
In addition,
you can tag entries as either being used for all utilities or just
for the LPD server.
Here are a couple of examples:
<tscreen>
<verb>
# for all utilities
pr:lp=pr@host
# just for LPD
pr:server
  :lp=/dev/lp
# more information
pr:check_for_nonprintable@
# --- final result for LPR
pr:lp=pr@host:check_for_nonprintable@
# --- final result for LPD
pr:lp=/dev/lp:check_for_nonprintable@
</verb>
</tscreen>
<p>
As you can see,
the <tt>server</tt>
keyword indicates that the printcap entry is only for the server.
The LPR utility will send the job to the host, while the LPD server
will print it on <tt>/dev/lp</tt>.
<p>
Note that the <tt>lp=...</tt> information overrides the
<tt>:rp:</tt> (remote printer)
and
<tt>:rm:</tt> (remote machine) fields if they are present.
<p>
Method 3: Force sending to server on <tt>localhost</tt>
<p>
The
<tt>force_localhost</tt>
printcap or configuration flag forces non-LPD applications to send all
requests and print jobs to the server running on the local host.
<p>
This method is similar to the previous one,
but has the benefit that it can be configured as a global (i.e. -
applies to all printers) rather than printer specific.
You can put this in the <tt>/etc/lpd.conf</tt> file for general
application,  or have a printcap entry of the following form:
<tscreen>
<verb>
# for all utilities
pr:lp=pr@host:force_localhost
</verb>
</tscreen>
<p>
The LPD server will ignore the
<tt>force_localhost</tt> flag,
and send jobs to the <tt>pr</tt> queue on the <tt>host</tt>
machine.
However, the LPR, LPQ, etc., utilities will send their requests to the
server running on the local host.
<sect1>Job disappears and is never printed, but lpr works
<p>
This is a rather disconcerting problem,
and usually occurs when sending jobs to either a network printer or
a nonconforming
<ref id="rfc1179" name="RFC1179">
print spooler.
For details about LPRng and RFC1179, see
<ref id="rfc1179ref" name="RFC1179 and LPRng">,
but here is a quick explanation.
<p>
An LPD job consists of a control file,  which contains information
about the job,  and one or more data files.  RFC1179 is silent on the
order that jobs are sent;  however some implementations REQUIRE that
the data files be sent first,  followed by the control file.
<p>
SOLUTION:
<p>
Set the <tt>send_data_first</tt> flag in the printcap for the particular
printer,  or in the <tt>lpd.conf</tt> configuration file.  This is:
<tscreen>
<verb>
:send_data_first:  (printcap)
send_data_first    (lpd.conf)
</verb>
</tscreen>
<p>
Note that some printers/servers INSIST on the control file first;
You can clear the flag using <tt>send_job_first@</tt> if you need to.
<sect1>I get messages about bad control file format
<p>
RFC1179 describes a set of fields that MAY appear in the control file.
It is silent if other ones can appear as well.
Unfortunately,  some implementations will reject jobs unless they contain
ONLY fields from a very small set.  In addition,  RFC1179 is silent
about the ORDER the fields can appear.
<p>
LPRng quite happily will accept jobs from poor or nonconforming RFC1179
spooler programs,
and fix them up to be conformant.
<p>
If you are sending jobs to one of a non-conforming spooler,
you can force LPRng to send jobs with only the fields described
in RFC1179 by setting the
the <tt> :bk: </tt> (BacKwards compatible) flag in the
printcap for your printer.
<sect1>What is RFC 1179, the Line Printer Daemon Protocol?
<label id="rfc1179">
<p>
RFC1179 defines a standard method by which print jobs can be transferred
using the TCP/IP protocol between hosts.
The standard was developed by simply detailing the way that
a version of the BSD LPD software did its job.
<p>
From the RFC Introduction:
<quote>
RFC 1179 describes a print server protocol widely used on
the Internet for communicating between line printer daemons (both
clients and servers).  RFC1179 is for informational purposes only,
and does not specify an Internet standard.
</quote>
<p>
Having said this,
the RFC then goes on to describe the protocol used
by a particular implementation of LPD.
The problem was that the RFC did not provide
any way to put extensions to the operations into the system,
and failed to specify such interesting details as the order in which
print jobs and their components could be transferred.
<p>
Comment by Patrick Powell <tt> &lt;papowell@astart.com> </tt>:
<quote>
<p>
Since 1988,
there have been a large number of print spooling systems developed which
claim RFC1179 conformance,
but which are mutually incompatible.
<p>
Rather than live with the limited capabilities of the RFC1179 standard,
LPRng has extended them by adding capabilities to perform remote control
of print spoolers,
encrypted and authenticated data transfers,
and other operations missing from the RFC1179 specification.
However,
great effort was made to be backwards compatible with older and other LPD
based systems.
<p>
LPRng was developed in order to be able to both accept and provide
interactions with these systems.  It does so by allowing various options
to be used to <em>tune</em> how print jobs would be exchanged.
Currently,
LPRng can be configured to send and receive print jobs between a vast number
of the existing spooling systems.
It is flexible enough to act as a gateway between non-compatible systems,
and has provisions to transform jobs from one format to another in a dynamic
manner.
</quote>
<p>
For a detailed explanation
about LPRng and RFC1179, see
<ref id="rfc1179ref" name="RFC1179 and LPRng">.
<sect1>I want to replace lp, lpstat, etc, but my programs need them
<p>
LPRng was designed as a replacement the BSD printing system. As such,
it inherited its command names and options from the latter. As you
might know, System&nbsp;V uses a totally different set of commands,
incompatible with the BSD ones.
<p>
The good news is that the LPRng binaries include an emulation for the
System&nbsp;V commands.
(See
<ref id="lpsimulation" name="lp Simulation">
for details.
Briefly, you create links to the appropriate programs,
and invoke them by the link names.
<em>Actually, these links are installed by default in recent versions.</em>
<p>
<tscreen>
<verb>
ln -s lpr lp
ln -s lpq lpstat
ln -s lprm cancel
</verb>
</tscreen>
<p>
If you make these links, calling <tt>lp</tt>, <tt>lpstat</tt> and
<tt>cancel</tt> will give you a (partial) SVR4 emulation. They have
their own man pages, which you should read if you need the emulation.
<p>
Since it is a <bf>partial</bf> emulation, you shouldn't expect everything
to work. In particular, I would guess that any script which relies on
the output format of one of your system binaries will break.
Again, see
<ref id="lpsimulation" name="lp Simulation">
for more details or additional suggestions.
<sect>Development Test Configuration
<p>
The LPRng code has the ability to run as non-setuid software,
and to use the non-default TCP/IP ports for communication.
This facility allows a <em>Test Version</em> to be run in parallel with the
normal LPRng software.
<p>
To simplify testing and portability issues,
a simple test version of the spool queues and jobs has been supplied with the
LPRng distribution.
These queues can be placed in a suitable location
(<tt>/tmp</tt> is common) and the LPRng software tested.
<p>
The test version of the software will use the <tt>LPD_CONF</tt>
environment variable to specify the location of the configuration file.
It will read this configuration file on startup and use the values
to override the normal defaults.
Since a user could maliciously set up their own configuration files
with values that could compromise system security,
it is strongly recommended that the test version is not made SETUID root.
In fact,
the LPRng code will chatter messages when the LPD_CONF ability is enabled
and it is run as root.
<sect1>Compiling the Test Version
<p>
Edit <tt>src/Makefile</tt>, and uncomment the indicated line.
Then run <tt>make</tt> to regenerate the distribution.
<tscreen>
<verb>
#### ****** TESTING AND SECURITY LOOPHOLE ******************************
# Define GETENV to allow the LPD_CONFIG environment
#  variable to be used as the name of a configuration file.  In non-testing
#  systems,  this is a security loophole.
#CF := $(CF) -DGETENV

</verb>
</tscreen>
<sect1>Setting Up The Test Version Spool Queues
<p>
The LPRng <tt>TESTSUPPORT</tt> directory contains a set of shell scripts
and files that need to be installed in the appropriate directory.
The following steps are used.
<enum>
<item>
First,
you need to set up your <tt>HOST</tt> environment variable to the fully
qualified domain name of your host
and your <tt>USER</tt> environment variable to your user name.
This is done in order to get values to put into the Test Version configuration files.
<item>
In the <tt>TESTSUPPORT</tt> directory,
edit the <tt>Makefile</tt>,
and specify the location of the <tt>Test Version</tt> spool queues.
The default location is <tt>/tmp</tt>;
since on most systems these files are deleted or are available to everybody,
a more secure location should most likely be used.
<bf>DO NOT USE THE RAW TESTFILE DIRECTORY</bf>.
These files need to be copied and placed in another directory.
<item>
The <tt>LPD_CONF</tt> environment variable should be set to the
location of the installed <tt/lpd.conf/ file.
<item>
In the <tt>TESTSUPPORT</tt> directory,
run <tt>make</tt>.
This will copy and install the necessary files.
</enum>
<p>
Example:
<tscreen>
<verb>
  CSH:
    setenv HOST &lcub;fully qualified domain name&rcub;;
    setenv USER `whoami`
    setenv LPD_CONF /tmp/LPD/lpd.conf
    set path=( /tmp/LPD $path )
    unsetenv PRINTER
   Example:
      setenv HOST astart1.astart.com
      setenv USER papowell
      setenv LPD_CONF /tmp/LPD/lpd.conf
      set path=( /tmp/LPD $path )
      unsetenv PRINTER
  Bourne Shell:
    HOST=&lcub;fully qualified domain name&rcub;; export HOST;
    USER='whoami'; export USER
    LPD_CONF=/tmp/LPD/lpd.conf.$HOST; export LPD_CONF
    PATH=/tmp/LPD:$PATH; export PATH
    PRINTER=; export PRINTER
   Example:
      HOST=astart1.astart.com; export HOST
      USER=papowell; export USER
      LPD_CONF=/tmp/LPD/lpd.conf.$HOST; export LPD_CONF
      PATH=/tmp/LPD:$PATH; export PATH
      PRINTER=; export PRINTER
  cd TESTSUPPORT
  make
</verb>
</tscreen>
<sect1>Running the Test Version Software
<p>
Set your current directory to the location of the compiled <tt>Test Version</tt>
executables.
Execute the various executables using <tt>./cmd</tt>,
or set <tt>.</tt> <bf> as the first entry in the PATH </bf>.
If it is not the first entry,
then the standard system executables will be used.
<enum>
<item> Run <tt>./checkpc</tt>.
this will print out the various values for the spool queues in the <tt>Test Version</tt>
setup.
If the <tt>t1</tt>, <tt>t2</tt>,... spool queues are not displayed,
make sure that the LPD_CONF environment variable is set correctly and that you
are using the <tt>Test Version</tt> executable.
<item>Run <tt>./checkpc -f</tt>.
This will fix up the (deliberately introduced) problems in the spool queues.
<item>
Next,  run <tt>./lpd -F</tt> in one window,
and then run <tt>./lpq -a </tt> in another window.
This will check that the server is working.
<item>
You can now amuse yourself by sending jobs,
setting up permissions checking,
and other chores.
<item>
When everything appears to be working correctly,
you can then remove the <tt>Test Version</tt> flag from the
<tt>src/Makefile</tt>, recompile,
and install the LPRng software.
</enum>
<sect>Acknowledgements
<p>
I'd like to thank the proof-readers from the LPRng mailing list,
in particular:
Gordon Haverland (<tt>haverlan@agric.gov.ab.ca</tt>),
Lars Anderson, Bertrand Decouty, Horst Fickenscher,
Philip Griffith, Gordon Haverland, John Perkins, Richard S. Shuford,
James H. Young and the ones I forgot.
<p>
Finally,  Patrick would like to thank all of the LPRng users
who so relentlessly tried the incredible number of permutations and
combiNATIONS Of printers and software,
and made requests for <em>just one more feature</em>.
<sect>Index To All The Configuration and Printcap Options
<label id="index">
<label id="options">
<p>
<!-- START OPTIONS -->
<tt><ref id="ab" name="ab"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  always print banner, ignore lpr -h option <newline>
<tt><ref id="achk" name="achk"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  query accounting server when connected <newline>
<tt><ref id="ae" name="ae"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  accounting at end (see also af, la, ar, as) <newline>
<tt><ref id="af" name="af"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  name of accounting file (see also la, ar) <newline>
<tt><ref id="ah" name="ah"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  automatically hold all jobs <newline>
<tt><ref id="allowduplicateargs" name="allow&lowbar;duplicate&lowbar;args"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Allow duplicate command line arguments (legacy requirement) <newline>
<tt><ref id="allowgetenv" name="allow&lowbar;getenv"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Allow use of LPD&lowbar;CONF <newline>
<tt><ref id="allowuserlogging" name="allow&lowbar;user&lowbar;logging"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  allow users to request logging info using lpr -mhost%port <newline>
<tt><ref id="allowusersetting" name="allow&lowbar;user&lowbar;setting"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>allow privileged user to impersonate other users<newline>
<tt><ref id="ar" name="ar"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  enable remote transfer accounting (if af is set) <newline>
<tt><ref id="as" name="as"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  accounting at start (see also af, la, ar) <newline>
<tt><ref id="auth" name="use&lowbar;auth"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  authentication type to use <newline>
<tt><ref id="authforward" name="auth&lowbar;forward"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>authentication type for forwarding<newline>
<tt><ref id="be" name="be"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Banner at End Generation Program <newline>
<tt><ref id="bk" name="bk"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Berkeley LPD job file format <newline>
<tt><ref id="bkfilteroptions" name="bk&lowbar;filter&lowbar;options"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Berkeley LPD filter options <newline>
<tt><ref id="bkoffilteroptions" name="bk&lowbar;of&lowbar;filter&lowbar;options"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Berkeley LPD OF filter options <newline>
<tt><ref id="bkf" name="bkf"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  backwards-compatible filters: use simple parameters <newline>
<tt><ref id="bl" name="bl"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  short banner line sent to banner printer <newline>
<tt><ref id="bp" name="bp"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Banner Generation Program (see bs, be) <newline>
<tt><ref id="bq" name="bq"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Use filters on bounce queue jobs <newline>
<tt><ref id="bqformat" name="bq_format"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Format of bounce queue output <newline>
<tt><ref id="br" name="br"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Serial port bit rate (see ty) <newline>
<tt><ref id="bs" name="bs"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Banner at Start Generation Program <newline>
<tt><ref id="cd" name="cd"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  control directory <newline>
<tt><ref id="checkfornonprintable" name="check&lowbar;for&lowbar;nonprintable"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  LPR checks for nonprintable file <newline>
<tt><ref id="checkidle" name="check&lowbar;idle"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  program used to check for idle printer <newline>
<tt><ref id="classinstatus" name="class&lowbar;in&lowbar;status"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Show job class name in <tt>lpq</tt> status information <newline>
<tt><ref id="client" name="client"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Mark printcap entry for client programs only <newline>
<tt><ref id="cm" name="cm"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  comment identifying printer (LPQ) <newline>
<tt><ref id="configfile" name="config&lowbar;file"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  configuration file <newline>
<tt><ref id="connectgrace" name="connect&lowbar;grace"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  connection control for remote printers <newline>
<tt><ref id="connectinterval" name="connect&lowbar;interval"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  connection control for remote printers <newline>
<tt><ref id="connecttimeout" name="connect&lowbar;timeout"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  connection control for remote printers <newline>
<tt><ref id="connecttry" name="connect&lowbar;try"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  connection control for remote printers <newline>
<tt><ref id="controlfilterbk" name="control&lowbar;filter"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  control file filter <newline>
<tt><ref id="db" name="db"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  debug options for queue <newline>
<tt><ref id="defaultformat" name="default&lowbar;format"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  default job format <newline>
<tt><ref id="defaultpermission" name="default&lowbar;permission"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  default permission for files <newline>
<tt><ref id="defaultprinter" name="default&lowbar;printer"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  default printer <newline>
<tt><ref id="defaultprinterwhenunknown" name="default&lowbar;printer&lowbar;when&lowbar;unknown"></tt><tt>&nbsp;&nbsp;</tt>  used by LPD when printer name not in printcap <newline>
<tt><ref id="defaultpriority" name="default&lowbar;priority"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  default job priority <newline>
<tt><ref id="defaultremotehost" name="default&lowbar;remote&lowbar;host"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  default remote host <newline>
<tt><ref id="defaulttmpdir" name="default&lowbar;tmp&lowbar;dir"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  default directory for temp files <newline>
<tt><ref id="destinations" name="destinations"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  printers that a route filter may return and we should query <newline>
<tt><ref id="exitlingertimeout" name="exit_linger_timeout"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  connection close linger timeout<newline>
<tt><ref id="ff" name="ff"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  string to send for a form feed <newline>
<tt><ref id="filterldpath" name="filter&lowbar;ld&lowbar;path"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  filter LD&lowbar;LIBRARY&lowbar;PATH value <newline>
<tt><ref id="filteroptions" name="filter&lowbar;options"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  filter options <newline>
<tt><ref id="filterpath" name="filter&lowbar;path"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  filter PATH environment variable <newline>
<tt><ref id="fo" name="fo"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  send form feed when device is opened <newline>
<tt><ref id="forcefqdnhostname" name="force&lowbar;fqdn&lowbar;hostname"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  force FQDN hostname value in control file <newline>
<tt><ref id="forcelocalhost" name="force&lowbar;localhost"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  force clients to send all requests to localhost <newline>
<tt><ref id="forcequeuename" name="force&lowbar;queuename"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  force use of this queuename if none provided <newline>
<tt><ref id="fq" name="fq"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  send form feed when device is closed <newline>
<tt><ref id="fulltime" name="full&lowbar;time"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  use extended time format <newline>
<tt><ref id="generatebanner" name="generate&lowbar;banner"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  generate banner page for forwarded jobs<newline>
<tt><ref id="group" name="group"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Effective Group ID (EGID) for SUID ROOT programs <newline>
<tt><ref id="hl" name="hl"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Header (banner) last, at end of job <newline>
<tt><ref id="ignorerequesteduserpriority" name="ignore&lowbar;requested&lowbar;user&lowbar;priority"></tt><tt></tt>  Ignore requested user priority <newline>
<tt><ref id="if" name="if"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  default (f, l) filter program <newline>
<tt><ref id="ipv6" name="ipv6"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  using IPV6 conventions <newline>
<tt><ref id="kerberoskeytab" name="kerberos&lowbar;keytab"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  kerberos keytab file location <newline>
<tt><ref id="kerberoslife" name="kerberos&lowbar;life"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  kerberos key lifetime <newline>
<tt><ref id="kerberosrenew" name="kerberos&lowbar;renew"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  kerberos key renewal time <newline>
<tt><ref id="kerberosforwardprincipal" name="kerberos&lowbar;forward&lowbar;principal"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;</tt>  kerberos remote principle name for forwarding <newline>
<tt><ref id="kerberosserverprincipal" name="kerberos&lowbar;server&lowbar;principal"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  kerberos remote server principle name <newline>
<tt><ref id="kerberosservice" name="kerberos&lowbar;service"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  kerberos default service <newline>
<tt><ref id="la" name="la"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  enable local printer accounting (if af is set) <newline>
<tt><ref id="ld" name="ld"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  leader string sent on printer open <newline>
<tt><ref id="lf" name="lf"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  error log file for spool queue <newline>
<tt><ref id="lk" name="lk"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  lock the IO device <newline>
<tt><ref id="lockfile" name="lockfile"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  lpd lock file <newline>
<tt><ref id="loggerdestination" name="logger&lowbar;destination"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  destination for logging information <newline>
<tt><ref id="loggertimeout" name="logger&lowbar;timeout"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  intervals between connection attempts <newline>
<tt><ref id="loggerpathname" name="logger&lowbar;pathname"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  temp file for log information <newline>
<tt><ref id="loggermaxsize" name="logger&lowbar;max&lowbar;size"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  max size in Kbytes of temp file for log information <newline>
<tt><ref id="longnumber" name="longnumber"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  use long job number when a job is submitted <newline>
<tt><ref id="lp" name="lp"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  printer device name or specification <newline>
<tt><ref id="lpdbounce" name="lpd&lowbar;bounce"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  force lpd to filter job before forwarding <newline>
<tt><ref id="lpdforcepoll" name="lpd&lowbar;force&lowbar;poll"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  force lpd to poll idle printers <newline>
<tt><ref id="lpdpolltime" name="lpd&lowbar;poll&lowbar;time"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  interval between lpd printer polls <newline>
<tt><ref id="lpdport" name="lpd&lowbar;port"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  lpd listening port <newline>
<tt><ref id="lpdprintcappath" name="lpd&lowbar;printcap&lowbar;path"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  lpd printcap path <newline>
<tt><ref id="lprbounce" name="lpr&lowbar;bounce"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  lpr does filtering as in bounce queue <newline>
<tt><ref id="lprbsd" name="lpr&lowbar;bsd"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  lpr does filtering as in bounce queue <newline>
<tt><ref id="mailfrom" name="mail&lowbar;from"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  mail user from user name <newline>
<tt><ref id="mailoperatoronerror" name="mail&lowbar;operator&lowbar;on&lowbar;error"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  mail to this operator on error <newline>
<tt><ref id="maxconnectinterval" name="max&lowbar;connect&lowbar;interval"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  maximum time between connection attempts <newline>
<tt><ref id="maxlogfilesize" name="max&lowbar;log&lowbar;file&lowbar;size"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  maximum size (in K) of spool queue log file <newline>
<tt><ref id="maxserversactive" name="max&lowbar;servers&lowbar;active"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  maximum number of lpd queue servers that can be active <newline>
<tt><ref id="maxstatusline" name="max&lowbar;status&lowbar;line"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  maximum length of status line <newline>
<tt><ref id="maxstatussize" name="max&lowbar;status&lowbar;size"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  maximum size (in K) of status file <newline>
<tt><ref id="mc" name="mc"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  maximum copies allowed <newline>
<tt><ref id="minlogfilesize" name="min&lowbar;log&lowbar;file&lowbar;size"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  minimum size (in K) of spool queue log file <newline>
<tt><ref id="minstatussize" name="min&lowbar;status&lowbar;size"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  minimum size to reduce status file to <newline>
<tt><ref id="minfree" name="minfree"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  minimum amount of free space needed <newline>
<tt><ref id="ml" name="ml"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  minimum number of printable characters for printable check <newline>
<tt><ref id="mstimeresolution" name="ms&lowbar;time&lowbar;resolution"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  millisecond time resolution <newline>
<tt><ref id="mx" name="mx"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  maximum job size (1Kb blocks, 0 = unlimited) <newline>
<tt><ref id="nb" name="nb"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  use nonblocking device open <newline>
<tt><ref id="networkconnectgrace" name="network&lowbar;connect&lowbar;grace"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  pause between transferring jobs to remote printer <newline>
<tt><ref id="nline_after_file" name="nline&lowbar;after&lowbar;file"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  N line after file name <newline>
<tt><ref id="of" name="of"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  banner output filter <newline>
<tt><ref id="offilteroptions" name="of&lowbar;filter&lowbar;options"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  OF filter options <newline>
<tt><ref id="oh" name="oh"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Printcap entry valid only on these hosts <newline>
<tt><ref id="originateport" name="originate&lowbar;port"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  originate connections from these ports <newline>
<tt><ref id="passenv" name="pass&lowbar;env"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  clients pass these environment variables to filters <newline>
<tt><ref id="permspath" name="perms&lowbar;path"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  lpd.perms files <newline>
<tt><ref id="pl" name="pl"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  page length (in lines) <newline>
<tt><ref id="pr" name="pr"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  pr program for p format <newline>
<tt><ref id="printcappath" name="printcap&lowbar;path"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  /etc/printcap files <newline>
<tt><ref id="ps" name="ps"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  printer status file name <newline>
<tt><ref id="pw" name="pw"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  page width (in characters) <newline>
<tt><ref id="px" name="px"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  page width in pixels (horizontal) <newline>
<tt><ref id="py" name="py"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  page length in pixels (vertical) <newline>
<tt><ref id="queue_lock_file" name="queue_lock_file"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>queue lock file name<newline>
<tt><ref id="queue_control_file" name="queue_control_file"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>queue control file name<newline>
<tt><ref id="queue_status_file" name="queue_status_file"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>queue status file name<newline>
<tt><ref id="qq" name="qq"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  put queue name in control file <newline>
<tt><ref id="remotesupport" name="remote&lowbar;support"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  operations allowed to remote host <newline>
<tt><ref id="reportserveras" name="report&lowbar;server&lowbar;as"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  server name for status reports <newline>
<tt><ref id="retryeconnrefused" name="retry&lowbar;econnrefused"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Retry on connect ECONNREFUSED errors <newline>
<tt><ref id="retrynolink" name="retry&lowbar;nolink"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Retry device open or connect failures <newline>
<tt><ref id="returnshortstatus" name="return&lowbar;short&lowbar;status"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  return short lpq status when request arrives from specified host <newline>
<tt><ref id="reuseaddr" name="reuse&lowbar;addr"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  set SO&lowbar;REUSEADDR on outgoing ports <newline>
<tt><ref id="reverselpqformat" name="reverse&lowbar;lpq&lowbar;format"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  reverse lpq format when request arrives from specified host <newline>
<tt><ref id="rg" name="rg"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  clients allow only users in this group access to printer <newline>
<tt><ref id="rm" name="rm"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  remote machine (hostname) (with rp) <newline>
<tt><ref id="router" name="router"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  routing filter, returns destinations <newline>
<tt><ref id="rp" name="rp"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  remote printer name (with rm) <newline>
<tt><ref id="rw" name="rw"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  open printer for reading and writing <newline>
<tt><ref id="safechars" name="safe&lowbar;chars"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  additional safe characters in control file lines <newline>
<tt><ref id="saveonerror" name="save&lowbar;on&lowbar;error"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  save job when an error <newline>
<tt><ref id="savewhendone" name="save&lowbar;when&lowbar;done"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  save job when done <newline>
<tt><ref id="sb" name="sb"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  short banner (one line only) <newline>
<tt><ref id="sd" name="sd"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  spool directory pathname <newline>
<tt><ref id="sendblockformat" name="send&lowbar;block&lowbar;format"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  send block of data, rather than individual files <newline>
<tt><ref id="senddatafirst" name="send&lowbar;data&lowbar;first"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  send data files first in job transfer <newline>
<tt><ref id="sendfailureaction" name="send&lowbar;failure&lowbar;action"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  failure action to take after send&lowbar;try attempts failed <newline>
<tt><ref id="sendjobrwtimeout" name="send&lowbar;job&lowbar;rw&lowbar;timeout"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  print job read/write timeout <newline>
<tt><ref id="sendqueryrwtimeout" name="send&lowbar;query&lowbar;rw&lowbar;timeout"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  status query operation read/write timeout <newline>
<tt><ref id="sendtry" name="send&lowbar;try"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  maximum number of times to try sending job <newline>
<tt><ref id="sendmail" name="sendmail"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  sendmail program <newline>
<tt><ref id="server" name="server"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Mark printcap entry for lpd server program only <newline>
<tt><ref id="servertmpdir" name="server&lowbar;tmp&lowbar;dir"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  server temporary file directory <newline>
<tt><ref id="sf" name="sf"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  suppress form feeds separating data files in job <newline>
<tt><ref id="sh" name="sh"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  suppress header (banner) pages <newline>
<tt><ref id="short_status_date" name="short&lowbar;status&lowbar;date"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  short (hh:mm) timestamp format for status <newline>
<tt><ref id="shortstatuslength" name="short&lowbar;status&lowbar;length"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  short lpq status length in lines <newline>
<tt><ref id="socketlinger" name="socket&lowbar;linger"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  set the SO&lowbar;LINGER socket option <newline>
<tt><ref id="spooldirperms" name="spool&lowbar;dir&lowbar;perms"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  spool directory permissions <newline>
<tt><ref id="spoolfileperms" name="spool&lowbar;file&lowbar;perms"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  spool file permissions <newline>
<tt><ref id="spreadjobs" name="spread&lowbar;jobs"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  amount to spread jobs to avoid collisions <newline>
<tt><ref id="ss" name="ss"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  name of queue that server serves (with sv) <newline>
<tt><ref id="stalledtime" name="stalled&lowbar;time"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  time after which to report active job stalled <newline>
<tt><ref id="stoponabort" name="stop&lowbar;on&lowbar;abort"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  stop processing queue on filter abort <newline>
<tt><ref id="stty" name="stty"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  stty commands to set output line characteristics <newline>
<tt><ref id="sv" name="sv"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  names of servers for queue (with ss) <newline>
<tt><ref id="syslogdevice" name="syslog&lowbar;device"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  name of syslog device <newline>
<tt><ref id="tc" name="tc"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Include indicated printcap entries in current entry<newline>
<tt><ref id="tr" name="tr"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  trailer string to send before closing printer <newline>
<tt><ref id="translateformat" name="translate&lowbar;format"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  translate data format in control file <newline>
<tt><ref id="usedate" name="use&lowbar;date"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  force date in control file <newline>
<tt><ref id="useidentifier" name="use&lowbar;identifier"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  force identifier in control file <newline>
<tt><ref id="useinfocache" name="use&lowbar;info&lowbar;cache"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  read and cache information <newline>
<tt><ref id="usequeuename" name="use&lowbar;queuename"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  put queue name in control file (alias for qq) <newline>
<tt><ref id="useshorthost" name="use&lowbar;shorthost"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Use short hostname for lpr control and data file names <newline>
<tt><ref id="user" name="user"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Effective User ID (EUID) for SUID ROOT programs <newline>
<tt><ref id="waitforeof" name="wait_for_eof"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Wait for EOF on connection <newline>
<!-- END OPTIONS -->
<!-- LPRng-HOWTO SGML format -->
</article>
