## The Master /etc/ifhp.conf File
## Assumes that we are generating output for a HP LaserJet Family Printer
## ifhp.conf.in,v 1.3 2000/04/20 14:12:21 jch Exp
##
## You should define your options in a ifhp.conf file in the spool
## directory,  or use the printcap ifhp=.... entry to get the options
## Comment have ## or #-- at the start of the line
##  commented out options have only # at the start of line

# PRINTER default - HP 4M Plus - PostScript, PJL, PCL Support, PJL Support
# PRINTER         - PJL for HP 4 Family
# PRINTER         - bidirectional connection with status and pagecount reporting

#--- START debugging setup
## turn debugging on
# debug=5
## specify a specific file for output
#dev=/tmp/d
## specify a network connection
# dev=astart14%9100
## specify a serial line
# dev=/dev/ttya
#stty=38400 -echo -crmod -raw -oddp -evenp ixon pass8 -ixany cbreak

## put trace output on STDERR
# trace
## specify status file for testing
#--- END debugging setup

## The summary file really slows down operation as it requires
## a file system sync each time.  Writing to a UDP socket is very
## fast
# summaryfile=summary

## Status file location and limits in K bytes
##
# statusfile=status
statusfile_max=8
statusfile_min=2

#--- START language setup
## default is to turn everything on
pjl
pcl
ps
text
## do LF to CRLF translation
# crlf

## These are for very ugly printers that have some strange problems
##  with PCL and PS end of job at the start of jobs.  If it is present,
##  the PJL settings are ignored,  or the rest of the job may be
##  ignored.  This also happens when you use a Microsoft product and the
##  print driver puts ^D at the start of PostScript jobs.  You have been
##  warned.
##
## Do NOT put PCL EOJ at start of job when PCL supported
# no_pcl_eoj
# 
## Do NOT put PS EOJ at start of PS when PS is being printed
# no_ps_eoj

## Some printers get very upset when PostScript jobs contain ^T or ^C
## characters.  You can remove various control character by setting
## their values in this string:
##  remove_ctrl=TC   will remove CTRL-T and CTRLC characters
##  This is only done for PostScript jobs.
##
# remove_ctrl=TC
# 

## Some printers insist on using the Tagged Binary Commmunication Protocol
## to support sending embedded PS file.  If you need to use TBCP, enable this.
## This flag is inherently evil,  and is for desperate uses only,
## and should not be generally enabled. 
##
## If you don't know what this is about,  don't mess with it.
##    You, as they say,  have been warned.
##
# tbcp

#--- END lanuage setup


#--- START accounting extra information
##  For those little moments of quiet desperation when you need to have the
##  actual printing filter do some accounting.  Why?  because you may need to
##  check with some specialized database,  update the information in it.
##
## Again,  this is inherently evil,  and is for desperate sysadmins who are
## trying to placate the bean counters in administration...
## If you don't know what this is about,  don't mess with it.
## You, as they say,  have been warned.  Also,  read the source code
## as well.
##

##
## accounting script
# accounting=accounting.sh
#--- END accounting extra information

#--- START printer status, sync, and pagecount
## information reporting
## status@ will suppress any reading of status information.  This can
##  have ugly side effects if your programs send status back on a TCP/IP
##  link,  it is not read,  the printers output buffer becomes full,
##  and the printer will lock up.  Use this ONLY if you must.
##  If you want the effects of status@,  but do not want to 'actively'
##  expect status back,  use sync@,pagecount@ instead
##
status

## sync@     - no sync
## sync      - if pjl availble us it, then if ps available use it
##             this is best method to sync
## sync=ps   - use ps method
## sync=pjl  - use pjl method
sync
## try sending sync at these intervals
#
sync_interval=20

## pagecount@     - no sync
## pagecount      - if pjl availble us it, then if ps available use it
##             this is best method to sync
## pagecount=ps   - use ps method
## pagecount=pjl  - use pjl method
pagecount
##  If your printer does not have a reliable way to determine that
## the last job has finished,  you can 'poll' it at intervals.
## The page count will be sampled at 'pagecount_poll' intervals
## until it is stable.
##  This is for desperation only
#pagecount_poll=5

##  You may need to periodically resend the pagecount command
## if you do not get a response.  This will do so.  You may have problems
## with jobs that take a very long time to process and which do not have
## reliable 'end of job' indications.

pagecount_interval=20

##  We will send a 'sync' query at then end of job to determine if a job has
##  finished.  However, if you do not want to do this, then set
##  waitend@ . Suppressing waitend is DANGEROUS if you expect to
##  get error status back.  You can also set waitend=ps to force
##  using a small PostScript job to be run to indicate that the processing
##  of the job has been completed.  Unfortunately,  this will only tell
##  about the print engine.  You will also have to use end_ctrl_t to force
##  the printing status to be delivered
waitend

##  When you use waitend=ps (or have a PostScript only printer),  you can
##  send a ^T (control T) to ask the printer for status.  This will cause
##  the actual printer status to be returned.  If it is one of the listed
##  values,  then it indicates that the last page has been printed.
##  This value can be a comma or colon separated list of (lowercase)
##  values,  and is searched using the 'strstr()' function for a match.
##  You can also use the !value to indicate that when this value does NOT
##  occur as a status,  then you have a done condition.  For example,
##  !printing will accept any status BUT printing as a done condition.
end_ctrl_t=busy:idle

##  If you are getting status using postscrip

## interval to send queries - this can be pretty long as many times
##  you will need to wait until the job finishes.  You do not want to
##  send too many of these
##
waitend_interval=300

## interval between PostScript CTRL_T queries after you have gotten
## a response from the printer that it is finished with the previous
## job.  Used only if end_ctrl_t has a non-null value,  and after a
## small PostScript job has been processed that sends back an echo
## response.  You may find that these CTRL_T's may get ignored if
## the PostScript engine is busy,  so do not send too fast
waitend_ctrl_t_interval=3

## how often to report progress - minimum of percent or
##  amount written (in Kbytes)
##  report when you have done this much more percent of the job
progress_pc=25
##  report when you have done this much more Kbytes of job
progress_k=1000

#--- END printer status, sync, and pagecount

#--- START OF Banner
##  If we want to have the ifhp filter generate a banner,
##  then we need to specify what format for the banner
##  This is ugly, ugly, ugly.
##  I don't know why I did this,  given that LPRng does better
##  banners.  This may come out
#banner=ps
#banner=pcl
banner@
banner_file=@FILTERDIR@/psbanner.ps
#--- END OF Banner


## START PJL configuration

## only allow these PJL commands
##
pjl_only=[
    COMMENT DEFAULT DINQUIRE ECHO ENTER EOJ
    FSAPPEND FSDIRLIST FSQUERY FSUPLOAD FSDELETE FSDOWNLOAD FSINIT FSMKDIR
    INFO INITIALIZE INQUIRE JOB OPMSG PJL RDYMSG
    RESET SET STMSG USTATUS USTATUSOFF
## special builtins that expand variables correctly
    COPIES
  ]

## do NOT allow these PJL commands, even if they are in pjl_only
pjl_except=[ ]

## BUILTIN PJL Support
##  pjl_enter - printer supports language selection
pjl_enter
##  pjl_job -   printer supports PJL JOB 
pjl_job
##  pjl_console -   printer supports PJL console setting 
pjl_console

## expand the following on startup,  after the builtin
pjl_init=[ ustatus teoj ]

## expand the following on termination,  after the builtin
pjl_term=[ ustatus teoj ]

## You can, if you are feeling very odd, force a file
##  to be send as part of the PJL setup
##  1. add setup to pjl_user_opts if you want user specified files
##    specify this with -Tsetup=filename
##  2. put setup=filename in pjl_init=[ ... ] list
##    if you want it permanently set up
##  The setup will get expanded to font_download=filename
##    and the actual file will come from ${pjl_fontdir}/filename
##  This keeps users from downloading /etc/passwd to your printer 

pjl_fontdir=@FILTERDIR@/fonts/pjl
pjl_setup=[ font_download=\%s{setup} ]
## default value for testing or insurance
setup=test

##   PJL USTATUS command string
##    This usually will force job status to be sent at 10
##   second intervals,  which is pretty useful for a keepalive
pjl_ustatus=
    @PJL USTATUSOFF
    @PJL USTATUS JOB = ON
    @PJL USTATUS DEVICE = ON
    @PJL USTATUS PAGE = ON
    @PJL USTATUS TIMED = 10

##   If your printer has 'True End of Job'  then this is useful.
##  The TEOJ is an undocumented option for PJL that forces JOB
##  status to be delayed until the job has been totally printed.
##  Sometimes it works,  usually does not
##
pjl_teoj= @PJL TEOJ = ON


## PJL Variables supposedly supported by HP and others
##  Your milage may vary.  More may be added as time goes on
##  Note:  the pjl_vars_set += [ ... ] format may soon
##  allow additional values to be added

pjl_vars_set= [
    AUTOCONF AUTOSELECT BINDING=LONGEDGE BITSPERPIXEL CLEARABLEWARNINGS
    CONTEXTSWITCH COURIER=REGULAR CPCLOCK DENSITY DISKLOCK
    DUPLEX ECONOMODE FINISH FORMLINES=60
    IMAGEADAPT INTRAY1 INTRAY2 
    INTRAY1SIZE INTRAY2SIZE INTRAY3SIZE INTRAY4SIZE
    INTRAY5SIZE INTRAY6SIZE INTRAY7SIZE INTRAY8SIZE
    IOBUFFER IOSIZE JOBATTR JOBOFFSET
    LANG=ENGLISH LOWTONER MANUALFEED
    MEDIASOURCE MEDIATYPE MPTRAY ORIENTATION=PORTRAIT OUTBIN=UPPER
    OUTLINEPOINTSIZE PAGEPROTECT
    PAPER=LETTER PARALLEL PERSONALITY=AUTO POWERSAVE POWERSAVETIME=30
    PRINTQUALITY=NORMAL QTY=1 RENDERMODE REPRINT=AUTO RESOLUTION
    RESOURCESAVE RESOURCESIZE RET TIMEOUT=600 WIDEA4
  ]

##
## Commands we have created:  upper, lower
## PJL Options we can set: autoselect autoconf
##

pjl_user_opts=[ inupper inlower outupper duplex outlower autoselect
    autoconf transparency setup copies landscape portrait ]

## Your milage may vary on these,  but supposedly most PJL aware
## printers will either support or ignore them
##

pjl_inupper=@PJL SET MEDIASOURCE = TRAY1
pjl_inlower=@PJL SET MEDIASOURCE = TRAY2
pjl_outupper=@PJL SET OUTBIN = UPPER
pjl_outlower=@PJL SET OUTBIN = LOWER
pjl_copies=@PJL SET COPIES = \%d{copies}
pjl_transparency=@PJL SET MEDIATYPE = TRANSPARENCY
pjl_landscape=@PJL SET ORIENTATION = LANDSCAPE
pjl_portrait=@PJL SET ORIENTATION = PORTRAIT

## PJL USTATUS information will include a lot of
## codes that are just not interesting,  such as 'printer on line',
## or 'power up'.  You can suppress reporting status for these codes
## by putting their code numbers in this list

pjl_quiet_codes=[
    10001
  ]

## Special error messages
##  One per line
##  The idea is that you may get an error code,  but you
## it is not 'standard'.  You can add additional codes here
## or override the default strings in the ifhp source.
## 
pjl_error_codes=[
    10006=Toner Low 
  ]

#--- END of PJL

#--- START of PostScript

## PostScript Information
##    WARNING - YOUR POSTSCRIPT PRINTER MAY NOT ACCEPT
##  SOME OF THE COMMANDS HERE.  Check the printer PostScript Printer
##  Description File for details.

## use the following string to cause the printer to echo
## ifhp will replace NAME by a unique identifier to make sure
## that the latest echo was detected

ps_status_code=
    %!PS-Adobe-2.0
## for PS Level 3 add:
#   false 0 startjob pop
    ( %%[ echo: NAME ]%% ) print () = flush

##  PageCount
##   This is a very nasty piece of PostScript that will
##  get the current pagecount value out of the statusdict
##  Note: you really should use the PS Level 3 if you have it
##  Note: some printers INSIST on ignoring the startjob stuff,
##    and will report the current pagecount.  You sometimes need
##    to sit in a loop and wait until it stops changing.
##    See pagecount_interval and pagecount_timeout

ps_pagecount_code=
    %!PS-Adobe-2.0
## for PS Level 3 add:
#   false 0 startjob pop
    /p{print}def ( %%[ pagecount: ) p
    statusdict begin pagecount end 20 string cvs p
    ( ]%% ) p () = flush

## PostScript options allowed by -T or -Z
##

ps_user_opts=[ manual inupper inlower outupper outlower envelope mediaselect
    simplex duplex duplexshort font transparency
    letter legal ledger oversize a3 a4 a5 lduplex sduplex
  ]

## support for font download
##  use:  -Tfont=name1,font=name2
##  This will get expanded to fontdownload 
##  and fontdownload will get the ${font} value set by font=
##  the ps_fontdir value will be prefixed,  and
##   ${ps_fontdir}/name1  and ${ps_fontdir}/name2 will be downloaded
##  to the printer
##   
ps_fontdir=@FILTERDIR@/fonts/ps
ps_font=[ font_download ]


## Support for PostScript based page settings 
## YOU NEED TO CHECK YOUR PPD FILE FOR THIS STUFF
##
ps_duplexshort=  [ sduplex ]
ps_duplex=   statusdict begin true setduplexmode false settumble end
ps_lduplex=  statusdict begin true setduplexmode false settumble end
ps_sduplex=  statusdict begin true setduplexmode true settumble end
ps_simplex=  statusdict begin false setduplexmode end
ps_inupper=  statusdict begin 0 setpapertray end
ps_inlower=  statusdict begin 1 setpapertray end
ps_manual=   statusdict begin /manualfeed true store end
ps_envelope= statusdict begin com10envelopetray end
ps_outupper= statusdict begin 0 setoutputtray end
ps_outlower= statusdict begin 1 setoutputtray end
ps_transparency= <</MediaType (Transparency)>> setpagedevice

mediaselect=3
ps_mediaselect=<</DeferredMediaSelection true /MediaPosition \%d{mediaselect}>> setpagedevice


#--- END PostScript

#--- START PCL


##   Initialization

pcl_user_opts=[
    bold clearmargins courier crlf delete_fonts duplex duplexback
    duplexfront duplexselect duplexshort fixed font font_id
    font_op font_primary height helvetica hmi init
    init inlower inupper italic jobseparation landscape leftmargin
    leftoffset lineprinter linesperpage linewrap lpi manual normalpage
    orientation outlower outupper pc8 pagesize pitch portrait proportional
    rightmargin simplex source style symbol_set topmargin topoffset
    typeface user_opts vmi weight
    pagesize letter legal ledger a3 a4 a5
  ]

## turn LF into CRLF
pcl_crlf=\033&k2G
## turn line wrap on
pcl_linewrap=\033&s0C

## page (job) size
##  use -Zpagesize=n
## 1 - executive, 2 - letter, 3 - legal, 6 - ledger, 25 - A5, 26 - A4, 27 - A3
## 80 - Monarch Envelope, 81 - Comm. 10 Envelope, 90 - Intl. DL Envelope
## 91 - Intl. C5 Envelope, 100 - Intl. D5 Envelope, 101 - Custom
## 71 - Hagaki Postcard, 72 - Oufuku-Hagaki Postcard
pagesize=2
pcl_pagesize=\033&l\%d{pagesize}A
pcl_letter=\033&l2A
pcl_legal=\033&l3A
pcl_ledger=\033&l6A
pcl_a5=\033&l25A
pcl_a4=\033&l26A
pcl_a3=\033&l27A

## paper source selection
##   use -Zsource=n
## 0 - current, 1 - upper, 2 - manual paper, 3 - manual envelope
## 4 - lower,   5 - optional paper  - 6 - optional manual
source=0
pcl_source=\033&l\%d{source}H
pcl_inupper=\033&l1H
pcl_manual=\033&l2H
pcl_inlower=\033&l4H

## orientation
##  0 - portrait, 1, landscape, 2 - reverse portrait, 3 reverse landscape
pcl_orientation=\033&l\%d{orientation}O
pcl_portrait=\033&l0O
pcl_landscape=\033&l1O

## simplex or duplex
##  0 - simplex,  1 - duplex long edge, 2 - duplex short edge
pcl_simplex=\033&l0S
pcl_duplex=\033&l1S
pcl_duplexshort=\033&l2S

## offsets
##  these are specified in 1/720 inch units
##  i.e. - if you want 1/2 inch, you need  720 x .5 = 360 units
leftoffset=0
pcl_leftoffset=\033&l\%d{leftoffset}U
topoffset=0
pcl_topoffset=\033&l\%d{topoffset}Z

## duplex page side selection
duplex_select=1
pcl_duplexselect=\033&a\%d{duplexselect}G
pcl_duplexfront=\033&a1G
pcl_duplexback=\033&a2G

## job separaton
pcl_jobseparation=\033&l1T

## output bin 
## 0 - auto, 1 - bin 1,top/facedown 2 - bin 2,left/faceup
## 3 - bin 3 (HCO faceup)
## 4 - bin 4 (HCO 1, facedown)
## 5 - bin 5 (HCO 2, facedown)
## 6 - bin 6 (HCO 3, facedown)
## 7 - bin 7 (HCO 4, facedown)
## 8 - bin 8 (HCO 5, facedown)
## 9 - bin 9 (HCO 6, facedown)
## 10 - bin 10 (HCO 7, facedown)
## 11 - bin 11 (HCO 8, facedown)

outbin=1
pcl_outbin=\033&l\%d{outbin}G
pcl_outupper=\033&l1G
pcl_outlower=\033&l2G

## margins
pcl_clearmargins=\0339
leftmargin=0
pcl_leftmargin=\033&a\%d{leftmargin}L
rightmargin=80
pcl_rightmargin=\033&a\%d{rightmargin}M
topmargin=0
pcl_topmargin=\033&l\%d{topmargin}E
linesperpage=66
pcl_linesperpage=\033&l\%d{linesperpage}F

## the HMI (Horizontal Motion Index)
##  this is dangerous...
##  This is the number of 1/120 inch unit per character
##  i.e. - 120 unit per inch
##  If you want 10 cpi, you want HMI = 120/10 = 12
hmi=12
pcl_hmi=\033&k\%d{hmi}H

## the VMI (Vertical Motion Index)
##  this is dangerous...
##  This is the number of 1/48 inch unit per line
##  i.e. - 48 unit per inch
##  If you want 6 lines per inch, you want HMI = 48/6 = 8
vmi=8
pcl_vmi=\033&l\%d{vmi}C

## the LPI (Lines Per Inch) - inverse of VMI
##  This is the lines per line
##  If you want 6 lines per inch, you want LPI = 6
lpi=6
pcl_lpi=\033&l\%d{lpi}D

## symbol set
##  - don't fool around with this one...
## 10U = PC 8 - shows the funny PC characters???
##
symbol_set=8U
pcl_symbol_set=\033(\%s{symbol_set}
pcl_pc8=\033(10U

## spacing
##  0 - fixed, 1 - proportional
pcl_fixed=\033(s0P
pcl_proportional=\033(s1P

## pitch for fixed spaced font
##  in characters per inch
pitch=10
pcl_pitch=\033(s\%3.2f{pitch}H

## height for proportional spaced font
##  in points
height=10
pcl_height=\033(s\%3.2f{height}V

## style for proportional spaced font
##  0 - normal, 1 - italic, 4 condensed, etc
style=0
pcl_style=\033(s\%d{style}S
pcl_italic=\033(s1S


## weight -
##  ranging from -7 (ultra thin) to 7 (ultra black)
weight=0
pcl_weight=\033(s\%d{weight}B
pcl_bold=\033(s3B

## Typeface Family
## See Appendic C in the PCL 5 comparison guide
##   consists of foundary * 4096 + fontid
##   foundary = 1 - AGFA, 2- Bitstream, etc 
##   fontid   = 0 - line printer, 3 = courier, 4 = helvetica
##   id 4099 - Courier
##      4100 - Helvetica
##
typeface=4099
pcl_typeface=\033(s\%d{typeface}T
pcl_courier=\033(s4099T
pcl_helvetica=\033(s4100T
pcl_lineprinter=\033(s0T


##
## Fonts and Font Downloading
##  fontid is used to set the current font
font_id=1
pcl_font_id=\033*c\%d{font_id}D
## set primary font
font_primary=1
pcl_font_primary=\033(\%d{font_primary}X

## font control
##
font_op=0
pcl_font_op=\033*c\%d{font_op}F
pcl_delete_fonts=\033*c0F

## font directory
font=c1201b.10
pcl_fontdir=@FILTERDIR@/fonts/pcl

## combination command
pcl_font=[ delete_fonts font_id font_download font_primary ]

## canned setup
pcl_normalpage=[ letter crlf linewrap portrait clearmargins fixed pitch=10 courier ]

pcl_init=[ normalpage ]

##
## Text and Incompatible file type conversion control
##
##  Problem:  you get files of very odd type and want to print
##   them,  but you need a converter program to do so
##
## Step 0:  set default file language type.  This is used if the
##   the language type is explicitly determined.
##    default_language=unknown
##
## Step 1:  determine file type
##
##  Method 1 - SIMPLE, BUT LIMITED - let ifhp detect the file type
##  this will be pjl, ps, text, or unknown
##  (option: forceconversion@)
##
##  Method 2 - POWERFUL, BUT MORE COMPLEX
##   Use the file util to find the file type
##       - the utility output converted to lower case and 
##       all white space (blanks, tabs, LF, HT, etc) are replace
##       by spaces
##  (option: forceconversion)
##
## Step 2:  do conversion
##
## rasterizer=
## file_output_match = [
##   *pcl*        pcl \%s{pcl_converter}
##   *ps*         ps  \%s{ps_converter}
##   *postscript* ps  \%s{ps_converter}
##   *pjl*        pjl \%s{pjl_converter}
## # if your printer understands PCL, use the next line
## # *text*       pcl \%s{pcl_converter}
## # if your printer only understands PostScript, use the next line
##   *text*       ps  \%s{text_converter}
##   *%20gif%20*  pcl /usr/local/bin/gif2pcl --autosize -x 2400 -y 3300 -d=300 -o-
##   *            unknown
## # for rasterizing
## # if you need to rasterize, use: 
##   *text*       raw  \%s{text_converter}
##   *ps*         raw  \%s{ps_converter}
##   *postscript* raw  \%s{ps_converter}
## ]
##   *text*       ps  /usr/local/bin/a2ps -q -B -1 -M Letter --borders=no -o-
##   ^^^ glob match
##                ^^ result type
##                    ^^ optional conversion program
##
## 
## We match the (method 1) determined file type file or (method 2)
## file utility output against a 'glob' pattern.  This pattern is URL
## encoded so that it can include spaces or other characters.
## 
## The if there is a match,  the resulting conversion type is set to
## the second entry.  If this is 'unknown', then the file is not
## printed.
##
## The third entry (and rest of line) is the conversion program and
## options to use.  As shown above, this can be an option whose
## value is expanded and substituted.  For example:
##
## ps_converter= [ @GS@ -dSAFER -dBATCH -q -sDEVICE=\%s{device}
##    \%s{resolution} -sOutputFile=- -
##  ]
##
## text_converter= [
##    @A2PS@ -q -B -1 -M Letter --borders=no -o-
##    | \%s{ps_converter}
##  ]
##
## If no conversion is specified,  then the original
## file is used.  If the program has pipe or meta characters,  then
## it is executed using /bin/sh -C 'program spec',   allowing you to
## pipe output of one program to another.
## 
##  The converter program command line ZOPTS and TOPTS words are replaced with
##  the values of the -Z flag and options and -T flag and options respectively,
##  and the ARGV word with the entire set of ifhp filter command line options.
##  For example,  if the filter was /usr/local/bin/mystuff ZOPTS
##  and you did lpr -Zlandscape,  then you would get
##     /usr/local/bin/mystuff -Zlandscape.
##  This allows you to pass options to the converter
##
##  The conversion program exit status must be 0 for successful conversion.
##  Please note that programs such as a2ps and enscript exit with non-zero
##  exit status when they perform conversions correctly but need to wrap lines,
##  or have some minor difficulty with non-ascii characters in the input.
##  The use of a wrapper such as shown below is recommended,  and is the
##  default with ifhp:
##    #!/bin/sh
##    # /usr.../wrapper path [options]
##    # wrapper script for a2ps, enscript and others
##    #   path is the path to the program and options are the
##    #   options to pass.  The program is run and then the exit
##    #   code is corrected
##    program=$1
##    status=1;
##    shift
##    if test -n "$program" ; then
##    	$program "$@"
##    	status=$?
##    fi;
##    case "$status" in
##    	1 ) exit $status;;
##    esac
##    exit 0
## 
##  Spaces in the file utility output can be matched with %20
##  (URL escaped space)
## 
##  file - utility to determine file type
##     ftp://ftp.astron.com/pub/file/
##     ftp.deshaw.com/pub/file/
##     Also available from the RedHat.com SRPMS in (of course) rpm format

# set forceconversion to force the file(1) utility to be used
default_language=text
forceconversion@

##  UNIX File utility path
file_util_path=/usr/bin/file -
##  Patterns and Converters
# example conversion program
file_output_match = [
  *postscript*  ps  \%s{ps_converter}
  *pcl*         pcl  \%s{pcl_converter}
  *pjl*         pjl  \%s{pjl_converter}
  *printer*job*language* pjl
#  if your printer has PCL, use:
  *text*  pcl  \%s{pcl_converter}
#  if your printer does not have PCL, use:
#  *text*  pcl  \%s{text_converter}
  ]

# device=epsonc
# resolution=-r240x72
# ps_converter= [ @GS@ -dSAFER -dBATCH -q -sDEVICE=\%s{device}
#   \%s{resolution} -sOutputFile=- -
# ]
#
ps_converter=
pcl_converter=
pjl_converter=
# text_converter= [
#  @A2PS@ -q -B -1 -M Letter --borders=no -o-
#  | \%s{ps_converter}
# ]
text_converter=


## you may need a temp file location
##
##  This will be extended to ..ifhpXXXXX
##   for use by the unix mktemp() routine
##
tempfile=/var/tmp/ifhp

## Printer Specific Configurations

## Apple or PostScript Printers
# PRINTER apple postscript ps - PostScript Only printer with text to PostScript via a2ps
# PRINTER                     - bidirectional connection with status and pagecount reporting
[ apple postscript ps ]
pjl@
pcl@
ps
text@
file_output_match = [
  *postscript*  ps
#  if your printer does not handle text but has PS, use:
  *text*  ps @A2PS@ -q -B -1 -M Letter --borders=no -o-
  ]


## PCL Only Printer
# PRINTER pclonly - PCL only printer, no accounting or status
[ pclonly pcl ]
pjl@
pcl
ps@
text@
file_output_match = [
  *pcl*  pcl
#  if your printer does not handle text but has PS, use:
  *text*  pcl
 ]

# PRINTER pcl_ps_conversion - PCL only printer with GhostScript conversion
[ pcl_ps_conversion ]
pjl@
pcl
ps@
text@
device=ljet4
file_output_match = [
  *pcl*  pcl
  *text*  pcl
  *postscript*  pcl @GS@ -dSAFER -q -sDEVICE=\%s{device} \%s{resolution} -sOutputFile=- -
 ]

# PRINTER ghostscript - Printer with GhostScript conversion to raster files
[ ghostscript gs ]
pcl@
pjl@
ps
text

# device=epsonc
# resolution=-r240x72
ps_converter= [ @GS@ -dSAFER -dBATCH -q -sDEVICE=\%s{device}
   \%s{resolution} -sOutputFile=- -
 ]
text_converter= [ @A2PS@ -q -B -1 -M Letter --borders=no -o-
  | \%s{ps_converter}
 ]

file_output_match = [
  *postscript*  raw  \%s{ps_converter}
#  if your printer has PCL, use:
  *text*  raw  \%s{text_converter}
  ]

## HP Printers
## These all support PJL to a limited extent and PCL as well
## This assumes that you have a PostScript Cartridge
### 
# PRINTER hpiisi - HP LaserJet III si, default with limited PJL capability
[ hpiiisi hp3si ]
pjl_only=[
    COMMENT ENTER
  ]

# PRINTER hp4 hp4m hp4si hp4simx hp4plus hp4mplus hp4v hp4mv hp4p hp4mp hp4pj hpljpro hp4lc - HP printer, default with limited PJL capabilities
[ hp4 hp4m hp4si hp4simx hp4plus hp4mplus hp4v hp4mv hp4p hp4mp hp4pj hpljpro hp4lc ]
pjl_except=[
    FSAPPEND FSDIRLIST FSQUERY FSUPLOAD FSDELETE FSDOWNLOAD FSINIT FSMKDIR
  ]

#
# Provided by Wilfried.Gaensheimer@infineon.com
#   --- Note: see also the HP5000 and HP8000 entries
# If you know "more", let me (Wilfried.Gaensheimer@infineon.com) know
#
# PRINTER hp4mplus - HP LaserJet 4MPlus
[ hp4mplus ]

pjl_only=[
    COMMENT DEFAULT DINQUIRE ECHO ENTER EOJ
    FSAPPEND FSDIRLIST FSQUERY FSUPLOAD FSDELETE FSDOWNLOAD
    FSINIT FSMKDIR
    INFO INITIALIZE INQUIRE JOB OPMSG PJL RDYMSG
    RESET SET STMSG USTATUS USTATUSOFF
    COPIES
  ]

#
# Some options do not really apply to the hp4mplus
# (I used that entry to try the new 8500 DN, too).
# - select tray (I left all of them in, of course the hp4mplus
#   doesn't have all of them ....)
# - manual feed
# - duplex, shortedge, ....
# - select a4 or letter or legal paper
# - set printquality and/or resolution (I guess that will
#    interact if you use both)
# - select rendermode (does not apply to the hp4mplus ...
#
# If you know "more", let me (wig or Wilfried.Gaensheimer@infineon.com)
# know. Or if I got it wrong (i'm still trying to figure out
# how this works) ... wig
#

pjl_user_opts=[ inupper inlower outupper duplex outlower
    autoselect autoconf transparency setup copies landscape portrait
    paper a4 letter legal
    sduplex mediasource shortedge manual manualfeed
    printquality draft normal high
    resolution 300 600 1200
    rendermode color grayscale ]

#
# wig added these:
#
pjl_duplex=@PJL SET DUPLEX = ON
pjl_sduplex=@PJL SET DUPLEX = ON
            @PJL SET TUMBLE = ON
pjl_shortedge=@PJL SET TUMBLE = ON

pjl_paper=@PJL SET PAPER = \%s{paper}
pjl_a4=@PJL SET PAPER = A4
pjl_a3=@PJL SET PAPER = A3
pjl_a0=@PJL SET PAPER = A0
pjl_letter=@PJL SET PAPER = letter
pjl_legal=@PJL SET PAPER = legal

pjl_resolution=@PJL SET RESOLUTION = \%d{resolution}
pjl_300=@PJL SET RESOLUTION = 300
pjl_600=@PJL SET RESOLUTION = 600
pjl_1200=@PJL SET RESOLUTION = 1200
pjl_mediasource=@PJL SET MEDIASOURCE = \%s{mediasource}
pjl_manual=@PJL SET MANUALFEED = ON
pjl_manualfeed=@PJL SET MANUALFEED = ON

pjl_printquality=@PJL SET PRINTQUALITY = \%s{printquality}
pjl_draft=@PJL SET PRINTQUALITY = DRAFT
pjl_normal=@PJL SET PRINTQUALITY = NORMAL
pjl_high=@PJL SET PRINTQUALITY = HIGH

pjl_rendermode=@PJL SET RENDERMODE = \%s{rendermode}
pjl_color=@PJL SET RENDERMODE = COLOR
pjl_grayscale=@PJL SET RENDERMODE = GRAYSCALE


# PRINTER hp4m - HP LaserJet 4M, has limited pagecount capability
[ hp4m ]
pagecount=ps

# PRINTER hp4v hp4mv - HP LaserJet 4M, 4MV
[ hp4v hp4mv ]
# Paper Selection By Size
ps_letter= <</DeferredMediaSelection true /PageSize [612 792] /ImagingBBox null>> setpagedevice
ps_legal= <</DeferredMediaSelection true /PageSize [612 1008] /ImagingBBox null>> setpagedevice
ps_ledger=<</DeferredMediaSelection true /PageSize [792 1224] /ImagingBBox null>> setpagedevice
ps_oversize=<</DeferredMediaSelection true /PageSize [842 1274] /ImagingBBox null>> setpagedevice
ps_a3 = <</DeferredMediaSelection true /PageSize [842 1191] /ImagingBBox null>> setpagedevice
ps_a4 = <</DeferredMediaSelection true /PageSize [595 842] /ImagingBBox null>> setpagedevice


# PRINTER hp4l hp5l hp6l - HP LaserJet 4L, 4L, 6L
[ hp4l hp5l hp6l ]
pjl_except=[
    EOJ JOB OPMSG RDYMSG STMSG
    FSAPPEND FSDIRLIST FSQUERY FSUPLOAD FSDELETE FSDOWNLOAD FSINIT FSMKDIR
  ]

# PRINTER  hp4ml hp5p hp5mp hp6p hp6mp - HP LaserJet 4ML, 5P, 5MP, 6P, 6MP
[ hp4ml hp5p hp5mp hp6p hp6mp ]
pjl_except=[
    OPMSG RDYMSG STMSG
    FSAPPEND FSDIRLIST FSQUERY FSUPLOAD FSDELETE FSDOWNLOAD FSINIT FSMKDIR
  ]

# PRINTER hp5 hp5si hp5simx hp5m - HP LaserJet 5, 5Si, 5SiMX, 5M
## HP 5SiMX
## You may need to change tray1 to letter and tray2 to ledger
## if you are using trays with different media
##
[ hp5 hp5si hp5simx hp5m ]

# There may be problems with the copypage and EOJ interaction
#ps_init = [ nocopypage ]
#ps_nocopypage = /copypage {showpage} def

pjl_except=[
    FSAPPEND FSDIRLIST FSQUERY FSUPLOAD
  ]


ps_manual=<</ManualFeed true>> setpagedevice
ps_envelope=<</DeferredMediaSelection true /MediaPosition 2>> setpagedevice


ps_inupper=[ tray1 ]
ps_inlower=[ tray2 ]

## *InputSlot Tray1/Tray 1:
ps_tray1=<</DeferredMediaSelection true /MediaPosition 3>> setpagedevice

##InputSlot Tray2/Tray 2: 
ps_tray2=<</DeferredMediaSelection true /MediaPosition 0>> setpagedevice

##InputSlot Tray3/Tray 3: 
ps_tray3=<</DeferredMediaSelection true /MediaPosition 1>> setpagedevice

##InputSlot Tray4/Tray 4: 
ps_tray4=<</DeferredMediaSelection true /MediaPosition 4>> setpagedevice


# Paper Selection By Size
ps_letter= <</DeferredMediaSelection true /PageSize [612 792] /ImagingBBox null>> setpagedevice
ps_legal= <</DeferredMediaSelection true /PageSize [612 1008] /ImagingBBox null>> setpagedevice
ps_ledger=<</DeferredMediaSelection true /PageSize [792 1224] /ImagingBBox null>> setpagedevice
ps_oversize=<</DeferredMediaSelection true /PageSize [842 1274] /ImagingBBox null>> setpagedevice
ps_a3 = <</DeferredMediaSelection true /PageSize [842 1191] /ImagingBBox null>> setpagedevice
ps_a4 = <</DeferredMediaSelection true /PageSize [595 842] /ImagingBBox null>> setpagedevice


## *OutputBin Upper/Top Output Bin (Face Down):
##ps_outupper=<</Staple 0 /OutputType (TOP OUTPUT BIN)>> setpagedevice
## *OutputBin Left/Left Output Bin (Face Up):
##ps_outlower=
##   currentpagedevice /OutputAttributes get
##   5 known
##         {<</Staple 0 /OutputType (FACE UP BIN)>> setpagedevice}
##         {<</Staple 0 /OutputType (LEFT OUTPUT BIN)>> setpagedevice}
##       ifelse
##
## *OutputBin Stacker/Stacker (Face Down):
ps_outbin2=<</Staple 0 /OutputType (OPTIONAL OUTBIN 2)>> setpagedevice

## *OutputBin Separator/Job Separator (Face Down): 
ps_outbin3=<</Staple 0 /OutputType (OPTIONAL OUTBIN 2)>> setpagedevice

## *OutputBin Stapler/Stapler (Face Down):         
ps_outbin4=<</Staple 2>> setpagedevice

## *OutputBin OutputBin1/Mailbox 1 (Face Down):    
ps_outbin5=<</Staple 0 /OutputType (OPTIONAL OUTBIN 2)>> setpagedevice

## *OutputBin OutputBin2/Mailbox 2 (Face Down):    
ps_outbin6=<</Staple 0 /OutputType (OPTIONAL OUTBIN 3)>> setpagedevice

## *OutputBin OutputBin3/Mailbox 3 (Face Down):    
ps_outbin7=<</Staple 0 /OutputType (OPTIONAL OUTBIN 4)>> setpagedevice

## *OutputBin OutputBin4/Mailbox 4 (Face Down):    
ps_outbin8=<</Staple 0 /OutputType (OPTIONAL OUTBIN 5)>> setpagedevice

## *OutputBin OutputBin5/Mailbox 5 (Face Down):    
ps_outbin9=<</Staple 0 /OutputType (OPTIONAL OUTBIN 6)>> setpagedevice

## *Duplex None/Off: 
ps_simplex=
     <</Duplex false /Tumble false>> setpagedevice
## *Duplex DuplexNoTumble/Long-Edge Binding: 
ps_duplex=
     <</Duplex true /Tumble false>> setpagedevice
## *Duplex DuplexTumble/Short-Edge Binding: 
ps_duplexshort=
     <</Duplex true /Tumble true>> setpagedevice

# PRINTER hp5simopier hp4000 - HP LaserJet 5 Si Mopier, HP4000
[ hp5simopier hp4000 ]
pjl_except= [
  ]

# PRINTER hpcolorlj hpcolorlj5 hpcolorlj5m - HP Color LaserJet, LJ5, LJ5m, default with restricted PJL capability
[ hpcolorlj hpcolorlj5 hpcolorlj5m ]
pjl_only=[
    COMMENT ECHO ENTER EOJ
    INFO INITIALIZE INQUIRE JOB PJL RDYMSG
    USTATUS USTATUSOFF
  ]

# PRINTER hpdj1200c hppjxl300 - HP Design Jet 1200C, HP Paint Jet XL 300
[ hpdj1200c hppjxl300 ]
pjl_only=[
    COMMENT ENTER
    PJL
  ]
status@

# PRINTER hpdj1600c hpdj1600cm - HP Design Jet 1600C and 1600CM

[ hpdj1600c hpdj1600cm ]
pjl_only=[
    COMMENT DEFAULT DINQUIRE ECHO ENTER EOJ
    JOB PJL
    RESET SET
  ]

# PRINTER hpdj200 hpdj220 hpdj600 hpdj650c - HP DeskJet 200, 220, 600, 650c

[ hpdj200 hpdj220 hpdj600 hpdj650c ]
pjl_only=[
    COMMENT ECHO ENTER
    INFO 
    USTATUS USTATUSOFF
  ]

# PRINTER hpdj230 hpdj250c hpdj330 hpdj350c hpdj430 hpdj450c hpdj455ca hpdj700 hpdj750c hpdj750cplus hpdj755cm hpdj2000cp - HP DeskJet 230, 250C, 330, 350C, 430, 450C, 455Ca, 700, 750C, 750Cplus, 755Cm, 2000Cp
[ hpdj230 hpdj250c hpdj330 hpdj350c hpdj430 hpdj450c hpdj455ca hpdj700 hpdj750c hpdj750cplus hpdj755cm hpdj2000cp ]
pjl_only=[
    COMMENT ECHO ENTER EOJ
    INFO JOB RESET SET
    USTATUS USTATUSOFF
  ]


# PRINTER hpdj2500cp - HP DesignJet 2500CP

[ hpdj2500cp ]
# Supplied by: Wilfried.Gaensheimer@infineon.com
# my try to get most out of our HP DesignJet 2500 ...
# please let me (Wilfried.Gaensheimer@infineon.com) know when I got it wrong  ...
#wig19990813
#   Modified Patrick Powell Fri Aug 13 11:14:35 PDT 1999

pjl_only=[
    COMMENT ECHO ENTER EOJ
    INFO JOB RESET SET
    USTATUS USTATUSOFF
  ]

# This device does not support pagecount (obvious ...)
pagecount@

#
# According to my copy of the PJL reference guide it supports
# only the DEVICE and the TIMED USTATUS commands ...
# I just don't know what these are for ... ?
#
pjl_ustatus=
    @PJL USTATUSOFF
    @PJL USTATUS DEVICE = ON
    @PJL USTATUS TIMED = 10

#
# setting orientation, printqualtity, rendermode with PJL did not work ...
# I left them in, but PostScript seems to be the better place ...
#
pjl_user_opts=[ 
    autoselect autoconf transparency setup copies landscape portrait
    paper a0 a3 a4 letter legal paperlength paperwidth
    manual manualfeed
    resolution 300 600 1200
    gamma
    ]

#
# DesignJet does not honor these PJLs???
# O.k., so we resort to ps_ (see below) ....
# I left them in because they might work one day ....
#
pjl_paper=@PJL SET PAPER = \%s{paper}
pjl_a4=@PJL SET PAPER = A4
# pjl_a3=@PJL SET PAPER = A3
pjl_a3=@PJL SET PAPERLENGTH = 8420
       @PJL SET PAPERWIDTH = 11910
pjl_a0=@PJL SET PAPER = A0
pjl_letter=@PJL SET PAPER = letter
pjl_legal=@PJL SET PAPER = legal
pjl_paperlength=@PJL SET PAPERLENGTH = \%s{paperlength}
pjl_paperwidth=@PJL SET PAPERWIDTH = \%s{paperwidth}

pjl_orientation=@PJL SET ORIENTATION = \%s{orientation}
pjl_landscape=@PJL SET ORIENTATION = LANDSCAPE
pjl_portrait=@PJL SET ORIENTATION = PORTRAIT

pjl_resolution=@PJL SET RESOLUTION = \%d{resolution}
pjl_300=@PJL SET RESOLUTION = 300
pjl_600=@PJL SET RESOLUTION = 600
pjl_1200=@PJL SET RESOLUTION = 1200

pjl_mediasource=@PJL SET MEDIASOURCE = \%s{mediasource}
pjl_manual=@PJL SET MANUALFEED = ON
pjl_manualfeed=@PJL SET MANUALFEED = ON

pjl_printquality=@PJL SET PRINTQUALITY = \%s{printquality}
pjl_draft=@PJL SET PRINTQUALITY = DRAFT
pjl_normal=@PJL SET PRINTQUALITY = NORMAL
pjl_high=@PJL SET PRINTQUALITY = HIGH

pjl_rendermode=@PJL SET RENDERMODE = \%s{rendermode}
pjl_color=@PJL SET RENDERMODE = COLOR
pjl_grayscale=@PJL SET RENDERMODE = GRAYSCALE
  
#
# We need to use the PostScript options ...
# Some of them might be there because of copy&paste ...
#
#
# The options allow to:
#   - choose manualfeed
#   - choose certain papersizes ( fb is for full bleed)
#   - scale on papersize to another (use -Za4,autoscale_a3)
#   - choose rendermode (color vs. grayscale)
#   - set gamma (defaults to 0.333, allows to reduce intensity
#     for ink based printing of "real" pictures
#   - set orientation
#   - set printquality
#   - set resolution (t.b.d.)
#   
# BTW.: If you want to have a A3 printed in endless paper, combine that
#   with the "landscape" option

ps_user_opts=[ manual envelope mediaselect
    font transparency
    letter legal ledger oversize a3 a4 a5 a4fb a3fb
    autoscale_letter autoscale_a4 autoscale_a3 autoscale_a0 autoscale_36x60
    grayscale color
    gamma
    orientation landscape portrait
    printquality high normal draft fast
    ]

ps_autoscale_letter=/HPDict /ProcSet findresource /SetAutoScale get
        true exch exec /HPDict /ProcSet findresource /SetDestinationPageSize
        get [612 792 ] exch exec <<>> setpagedevice

ps_autoscale_a4=/HPDict /ProcSet findresource /SetAutoScale get
        true exch exec /HPDict /ProcSet findresource /SetDestinationPageSize
        get [595 842] exch exec <<>> setpagedevice

ps_autoscale_a3=/HPDict /ProcSet findresource /SetAutoScale get
        true exch exec /HPDict /ProcSet findresource /SetDestinationPageSize
        get [842 1191] exch exec <<>> setpagedevice

ps_autoscale_a0=/HPDict /ProcSet findresource /SetAutoScale get
        true exch exec /HPDict /ProcSet findresource /SetDestinationPageSize
        get [2384 3370] exch exec <<>> setpagedevice

ps_autoscale_36x60=/HPDict /ProcSet findresource /SetAutoScale get
        true exch exec /HPDict /ProcSet findresource /SetDestinationPageSize
        get [2592 4320] exch exec <<>> setpagedevice

ps_a4=<</PageSize[595 842]/ImagingBBox null>> setpagedevice

# full bleed ...
ps_a4fb=<</PageSize[760 1059]/ImagingBBox null>> setpagedevice

ps_a3=<</PageSize[842 1191]/ImagingBBox null>> setpagedevice

ps_a3fb=<</PageSize[1007 1408]/ImagingBBox null>> setpagedevice

ps_a0=<</PageSize[2384 3370]/ImagingBBox null>> setpagedevice

ps_grayscale=<< /ProcessColorModel /DeviceGray >> setpagedevice

ps_color=<< /ProcessColorModel /DeviceCMYK >> setpagedevice

ps_landscape=userdict /HPCustTrans known
  {
    (<<) cvx exec
    /Orientation
    userdict /HPCustTrans get 
    1 eq 
    { 0 }
    { 1 } ifelse 
    (>>) cvx exec setpagedevice
  }
  {
    <</Orientation 1>> setpagedevice
  } ifelse

ps_portrait=userdict /HPCustTrans known
  {
    (<<) cvx exec
    /Orientation
    userdict /HPCustTrans get 
    (>>) cvx exec setpagedevice
  }
  {
     <</Orientation 0>> setpagedevice
  } ifelse

# set gamma correction to reduce color intensity for InkJets ..
gamma=0.333
ps_gamma={ \%6.3f{gamma} exp } dup dup currenttransfer set colortransfer

ps_printquality=[ \%s{printquality} ]

ps_draft=  << /HWResolution [300 300]
    /PostRenderingEnhance true
    /PostRenderingEnhanceDetails
    << /PrintQuality 1
    /Type 11 >>
    >> setpagedevice

ps_normal= << /HWResolution [300 300]
    /PostRenderingEnhance true
    /PostRenderingEnhanceDetails
    << /PrintQuality 2
      /Type 11 >>
  >> setpagedevice

ps_fast= [ high ]
ps_high= << /HWResolution [600 600]
    /PostRenderingEnhance true
    /PostRenderingEnhanceDetails
    << /PrintQuality 3
      /Type 11 >>
    >> setpagedevice

#
# O.K., here we are the end of the story, at least today ...
#wig19990813
#

##
##  QMS Printers do not seem to return status or other information
##  you may need to configure them to connect on port 35
## printcap 
##  lp:ifhp=model=qms1725,dev=qms.printer.ip.addr%35
##    :lp=/dev/null
##    :if=..../ifhp
##
# Printer qms1725 - QMS 1725, uses appsocket, no status, PostScript only
[ qms1725 ]
appsocket
# no_udp_monitor
status@
qms
pjl@
pcl@
ps
text@

file_output_match = [
  *postscript*  ps
#  if your printer does not handle text but has PS, use:
  *text*  ps @A2PS@ -q -B -1 -M Letter --borders=no -o-
  ]

#*DefaultDuplex: None
#*Duplex None: statusdict begin false setduplexmode false settumble end
ps_simplex=statusdict begin false setduplexmode false settumble end
#*Duplex DuplexNoTumble: statusdict begin true setduplexmode false settumble end
ps_duplex=statusdict begin true setduplexmode false settumble end
#*Duplex DuplexTumble: statusdict begin true setduplexmode true settumble end
ps_lduplex=statusdict begin true setduplexmode true settumble end

#*InputSlot Upper: statusdict begin 1 setpapertray end
ps_inupper=statusdict begin 1 setpapertray end
#*InputSlot Lower: statusdict begin 2 setpapertray end
ps_inlower=statusdict begin 2 setpapertray end
#*InputSlot Envelope: statusdict begin 3 setpapertray end
ps_envelope=statusdict begin 3 setpapertray end

ps_manual=   1 dict dup /ManualFeed true put setpagedevice

#*OutputBin Upper: statusdict begin 1 setoutputray end
#*OutputBin Back: statusdict begin 2 setoutputtray end

ps_outupper= statusdict begin 1 setoutputray end
ps_outlower= statusdict begin 2 setoutputtray end

# QMS 2025 appears to be HP compatible
# QMS 860 has same tray as QMS2025
# Printer qms2025 qms860 qms2060 - QMS 2025, 860, 2060, uses appsocket, no status, PostScript and PCL
[ qms2025 qms860 qms2060 ]
appsocket
# no_udp_monitor
qms
status@
pjl@
pcl
ps
text@
#*PageSize Letter: statusdict begin lettertray end
ps_letter=statusdict begin lettertray end
#*PageSize Legal: statusdict begin legaltray end
ps_legal=statusdict begin legaltray end
#*PageSize Tabloid: statusdict begin 11x17tray end
ps_ledger=statusdict begin 11x17tray end
#*PageSize Executive: statusdict begin executivetray end
ps_executive=statusdict begin executivetray end
#*PageSize A3: statusdict begin a3tray end
ps_a3=statusdict begin a3tray end
#*PageSize A4: statusdict begin a4tray end
ps_a4=statusdict begin a4tray end
#*PageSize A5: statusdict begin a5tray end
ps_a5=statusdict begin a5tray end
#*PageSize B4: statusdict begin b4tray end
ps_b4=statusdict begin b4tray end
#*PageSize B5: statusdict begin b5tray end
ps_b5=statusdict begin b5tray end
#*PageSize B6: statusdict begin b6tray end
ps_b6=statusdict begin b6tray end


## Tektronix Color Printers
##  uses 'appsocket' protcol
##   TCP port 9100
##    receives job status
##   UPD port 9101
##    receives status
##    send a '\r\n' or 0 length packet to UDP port
##    responds with status information
## Sometimes the UDP monitoring is broken - then set
##  no_udp_monitor
##
## printcap entry:
##  lp:cm=Phaser
##    :lp=/dev/null
##    :ifhp=model=tek,dev=10.0.0.1%9100
##    :if=/usr/local/bin/ifhp
##
##  OR
##
##  lp:cm=Phaser
##    :lp=/dev/null
##    :if=/usr/local/bin/ifhp -Tmodel=tek,dev=10.0.0.1%9100
##
##  If you insist on banner pages or need powerful accounting
##  and need an OF filter (NOT recommended with the appsocket protocol),
##  then add (respectively to the above examples):
##
##    :of=/usr/local/bin/ifhp
##  OR
##    :of=/usr/local/bin/ifhp -Tmodel=tek,dev=10.0.0.1%9100
##  

# Printer tek phaser - Tektronics Phaser Color Printer, appsocket, PostScript only
[ tek phaser ]
appsocket
# no_udp_monitor
pjl@
pcl@
ps
sync@

file_output_match = [
  *postscript*  ps
#  if your printer does not handle text but has PS, use:
  *text*  ps @A2PS@ -q -B -1 -M Letter --borders=no -o-
  ]

ps_pagecount_code=%!
  false 0 startjob pop
  (%%[ pagecount: )print statusdict /pagecount get exec (                )cvs
   print
  ( ]%% )= flush
ps_inupper=
  product (Phaser 2) anchorsearch
  { pop pop 2 dict begin
     /InputAttributes 1 dict begin /Priority [0] def currentdict
  end def }
  {  (Phaser 440) anchorsearch
     { pop pop 3 dict begin
         /MediaType (Upper Tray) def
        /MediaColor null def }
    { pop 4 dict begin
        /MediaPosition 0 def
        /MediaType null def
        /ManualFeed false def } ifelse
  } ifelse
  /TraySwitch false def
  currentdict end setpagedevice

ps_transparency=
  mark
  {
    4 dict begin
      /MediaPosition null def
      /MediaType (Transparency) def
      /TraySwitch true def
      /ManualFeed false def
      currentdict end setpagedevice
  } stopped cleartomark

# Printer lexmark4039 - Lexmark 4039, Postscript only
[ lexmark4039 ]

pcl@
pjl@
ps
ps_init=[ set_sync ]

file_output_match = [
  *postscript*  ps
#  if your printer does not handle text but has PS, use:
  *text*  ps @A2PS@ -q -B -1 -M Letter --borders=no -o-
  ]

# Printer hp8100 - HP 8100
[ hp8100 ]

# PCL info:    (paper handling for the HP8100 printer)
#  
# For tray selection:   (paper input)
# 
# Tray 1 =  \e&l4H     (where \e is an esc)
# Tray 2 =  \e&l1H
# Tray 3 =  \e&l5H
# Tray 4 =  \e&l20H
# Tray 5 =  \e&l8H
# Auto Select = \e&l7H
# Manual feed, paper = \e&l2H
# Manual feed, Env.  = \e&l3H
# 
# Paper output to the external stacker:
# 
# 
# LF stacker (top)  \e&l3G
# Stacker 1         \e&l4G
# Stacker 2         \e&l5G
# Stacker 3         \e&l6G
# Stacker 4         \e&l7G
# Stacker 5         \e&l8G
# Stacker 6         \e&l9G
# Stacker 7         \e&l10G
# Stacker 8         \e&l11G
# 

pcl_user_opts=[
    bold clearmargins courier crlf delete_fonts duplex duplexback
    duplexfront duplexselect duplexshort fixed font font_id
    font_op font_primary height helvetica hmi init
    init inlower inupper italic jobseparation landscape leftmargin
    leftoffset lineprinter linesperpage linewrap lpi manual normalpage
    orientation outlower outupper pc8 pagesize pitch portrait proportional
    rightmargin simplex source style symbol_set topmargin topoffset
    typeface user_opts vmi weight
    pagesize letter legal ledger a3 a4 a5
    lf_stacker stacker1 stacker2 stacker3 stacker4 stacker5 stacker6
    stacker7 stacker8
    tray1 tray2 tray3 tray4 autoselect envelope inmiddle inlarge in6
  ]
ps_user_opts=[ manual inupper inlower outupper outlower envelope mediaselect
    simplex duplex duplexshort font transparency
    letter legal ledger oversize a3 a4 a5
    inupper manual inmiddle inlower inlarge tray5
    envelope plain preprinted letterhead transparency prepunched
    labels bond recycled color cardstock rough
  ]

pcl_outupper=\033&l1G
pcl_outlower=\033&l2G
pcl_lf_stacker=\033&l3G
pcl_stacker1=\033&l4G
pcl_stacker2=\033&l5G
pcl_stacker3=\033&l6G
pcl_stacker4=\033&l7G
pcl_stacker5=\033&l8G
pcl_stacker6=\033&l9G
pcl_stacker7=\033&l10G
pcl_stacker8=\033&l11G
pcl_tray1=\033&l4H
pcl_tray2=\033&l1H
pcl_tray3=\033&l5H
pcl_tray4=\033&l20H
pcl_tray5=\033&l8H
pcl_autoselect=\033&l7H
pcl_manual=\033&l2H
pcl_envelope=\033&l3H

ps_inupper=  <</ManualFeed false /MediaPosition 3>> setpagedevice
ps_manual= <</ManualFeed true /MediaPosition 3>> setpagedevice
ps_inmiddle= <</ManualFeed false /MediaPosition 0>> setpagedevice
ps_inlower= <</ManualFeed false /MediaPosition 1>> setpagedevice
ps_inlarge=  <</ManualFeed false /MediaPosition 5>> setpagedevice
ps_tray5=  <</ManualFeed false /MediaPosition 6>> setpagedevice
ps_envelope= <</ManualFeed false /MediaPosition 2>> setpagedevice
ps_plain=  <</ManualFeed false /MediaType (Plain)>> setpagedevice
ps_preprinted= <</ManualFeed false /MediaType (Preprinted)>> setpagedevice
ps_letterhead= <</ManualFeed false /MediaType (Letterhead)>> setpagedevice
ps_transparency= <</ManualFeed false /MediaType (Transparency)>> setpagedevice
ps_prepunched=  <</ManualFeed false /MediaType (Prepunched)>> setpagedevice
ps_labels= <</ManualFeed false /MediaType (Labels)>> setpagedevice
ps_bond= <</ManualFeed false /MediaType (Bond)>> setpagedevice
ps_recycled= <</ManualFeed false /MediaType (Recycled)>> setpagedevice
ps_color= <</ManualFeed false /MediaType (Color)>> setpagedevice
ps_cardstock= <</ManualFeed false /MediaType (Card Stock)>> setpagedevice
ps_rough=  <</ManualFeed false /MediaType (Rough)>> setpagedevice

# PCL Only Support
#  This is seems to handle most printers that
#  do not have PostScript.  -Z options may not work
# PRINTER lj3pclonly - LaserJet 3 with PCL only support
[ lj3pclonly ]
ps@
pjl@
text
pcl
device=ljet3
resolution=
ps_converter= [ @GS@ -q -dSAFER -dBATCH -sDEVICE=\%{device} \%s{resolution} -sOutputFile=- - ]

file_output_match = [
  *postscript*  pcl \%{ps_converter}
  *pcl*         pcl
  *text*        pcl
  ]

# PRINTER hp4500 - HP4500 Printer
#
# submitted by  Klaus Singvogel <ks@lst.de>
#

[ hp4500 ]

pcl_user_opts=[
    bold clearmargins courier crlf delete_fonts duplex duplexback
    duplexfront duplexselect duplexshort fixed font font_id
    font_op font_primary height helvetica hmi init
    init inlower inupper italic jobseparation landscape leftmargin
    leftoffset lineprinter linesperpage linewrap lpi manual normalpage
    orientation pc8 pagesize pitch portrait proportional
    rightmargin simplex source style symbol_set topmargin topoffset
    typeface user_opts vmi weight
    pagesize letter legal ledger a3 a4 a5
    autoselect envelope
  ]
ps_user_opts=[
    simplex duplex duplexshort inupper inlower manual tray1 tray2 tray3
    letter legal executive a4 a5 b5 envb5 env10 envc5 envmonarch plain
    preprinted letterhead transparency glossy prepunched labels bond
    recycled color heavy cardstock
    colorasgray colorascolor cmykinksfast cmykinksswop cmykinkseuro cmykinkstoyo
]

pjl_inupper=@PJL SET MEDIASOURCE = TRAY0
pjl_inlower=@PJL SET MEDIASOURCE = TRAY1
pjl_manual=@PJL SET MANUALFEED = ON
pjl_a4=@PJL SET PAPER = A4

pcl_inupper=\033&l1H
pcl_inlower=\033&l4H
pcl_manual=\033&l2H
pcl_autoselect=\033&l7H
pcl_envelope=\033&l3H

#duplex (optional)
ps_simplex= <</Duplex false /Tumble false>> setpagedevice
ps_duplex= <</Duplex true /Tumble false>> setpagedevice
ps_duplexshort= <</Duplex true /Tumble true>> setpagedevice
#Tray
ps_inupper=  <</MediaPosition 0>> setpagedevice
ps_inlower= <</MediaPosition 1>> setpagedevice
ps_manual= <</ManualFeed true>> setpagedevice
ps_tray1= <</MediaPosition 3>> setpagedevice
ps_tray2= <</MediaPosition 0>> setpagedevice
ps_tray3= <</MediaPosition 1>> setpagedevice
#PageSize
ps_letter= <</PageSize [612 792] /ImagingBBox null>> setpagedevice
ps_legal= <</PageSize [612 1008] /ImagingBBox null>> setpagedevice
ps_executive= <</PageSize [522 756] /ImagingBBox null>> setpagedevice
ps_a4= <</PageSize [595 842] /ImagingBBox null>> setpagedevice
ps_a5= <</PageSize [420 595] /ImagingBBox null>> setpagedevice
ps_b5= <</PageSize [516 729] /ImagingBBox null>> setpagedevice
ps_envb5= <</PageSize [499 709] /ImagingBBox null>> setpagedevice
ps_env10= <</PageSize [297 684] /ImagingBBox null>> setpagedevice
ps_envc5= <</PageSize [459 649] /ImagingBBox null>> setpagedevice
ps_envmonarch= <</PageSize [312 624] /ImagingBBox null>> setpagedevice
#MediaType
ps_plain= <</MediaType (Plain)>> setpagedevice
ps_preprinted= <</MediaType (Preprinted)>> setpagedevice
ps_letterhead= <</MediaType (Letterhead)>> setpagedevice
ps_transparency= <</MediaType (Transparency)>> setpagedevice
ps_glossy= <</MediaType (Gloss)>> setpagedevice
ps_prepunched=  <</MediaType (Prepunched)>> setpagedevice
ps_labels= <</MediaType (Labels)>> setpagedevice
ps_bond= <</MediaType (Bond)>> setpagedevice
ps_recycled= <</MediaType (Recycled)>> setpagedevice
ps_color= <</MediaType (Color)>> setpagedevice
ps_heavy= <</MediaType (Heavy)>> setpagedevice
ps_cardstock= <</MediaType (Cardstock)>> setpagedevice
# Print Color as Gray
ps_colorasgray= <</ProcessColorModel /DeviceGray>> setpagedevice
ps_colorascolor= <</ProcessColorModel /DeviceCMY>> setpagedevice
# CMYK Ink Space
ps_cmykinksfast= << /CMYKInkSet 0 >> setpagedevice
ps_cmykinksswop= << /CMYKInkSet 1 >> setpagedevice
ps_cmykinkseuro= << /CMYKInkSet 2 >> setpagedevice
ps_cmykinkstoyo= << /CMYKInkSet 3 >> setpagedevice

# PRINTER hp5000 - HP5000  Model number: C4111A (LaserJet 5000N)
#
# Hewlett Packard 5000 Series
# Model number: C4111A (LaserJet 5000N)
# Printer short description: Letter/Legal/A4/A3, PostScript Level3
#
# Input taken from
# hp5000_6.ppd
#
# Author: Wilfried.Gaensheimer@infineon.com
# wig19991020
#
# Status: untested
#
# Open Issues:
#
# Implemented commands:
#
# PJL:
#
# paper: A3,A4,Letter,Legal,Ledger/Tabloid/11x17
# resolution: 300/300dpi | 600/600dpi | 1200/1200dpi
# ??bitsperpixel: ( 2 | 1 )
# ??economode: ( ON | OFF )
# 
# Postscript:
#
# ?? collate: ( true | false )
# ?? smoothing: ( true | false )
# pagesize/papersize/paper:
#        letter | executive | legal | ledger/tabloid/11x17 | a3 | a4 | a5
#   not implemented: ....
# inputslot/tray: upper/tray1 | manual/manualfeed | middle/tray2 |
#             lower/tray3 |largecapacity/tray4/large |
# media type: plain | transparency | preprinted
#   not implemented: | letterhead | prepunched | labels | bond | recycled |
#              colorpaper (*) | cardstock | rough
# (*) color in PPD
# ?? scalepattern (not implemented)
# ?? halftone: enhanced | standard (not implemented)
# duplex | sduplex/duplexshort | simplex | shortedge/tumble

[ hp5000 ]

pjl_only=[
    COMMENT DEFAULT DINQUIRE ECHO ENTER EOJ
    FSAPPEND FSDIRLIST FSQUERY FSUPLOAD FSDELETE FSDOWNLOAD
    FSINIT FSMKDIR
    INFO INITIALIZE INQUIRE JOB OPMSG PJL RDYMSG
    RESET SET STMSG USTATUS USTATUSOFF
    COPIES
]
pjl_user_opts=[
	resolution 300 300dpi 600 600dpi 1200 1200dpi
	paper a4 a3 letter legal ledger tabloid 11x17
	duplex simplex sduplex shortedge tumble
	copies
    ]

resolution=300

pjl_resolution=@PJL SET RESOLUTION = \%d{resolution}
pjl_300=[ resolution=300 ]
pjl_600=[ resolution=600 ]
pjl_1200=[ resolution=1200 ]
pjl_300dpi=[ resolution=300 ]
pjl_600dpi=[ resolution=600 ]
pjl_1200dpi=[ resolution=1200 ]

# Taken from 8000 ??
pjl_bitsperpixel=@PJL SET BITSPERPIXEL = \%d{bitsperpixel}

# Taken from 8000 ??
economode=ON
pjl_economode=@PJL SET ECONOMODE = \%s{economode}

pjl_paper=@PJL SET PAPER = \%s{paper}
pjl_a4=@PJL SET PAPER = A4
pjl_a3=@PJL SET PAPER = A3
pjl_executive=@PJL SET PAPER = executive
pjl_letter=@PJL SET PAPER = letter
pjl_legal=@PJL SET PAPER = legal
pjl_ledger=@PJL SET PAPER = ledger
pjl_tabloid=[ ledger ]
pjl_11x17=[ ledger ]

pjl_duplex=@PJL SET DUPLEX = ON
pjl_sduplex=@PJL SET DUPLEX = ON
            @PJL SET TUMBLE = ON
pjl_shortedge=@PJL SET TUMBLE = ON
pjl_tumble=[ shortedge ]
pjl_simplex=@PJL SET DUPLEX = OFF

copies=1
pjl_copies=@PJL SET COPIES = \%d{copies}

ps_user_opts=[
        collate
        smoothing nosmoothing
        pagesize papersize paper letter executive legal tabloid 11x17
            a3 a4 a5
        inputslot tray upper tray1 manual manualfeed middle tray2
            lower tray3 largecapacity large
            tray4
        # halftone enhanced standard
        duplex sduplex duplexshort simplex shortedge tumble
    ]

collate=true
ps_collate=<</Collate \%s{collate}>> setpagedevice

# smoothing: ( true | false )
smoothing=true
ps_smoothing=
   << /PostRenderingEnhance true /PostRenderingEnhanceDetails << /REValue 2 /Type 8 >>
    >> setpagedevice
ps_nosmoothing=
   << /PostRenderingEnhance true /PostRenderingEnhanceDetails << /REValue 0 /Type 8 >>
    >> setpagedevice

#
# Paper size selection ...
#
ps_paper=[ \%s{paper} ]
ps_papersize=[ \%s{papersize} ]
ps_pagesize=[ \%s{pagesize} ]
ps_letter=<</PageSize [612 792] /ImagingBBox null>> setpagedevice
ps_executive=
    <</PageSize [522 756] /ImagingBBox null>> setpagedevice
ps_legal=
    <</PageSize [612 1008] /ImagingBBox null>> setpagedevice
ps_ledger=
  <</PageSize [792 1224] /ImagingBBox null>> setpagedevice
ps_11x17=[ ledger ]
ps_tabloid=[ ledger ]
ps_a3=
    <</PageSize [842 1191] /ImagingBBox null>> setpagedevice
ps_a4=
    <</PageSize [595 842] /ImagingBBox null>> setpagedevice
ps_a5=
    <</PageSize [420 595] /ImagingBBox null>> setpagedevice

#
# inputslot ...
#
ps_tray=[ \%s{tray} ]
ps_inputslot=[ \%s{inputslot} ]
	
ps_upper=<</ManualFeed false /MediaPosition 3>> setpagedevice
ps_tray1=[ upper ]
ps_manual=<</ManualFeed true /MediaPosition 3>> setpagedevice
ps_manualfeed=[ manual ]
ps_middle=<</ManualFeed false /MediaPosition 0>> setpagedevice
ps_tray2=[ middle ]
ps_lower=<</ManualFeed false /MediaPosition 1>> setpagedevice"
ps_tray3=[ lower ]
ps_largecapacity=<</ManualFeed false /MediaPosition 4>> setpagedevice
ps_large=[ largecapacity ]
ps_tray4=[ largecapacity ]

#
# Media type ...
#
ps_plain=<</MediaType (Plain)>> setpagedevice
ps_preprinted=<</MediaType (Preprinted)>> setpagedevice
ps_transparency=<</MediaType (Transparency)>> setpagedevice

#
# Duplex control ..
#
ps_duplex=<</Duplex true>> setpagedevice
ps_sduplex=<</Duplex true /Tumble true>> setpagedevice
ps_duplexshort=[ sduplex ]
ps_simplex=<</Duplex false /Tumble false>> setpagedevice
ps_shortedge=<</Tumble true>> setpagedevice
ps_tumble=[ shortedge ]

#
# Take PCL from generic section ....
#

#!End of [ hp5000 ]

# PRINTER hp8000 - HP8000 Series
#
# Hewlett Packard 8000 Series
#
# Printer short description: Letter/Legal/A4, PostScript Level3
#                            300/600
#
# Input taken from
# hp8000_5.ppd
#
# Author: Wilfried.Gaensheimer@infineon.com
# wig19990921
#
# Status: untested
#
# Open Issues:
#
# Implemented commands:
#
# PJL:
#
# resolution: 300/300dpi | 600/600dpi
# bitsperpixel: ( 2 | 1 )
# economode: ( ON | OFF )
# 
# Postscript:
#
# outputbin: upper/topbin | left/leftbin | 
#   not implemented: stacker | collator |separator | stapler | ....
# collate: ( true | false )
# smoothing: ( true | false )
# pagesize/papersize/paper:
#        letter | executive | legal | tabloid/11x17 | a3 | a4 | a5
#   not implemented: w842h1274 | b4 | b5 | doublepostcard |
#                    w612h935 | w558h774 | w774h1116 |
#                    env10 envmonarch envdl envc5 envisob5
# inputslot/tray: upper/tray1 | manual/manualfeed | middle/tray2 |
#             lower/tray3 |largecapacity/tray4/large |
#             tray5 | envelope | plain | preprinted | 
#             transparency 
#   not implemented: | letterhead | prepunched | labels | bond | recycled |
#              colorpaper (*) | cardstock | rough
# (*) color in PPD
# scalepattern (not implemented)
# halftone: enhanced | standard
# duplex | sduplex/duplexshort | simplex | shortedge/tumble

[ hp8000 ]

pjl_only=[
    COMMENT DEFAULT DINQUIRE ECHO ENTER EOJ
    FSAPPEND FSDIRLIST FSQUERY FSUPLOAD FSDELETE FSDOWNLOAD
    FSINIT FSMKDIR
    INFO INITIALIZE INQUIRE JOB OPMSG PJL RDYMSG
    RESET SET STMSG USTATUS USTATUSOFF
    COPIES
]
pjl_user_opts=[
	resolution 300 300dpi 600 600dpi
        bitsperpixel
        economode
    ]

resolution=300

pjl_resolution=@PJL SET RESOLUTION = \%d{resolution}
pjl_300=[ resolution=300 ]
pjl_600=[ resolution=600 ]
pjl_300dpi=[ resolution=300 ]
pjl_600dpi=[ resolution=600 ]

pjl_bitsperpixel=@PJL SET BITSPERPIXEL = \%d{bitsperpixel}

economode=ON
pjl_economode=@PJL SET ECONOMODE = \%s{economode}

ps_user_opts=[
	outputbin upper topbin left leftbin
        collate
        smoothing nosmoothing
        pagesize papersize paper letter executive legal tabloid 11x17
            a3 a4 a5
        inputslot tray upper tray1 manual manualfeed middle tray2
            lower tray3 largecapacity large
            tray4 tray5 plain preprinted transparency
        halftone enhanced standard
        duplex sduplex duplexshort simplex shortedge tumble
    ]

ps_outputbin=[ \%s{outputbin} ]
ps_upper=[ topbin ]
ps_topbin=<</Staple 0 /OutputType (TOP OUTPUT BIN)>> setpagedevice
ps_left=[ leftbin ]
ps_leftbin=
   currentpagedevice /OutputAttributes get
   4 known
         {<</Staple 0 /OutputType (FACE UP BIN)>> setpagedevice}
         {<</Staple 0 /OutputType (LEFT OUTPUT BIN)>> setpagedevice}
       ifelse

collate=true
ps_collate=<</Collate \%s{collate}>> setpagedevice

# smoothing: ( true | false )
smoothing=true
ps_smoothing=
   << /PostRenderingEnhance true /PostRenderingEnhanceDetails << /REValue 2 /Type 8 >>
    >> setpagedevice
ps_nosmoothing=
   << /PostRenderingEnhance true /PostRenderingEnhanceDetails << /REValue 0 /Type 8 >>
    >> setpagedevice

#
# Paper size selection ...
#
ps_paper=[ \%s{paper} ]
ps_papersize=[ \%s{papersize} ]
ps_pagesize=[ \%s{pagesize} ]
ps_letter=<</DeferredMediaSelection true /PageSize [612 792] /ImagingBBox null>> setpagedevice
ps_executive=
    <</DeferredMediaSelection true /PageSize [522 756] /ImagingBBox null>> setpagedevice
ps_legal=
    <</DeferredMediaSelection true /PageSize [612 1008] /ImagingBBox null>> setpagedevice
ps_tabloid=
  <</DeferredMediaSelection true /PageSize [792 1224] /ImagingBBox null>> setpagedevice
ps_11x17=[ tabloid ]
ps_ledger=[ tabloid ]
ps_a3=
    <</DeferredMediaSelection true /PageSize [842 1191] /ImagingBBox null>> setpagedevice
ps_a4=
    <</DeferredMediaSelection true /PageSize [595 842] /ImagingBBox null>> setpagedevice
ps_a5=
    <</DeferredMediaSelection true /PageSize [420 595] /ImagingBBox null>> setpagedevice

#
# inputslot ...
#
ps_tray=[ \%s{tray} ]
ps_inputslot=[ \%s{inputslot} ]
	
ps_upper=<</ManualFeed false /MediaPosition 3>> setpagedevice
ps_tray1=[ upper ]
ps_manual=<</ManualFeed true /MediaPosition 3>> setpagedevice
ps_manualfeed=[ manual ]
ps_middle=<</ManualFeed false /MediaPosition 0>> setpagedevice
ps_tray2=[ middle ]
ps_lower=<</ManualFeed false /MediaPosition 1>> setpagedevice"
ps_tray3=[ lower ]
ps_largecapacity=<</ManualFeed false /MediaPosition 5>> setpagedevice
ps_large=[ largecapacity ]
ps_tray4=[ largecapacity ]
ps_tray5=<</ManualFeed false /MediaPosition 6>> setpagedevice
ps_plain=<</ManualFeed false /MediaType (Plain)>> setpagedevice
ps_preprinted=<</ManualFeed false /MediaType (Preprinted)>> setpagedevice
ps_transparency=<</ManualFeed false /MediaType (Transparency)>> setpagedevice

ps_halftone=[ \%s{halftone} ]
ps_enhanced=
  << /Install {
     currentpagedevice /HWResolution get
     dup 0 get 600 eq exch 1 get 600 eq and
     { /EnhancedColorRendering600 } { /EnhancedColorRendering } ifelse
     /ColorRendering findresource setcolorrendering
     /EnhancedHalftone /Halftone findresource sethalftone
     { } settransfer false setstrokeadjust
   }
   >> setpagedevice
   currentpagedevice /HWResolution get dup 0 get 600 eq exch 1 get 600 eq and
   {
       << /PostRenderingEnhance true
            /PostRenderingEnhanceDetails << /REValue 0 /Type 8 >>
       >> setpagedevice
   } if
   /setscreen { pop pop pop } def
   /setcolorscreen { pop pop pop pop pop pop pop pop pop pop pop pop } def
   /sethalftone { pop } def 
ps_standard=
     << /Install {
     currentpagedevice /HWResolution get
     dup 0 get 600 eq exch 1 get 600 eq and dup
     currentpagedevice /PostRenderingEnhance get
     currentpagedevice /PostRenderingEnhanceDetails get /REValue get 0 ne and
     { {/DefaultColorRenderingRE600} {/DefaultColorRenderingRE} ifelse}
     { {/DefaultColorRendering600} {/DefaultColorRendering} ifelse} ifelse
     /ColorRendering findresource setcolorrendering
     { /DefaultHalftone600 } {/DefaultHalftone} ifelse
     /Halftone findresource sethalftone
     {} settransfer false setstrokeadjust
   } >> setpagedevice
   currentpagedevice /HWResolution get dup 0 get 600 eq exch 1 get 600 eq and
   {
     << /PostRenderingEnhance true /PostRenderingEnhanceDetails
     << /REValue 0 /Type 8 >> >> setpagedevice
   } if    

#
# Duplex controll ..
#
ps_duplex=<</Duplex true>> setpagedevice
ps_sduplex=<</Duplex true /Tumble true>> setpagedevice
ps_duplexshort=[ sduplex ]
ps_simplex=<</Duplex false /Tumble false>> setpagedevice
ps_shortedge=<</Tumble true>> setpagedevice
ps_tumble=[ shortedge ]

#!End of [ hp8000 ]

# PRINTER hp4050 - HP4050 Series
#
# Hewlett Packard 4050 Series
#
# Model number: C4253A (LaserJet 4050N)
#
# Printer short description: Letter/Legal/A4, PostScript Level3
#                            300/600/1200
#
# Input taken from
# HP4050_6.ppd
#
# Author: Wilfried.Gaensheimer@infineon.com
# wig20000124
#
# Status: untested
#
# Open Issues:
#
# Implemented commands:
#
# PJL:
#
# paper: A4,Letter,Legal
# resolution: 300/300dpi | 600/600dpi | 1200/1200dpi
# fastres
# bitsperpixel: ( 2 | 1 )
# economode: ( ON | OFF )
# retention: ( on | off ) | quickcopy private proof store
# 
# Postscript:
#
# collate: ( true | false )
# smoothing: ( true | false ) smoothingon smoothingoff
# pagesize/papersize/paper:
#        letter | executive | legal | a4 | a5 |
#        b5 | w612h935 | w558h774 |
#        env10 | envmonarch | envdl | envc5 | envb5
# oneup oneupl twoup twoupl fourup fourupl sixup sixupl
#         nineup nineupl sixteenup sixteenupl
# Watermarks:
#   wmtext wmfont wmsize wmangle
#   wmtextstylenarrow wmtextstylemedium wmtextstylewide wmtextstylehalo
#   wmallpages wmfirstpage
# tray|inputslot: upper/tray1 | manualfeed/manual | middle/tray2
#    lower/tray3 | large/largecapacity/tray4
#    tray5 | tray6 | tray7 | tray8 | tray9 | tray10 | envelope
# media type: plain | transparency | preprinted
# media type:
#  plain | preprinted | letterhead | transparancy | prepunched |
#  labels | bond | recycled | mediacolor(*) | cardstock | rough
# (*) color in PPD
# promptuser
#   nearestsizeadjust
#   nearestsizenoadjust
#   policyletter
#   policya4
# scalepatterns
# halftone: halftoneenhanced | halfetonestandard
# duplex | sduplex/duplexshort/duplexshortedge | simplex | shortedge/tumble

[ hp4050* ]

pjl_only=[
    COMMENT DEFAULT DINQUIRE ECHO ENTER EOJ
    FSAPPEND FSDIRLIST FSQUERY FSUPLOAD FSDELETE FSDOWNLOAD
    FSINIT FSMKDIR
    INFO INITIALIZE INQUIRE JOB OPMSG PJL RDYMSG
    RESET SET STMSG USTATUS USTATUSOFF
    COPIES
]
pjl_except=[
]

pjl_user_opts=[
	resolution 300 300dpi 600 600dpi 1200 1200dpi
	paper a4 letter legal
	duplex simplex sduplex shortedge tumble
	copies
        retention quickcopy private proof store 
        fastres bitsperpixel fastresoff
    ]

resolution=300

pjl_resolution=@PJL SET RESOLUTION = \%d{resolution}
pjl_300=[ resolution=300 ]
pjl_600=[ resolution=600 ]
pjl_1200=[ resolution=1200 ]
pjl_300dpi=[ resolution=300 ]
pjl_600dpi=[ resolution=600 ]
pjl_1200dpi=[ resolution=1200 ]

#ExtractedKey: JCLResolution 300dpi/300 dpi
#pjl_300=
#    @PJL SET RESOLUTION = 300
#ExtractedKey: JCLResolution 600dpi/600 dpi
# pjl_600=
#     @PJL SET RESOLUTION = 600
#ExtractedKey: JCLResolution 1200dpi/1200 dpi
# pjl_1200=
#     @PJL SET RESOLUTION = 1200

# You can set retention to ON or OFF ... quickcopy, private and store are
# predefined ...
retention=OFF
pjl_retention=@PJL SET HOLD = \%s{retention}
#ExtractedKey: JCLRetention JCLRetentionQuickCopy/Quick Copy
pjl_quickcopy=@PJL SET HOLD = ON

#ExtractedKey: JCLRetention JCLRetentionProof/Proof and Hold
pjl_proof=@PJL SET HOLD = PROOF

#ExtractedKey: JCLRetention JCLRetentionPrivate/Private Job
pjl_private=
    @PJL SET HOLD = ON
    @PJL SET HOLDTYPE = PRIVATE

#ExtractedKey: JCLRetention JCLRetentionStore/Stored Job
pjl_store=@PJL SET HOLD = STORE

# Fast mode -> set fastres or bitsperpixel to 2,
bitsperpixel=1
pjl_bitsperpixel=@PJL SET BITSPERPIXEL = \%d{bitsperpixel}

#ExtractedKey: JCLFastRes True/On
pjl_fastres=@PJL SET BITSPERPIXEL = 2
#ExtractedKey: JCLFastRes False/Off
pjl_fastresoff=@PJL SET BITSPERPIXEL = 1

# Set economode
economode=ON
pjl_economode=@PJL SET ECONOMODE = \%s{economode}
#ExtractedKey: JCLEconomode False/Highest Quality
pjl_economodeoff=@PJL SET ECONOMODE = OFF
#ExtractedKey: JCLEconomode True/Save Toner
#pjl_economode=
#    @PJL SET ECONOMODE = ON


pjl_paper=@PJL SET PAPER = \%s{paper}
pjl_a4=@PJL SET PAPER = A4
pjl_letter=@PJL SET PAPER = letter
pjl_legal=@PJL SET PAPER = legal

pjl_duplex=@PJL SET DUPLEX = ON
pjl_sduplex=@PJL SET DUPLEX = ON
            @PJL SET TUMBLE = ON
pjl_shortedge=@PJL SET TUMBLE = ON
pjl_tumble=[ shortedge ]
pjl_simplex=@PJL SET DUPLEX = OFF

copies=1
pjl_copies=@PJL SET COPIES = \%d{copies}

ps_user_opts=[
        collate
        smoothing smoothingon smoothingoff nosmoothing
        pagesize papersize paper
           letter executive legal a4 a5 b5
           w612h935 w558h774 env10 envmonarch envdl envc5 envb5
        inputslot tray upper tray1 manual manualfeed middle tray2
           lower tray3 largecapacity large
           tray4 tray5 tray6 tray7 tray8 tray9 tray10 envelope
        plain preprinted letterhead transparancy prepunched labels
           bond recycled mediacolor cardstock rough
        halftone enhanced standard
        duplex sduplex duplexshort duplexshortedge simplex shortedge tumble
        oneup oneupl twoup twoupl fourup fourupl sixup sixupl
           nineup nineupl sixteenup sixteenupl
        wmtext wmfont wmsize wmangle
        wmtextstylenarrow wmtextstylemedium wmtextstylewide wmtextstylehalo
        wmallpages wmfirstpage
        promptuser
        nearestsizeadjust nearestsizenoadjust
        policyletter policya4
        scalepatterns
        halftoneenhanced halftonestandard
    ]

#ExtractedKey: HPNup OneUp/1 (Portrait)
ps_oneup=
    % Copyright (c) Hewlett-Packard Co 1997
      userdict begin
      true setglobal /HPwm 5 dict dup begin /HPwmOn true def /HPwmOdd true def end def false setglobal
    
      userdict /HPwmAngle known not {/HPwmAngle 45 def} if
      userdict /HPwmSize known not {/HPwmSize 48 def} if
      userdict /HPwmLocation known not {/HPwmLocation true def} if
      userdict /HPwmStyle known not {/HPwmStyle .48 def} if
      userdict /HPwmDuplex known not {/HPwmDuplex 0 def} if
    
      /HPwmEOP {HPwmDuplex 0 eq {true}{HPwmDuplex 1 eq HPwmOdd eq dup not {erasepage}if
        true setglobal /HPwmOdd HPwmOdd not def false setglobal}ifelse} bind def
      end
    
      <<
      /EndPage {userdict begin
      userdict /HPwmText known HPwm /HPwmOn get and
        {initmatrix
         0 setgray 1 setlinewidth true setstrokeadjust 0 setlinejoin 0 setlinecap [] 0 setdash
         currentpagedevice /PageSize get aload pop 2 div exch 2 div exch translate
         HPwmAngle rotate /HPwmFont userdict /HPppScale known {HPwmSize HPppScale mul}{HPwmSize}ifelse selectfont
         HPwmText stringwidth 2 div neg exch 2 div neg exch
           userdict /HPppScale known {HPwmSize HPppScale mul}{HPwmSize}ifelse .25 mul sub moveto
         HPwmText false charpath userdict /HPwmStyle1 known
           {gsave 1 setgray HPwmStyle1 HPwmStyle add setlinewidth stroke grestore} if
         0 setgray HPwmStyle setlinewidth stroke
         HPwmLocation not {true setglobal HPwm /HPwmOn false put false setglobal} if
        } if
        2 eq {pop false}{pop HPwm begin HPwmEOP end} ifelse
        end } bind
      >> setpagedevice

#ExtractedKey: HPNup OneUpL/1 (Landscape)
ps_oneupl=
    % Copyright (c) Hewlett-Packard Co 1997
      userdict begin
      true setglobal /HPwm 5 dict dup begin /HPwmOn true def /HPwmOdd true def end def false setglobal
    
      userdict /HPwmAngle known not {/HPwmAngle 45 def} if
      userdict /HPwmSize known not {/HPwmSize 48 def} if
      userdict /HPwmLocation known not {/HPwmLocation true def} if
      userdict /HPwmStyle known not {/HPwmStyle .48 def} if
      userdict /HPwmDuplex known not {/HPwmDuplex 0 def} if
    
      /HPwmEOP {HPwmDuplex 0 eq {true}{HPwmDuplex 1 eq HPwmOdd eq dup not {erasepage}if
        true setglobal /HPwmOdd HPwmOdd not def false setglobal}ifelse} bind def
      end
    
      <<
      /EndPage {userdict begin
      userdict /HPwmText known HPwm /HPwmOn get and
        {initmatrix
         0 setgray 1 setlinewidth true setstrokeadjust 0 setlinejoin 0 setlinecap [] 0 setdash
         currentpagedevice /PageSize get aload pop 2 div exch 2 div exch translate
         HPwmAngle 90 add rotate /HPwmFont userdict /HPppScale known {HPwmSize HPppScale mul}{HPwmSize}ifelse selectfont
         HPwmText stringwidth 2 div neg exch 2 div neg exch
           userdict /HPppScale known {HPwmSize HPppScale mul}{HPwmSize}ifelse .25 mul sub moveto
         HPwmText false charpath userdict /HPwmStyle1 known
           {gsave 1 setgray HPwmStyle1 HPwmStyle add setlinewidth stroke grestore} if
         0 setgray HPwmStyle setlinewidth stroke
         HPwmLocation not {true setglobal HPwm /HPwmOn false put false setglobal} if
        } if
        2 eq {pop false}{pop HPwm begin HPwmEOP end} ifelse
        end } bind
      >> setpagedevice

#ExtractedKey: HPNup TwoUp/2 (Portrait)
ps_twoup=
    % Copyright (c) Hewlett-Packard Co 1997
      userdict begin
      userdict /HPwmPgWidth known not
        {/HPwmPgWidth currentpagedevice /PageSize get aload pop /HPwmPgHeight exch def def} if
      /HPwmShWidth currentpagedevice /PageSize get aload pop /HPwmShHeight exch def def
    
      /HPwmCTM {
        /HPwmScale HPwmShWidth 32 sub HPwmPgHeight div dup HPwmShHeight 32 sub 2 div 
          HPwmPgWidth div dup 3 1 roll lt {pop} {exch pop} ifelse def
        /HPwmX1 HPwmShWidth HPwmPgHeight HPwmScale mul sub 2 div HPwmPgHeight HPwmScale mul add def
        /HPwmY1 HPwmShHeight HPwmPgWidth HPwmScale mul 2 mul sub 2 div def
        /HPwmY2 HPwmPgWidth HPwmScale mul HPwmY1 add def
      } bind def HPwmCTM
    
      true setglobal /HPwm 5 dict dup begin /HPwmOn true def /HPwmOdd true def end def false setglobal
    
      /restore {/PageSV where {pop dup PageSV eq 
        {restore HPwm begin HPwmMatrix setmatrix end}{restore}ifelse}{restore}ifelse} bind def
    
      userdict /HPwmAngle known not {/HPwmAngle 45 def} if
      userdict /HPwmSize known not {/HPwmSize 48 def} if
      userdict /HPwmLocation known not {/HPwmLocation true def} if
      userdict /HPwmStyle known not {/HPwmStyle .48 def} if
      userdict /HPwmDuplex known not {/HPwmDuplex 0 def} if
    
      /HPwmEOP {HPwmDuplex 0 eq {true}{HPwmDuplex 1 eq HPwmOdd eq dup not {erasepage}if
        true setglobal /HPwmOdd HPwmOdd not def false setglobal}ifelse} bind def
    
      /HPWaterMark {
      0 setgray 1 setlinewidth true setstrokeadjust 0 setlinejoin 0 setlinecap [] 0 setdash
      0 0 HPwmPgWidth HPwmPgHeight rectstroke
      userdict /HPwmText known HPwmOn and
        {HPwmPgWidth 2 div HPwmPgHeight 2 div translate
         HPwmAngle rotate /HPwmFont HPwmSize selectfont
         HPwmText stringwidth 2 div neg exch 2 div neg exch HPwmSize .25 mul sub moveto
         HPwmText false charpath userdict /HPwmStyle1 known
           {gsave 1 setgray HPwmStyle1 HPwmScale div HPwmStyle add setlinewidth stroke grestore} if
         0 setgray HPwmStyle setlinewidth stroke
         HPwmLocation not {true setglobal HPwm /HPwmOn false put false setglobal} if
        } if
      } bind def
      end
    
      <<
      /BeginPage {userdict begin
        2 mod 0 eq { HPwmX1 HPwmY1 translate }{ HPwmX1 HPwmY2 translate } ifelse
        90 rotate HPwmScale HPwmScale scale
        HPwm begin true setglobal
          /HPwmMatrix matrix currentmatrix def
        false setglobal end
        end } bind
     
      /EndPage {userdict begin
        HPwm begin HPwmMatrix setmatrix
        2 eq {2 mod 0 ne {HPwmEOP}{false}ifelse}{HPWaterMark 2 mod 1 eq {HPwmEOP}{false}ifelse} ifelse end
        end } bind
      >> setpagedevice
    
    /setpagedevice {userdict begin dup /PageSize known {/HPwmPgWidth exch /PageSize get aload pop /HPwmPgHeight exch def def
      HPwmCTM <</PageSize [HPwmShWidth HPwmShHeight] /ImagingBBox null>>
      userdict /HPwmSPD known {HPwmSPD}{setpagedevice} ifelse}if end} bind def

#ExtractedKey: HPNup TwoUpL/2 (Landscape)
ps_twoupl=
    % Copyright (c) Hewlett-Packard Co 1997
      userdict begin
      userdict /HPwmPgWidth known not
        {/HPwmPgWidth currentpagedevice /PageSize get aload pop /HPwmPgHeight exch def def} if
      /HPwmShWidth currentpagedevice /PageSize get aload pop /HPwmShHeight exch def def
    
      /HPwmCTM {
        /HPwmScale HPwmShWidth 32 sub HPwmPgHeight div dup HPwmShHeight 32 sub 2 div 
          HPwmPgWidth div dup 3 1 roll lt {pop} {exch pop} ifelse def
        /HPwmX1 HPwmShWidth HPwmPgHeight HPwmScale mul sub 2 div def
        /HPwmY1 HPwmShHeight HPwmPgWidth HPwmScale mul 2 mul sub 2 div HPwmShHeight exch sub def
        /HPwmY2 HPwmY1 HPwmPgWidth HPwmScale mul sub def
      } bind def HPwmCTM
    
      true setglobal /HPwm 5 dict dup begin /HPwmOn true def /HPwmOdd true def end def false setglobal
    
      /restore {/PageSV where {pop dup PageSV eq 
        {restore HPwm begin HPwmMatrix setmatrix end}{restore}ifelse}{restore}ifelse} bind def
    
      userdict /HPwmAngle known not {/HPwmAngle 45 def} if
      userdict /HPwmSize known not {/HPwmSize 48 def} if
      userdict /HPwmLocation known not {/HPwmLocation true def} if
      userdict /HPwmStyle known not {/HPwmStyle .48 def} if
      userdict /HPwmDuplex known not {/HPwmDuplex 0 def} if
    
      /HPwmEOP {HPwmDuplex 0 eq {true}{HPwmDuplex 1 eq HPwmOdd eq dup not {erasepage}if
        true setglobal /HPwmOdd HPwmOdd not def false setglobal}ifelse} bind def
    
      /HPWaterMark {
      0 setgray 1 setlinewidth true setstrokeadjust 0 setlinejoin 0 setlinecap [] 0 setdash
      0 0 HPwmPgWidth HPwmPgHeight rectstroke
      userdict /HPwmText known HPwmOn and
        {HPwmPgWidth 2 div HPwmPgHeight 2 div translate
         HPwmAngle 90 add rotate /HPwmFont HPwmSize selectfont
         HPwmText stringwidth 2 div neg exch 2 div neg exch HPwmSize .25 mul sub moveto
         HPwmText false charpath userdict /HPwmStyle1 known
           {gsave 1 setgray HPwmStyle1 HPwmScale div HPwmStyle add setlinewidth stroke grestore} if
         0 setgray HPwmStyle setlinewidth stroke
         HPwmLocation not {true setglobal HPwm /HPwmOn false put false setglobal} if
        } if
      } bind def
      end
    
      <<
      /BeginPage {userdict begin
        2 mod 0 eq { HPwmX1 HPwmY1 translate }{ HPwmX1 HPwmY2 translate } ifelse
        -90 rotate HPwmScale HPwmScale scale
        HPwm begin true setglobal
          /HPwmMatrix matrix currentmatrix def
        false setglobal end
        end } bind
     
      /EndPage {userdict begin
        HPwm begin HPwmMatrix setmatrix
        2 eq {2 mod 0 ne {HPwmEOP}{false}ifelse}{HPWaterMark 2 mod 1 eq {HPwmEOP}{false}ifelse} ifelse end
        end } bind
      >> setpagedevice
    
    /setpagedevice {userdict begin dup /PageSize known {/HPwmPgWidth exch /PageSize get aload pop /HPwmPgHeight exch def def
      HPwmCTM <</PageSize [HPwmShWidth HPwmShHeight] /ImagingBBox null>>
      userdict /HPwmSPD known {HPwmSPD}{setpagedevice} ifelse}if end} bind def

#ExtractedKey: HPNup FourUp/4 (Portrait)
ps_fourup=
    % Copyright (c) Hewlett-Packard Co 1997
      userdict begin
      userdict /HPwmPgWidth known not
        {/HPwmPgWidth currentpagedevice /PageSize get aload pop /HPwmPgHeight exch def def} if
      /HPwmShWidth currentpagedevice /PageSize get aload pop /HPwmShHeight exch def def
    
      /HPwmCTM {
        /HPwmScale HPwmShWidth 32 sub 2 div HPwmPgWidth div dup HPwmShHeight 32 sub 2 div 
          HPwmPgHeight div dup 3 1 roll lt {pop} {exch pop} ifelse def
        /HPwmX1 HPwmShWidth HPwmPgWidth HPwmScale mul 2 mul sub 2 div def
        /HPwmX2 HPwmPgWidth HPwmScale mul HPwmX1 add def
        /HPwmY1 HPwmShHeight HPwmPgHeight HPwmScale mul 2 mul sub 2 div def
        /HPwmY2 HPwmPgHeight HPwmScale mul HPwmY1 add def
      } bind def HPwmCTM
    
      true setglobal /HPwm 5 dict dup begin /HPwmOn true def /HPwmOdd true def end def false setglobal
    
      /restore {/PageSV where {pop dup PageSV eq 
        {restore HPwm begin HPwmMatrix setmatrix end}{restore}ifelse}{restore}ifelse} bind def
    
      userdict /HPwmAngle known not {/HPwmAngle 45 def} if
      userdict /HPwmSize known not {/HPwmSize 48 def} if
      userdict /HPwmLocation known not {/HPwmLocation true def} if
      userdict /HPwmStyle known not {/HPwmStyle .48 def} if
      userdict /HPwmDuplex known not {/HPwmDuplex 0 def} if
    
      /HPwmEOP {HPwmDuplex 0 eq {true}{HPwmDuplex 1 eq HPwmOdd eq dup not {erasepage}if
        true setglobal /HPwmOdd HPwmOdd not def false setglobal}ifelse} bind def
    
      /HPWaterMark {
      0 setgray 1 setlinewidth true setstrokeadjust 0 setlinejoin 0 setlinecap [] 0 setdash
      0 0 HPwmPgWidth HPwmPgHeight rectstroke
      userdict /HPwmText known HPwmOn and
        {HPwmPgWidth 2 div HPwmPgHeight 2 div translate
         HPwmAngle rotate /HPwmFont HPwmSize selectfont
         HPwmText stringwidth 2 div neg exch 2 div neg exch HPwmSize .25 mul sub moveto
         HPwmText false charpath userdict /HPwmStyle1 known
           {gsave 1 setgray HPwmStyle1 HPwmScale div HPwmStyle add setlinewidth stroke grestore} if
         0 setgray HPwmStyle setlinewidth stroke
         HPwmLocation not {true setglobal HPwm /HPwmOn false put false setglobal} if
        } if
      } bind def
      end
    
    <<
      /BeginPage {userdict begin
        4 mod dup dup dup
        0 eq {HPwmX1 HPwmY2 translate} if
        1 eq {HPwmX2 HPwmY2 translate} if
        2 eq {HPwmX1 HPwmY1 translate} if
        3 eq {HPwmX2 HPwmY1 translate} if
        HPwmScale HPwmScale scale
        HPwm begin true setglobal
          /HPwmMatrix matrix currentmatrix def
        false setglobal end
        end } bind
     
      /EndPage {userdict begin
        HPwm begin HPwmMatrix setmatrix
        2 eq {4 mod 0 ne {HPwmEOP}{false}ifelse}{HPWaterMark 4 mod 3 eq {HPwmEOP}{false}ifelse} ifelse end
        end } bind
    >> setpagedevice
    
    /setpagedevice {userdict begin dup /PageSize known {/HPwmPgWidth exch /PageSize get aload pop /HPwmPgHeight exch def def
      HPwmCTM <</PageSize [HPwmShWidth HPwmShHeight] /ImagingBBox null>>
      userdict /HPwmSPD known {HPwmSPD}{setpagedevice} ifelse}if end} bind def

#ExtractedKey: HPNup FourUpL/4 (Landscape)
ps_fourupl=
    % Copyright (c) Hewlett-Packard Co 1997
      userdict begin
      userdict /HPwmPgWidth known not
        {/HPwmPgWidth currentpagedevice /PageSize get aload pop /HPwmPgHeight exch def def} if
      /HPwmShWidth currentpagedevice /PageSize get aload pop /HPwmShHeight exch def def
    
      /HPwmCTM {
        /HPwmScale HPwmShWidth 32 sub 2 div HPwmPgWidth div dup HPwmShHeight 32 sub 2 div 
          HPwmPgHeight div dup 3 1 roll lt {pop} {exch pop} ifelse def
        /HPwmX1 HPwmShWidth HPwmPgWidth HPwmScale mul 2 mul sub 2 div def
        /HPwmX2 HPwmPgWidth HPwmScale mul HPwmX1 add def
        /HPwmY1 HPwmShHeight HPwmPgHeight HPwmScale mul 2 mul sub 2 div def
        /HPwmY2 HPwmPgHeight HPwmScale mul HPwmY1 add def
      } bind def HPwmCTM
    
      true setglobal /HPwm 5 dict dup begin /HPwmOn true def /HPwmOdd true def end def false setglobal
    
      /restore {/PageSV where {pop dup PageSV eq 
        {restore HPwm begin HPwmMatrix setmatrix end}{restore}ifelse}{restore}ifelse} bind def
    
      userdict /HPwmAngle known not {/HPwmAngle 45 def} if
      userdict /HPwmSize known not {/HPwmSize 48 def} if
      userdict /HPwmLocation known not {/HPwmLocation true def} if
      userdict /HPwmStyle known not {/HPwmStyle .48 def} if
      userdict /HPwmDuplex known not {/HPwmDuplex 0 def} if
    
      /HPwmEOP {HPwmDuplex 0 eq {true}{HPwmDuplex 1 eq HPwmOdd eq dup not {erasepage}if
        true setglobal /HPwmOdd HPwmOdd not def false setglobal}ifelse} bind def
    
      /HPWaterMark {
      0 setgray 1 setlinewidth true setstrokeadjust 0 setlinejoin 0 setlinecap [] 0 setdash
      0 0 HPwmPgWidth HPwmPgHeight rectstroke
      userdict /HPwmText known HPwmOn and
        {HPwmPgWidth 2 div HPwmPgHeight 2 div translate
         HPwmAngle 90 add rotate /HPwmFont HPwmSize selectfont
         HPwmText stringwidth 2 div neg exch 2 div neg exch HPwmSize .25 mul sub moveto
         HPwmText false charpath userdict /HPwmStyle1 known
           {gsave 1 setgray HPwmStyle1 HPwmScale div HPwmStyle add setlinewidth stroke grestore} if
         0 setgray HPwmStyle setlinewidth stroke
         HPwmLocation not {true setglobal HPwm /HPwmOn false put false setglobal} if
        } if
      } bind def
      end
    
      <<
      /BeginPage {userdict begin
        4 mod dup dup dup
        0 eq {HPwmX1 HPwmY1 translate} if
        1 eq {HPwmX1 HPwmY2 translate} if
        2 eq {HPwmX2 HPwmY1 translate} if
        3 eq {HPwmX2 HPwmY2 translate} if
        HPwmScale HPwmScale scale
        HPwm begin true setglobal
          /HPwmMatrix matrix currentmatrix def
        false setglobal end
        end } bind
     
      /EndPage {userdict begin
        HPwm begin HPwmMatrix setmatrix
        2 eq {4 mod 0 ne {HPwmEOP}{false}ifelse}{HPWaterMark 4 mod 3 eq {HPwmEOP}{false}ifelse} ifelse end
        end } bind
      >> setpagedevice
    
    /setpagedevice {userdict begin dup /PageSize known {/HPwmPgWidth exch /PageSize get aload pop /HPwmPgHeight exch def def
      HPwmCTM <</PageSize [HPwmShWidth HPwmShHeight] /ImagingBBox null>>
      userdict /HPwmSPD known {HPwmSPD}{setpagedevice} ifelse}if end} bind def

#ExtractedKey: HPNup SixUp/6 (Portrait)
ps_sixup=
    % Copyright (c) Hewlett-Packard Co 1997
      userdict begin
      userdict /HPwmPgWidth known not
        {/HPwmPgWidth currentpagedevice /PageSize get aload pop /HPwmPgHeight exch def def} if
      /HPwmShWidth currentpagedevice /PageSize get aload pop /HPwmShHeight exch def def
    
      /HPwmCTM {
        /HPwmScale HPwmShWidth 32 sub 2 div HPwmPgHeight div dup HPwmShHeight 32 sub 3 div 
          HPwmPgWidth div dup 3 1 roll lt {pop} {exch pop} ifelse def
        /HPwmX1 HPwmShWidth HPwmPgHeight HPwmScale mul 2 mul sub 2 div HPwmPgHeight HPwmScale mul add def
        /HPwmY1 HPwmShHeight HPwmPgWidth HPwmScale mul 3 mul sub 2 div def
      } bind def HPwmCTM
    
      true setglobal /HPwm 5 dict dup begin /HPwmOn true def /HPwmOdd true def end def false setglobal
    
      /restore {/PageSV where {pop dup PageSV eq 
        {restore HPwm begin HPwmMatrix setmatrix end}{restore}ifelse}{restore}ifelse} bind def
    
      userdict /HPwmAngle known not {/HPwmAngle 45 def} if
      userdict /HPwmSize known not {/HPwmSize 48 def} if
      userdict /HPwmLocation known not {/HPwmLocation true def} if
      userdict /HPwmStyle known not {/HPwmStyle .48 def} if
      userdict /HPwmDuplex known not {/HPwmDuplex 0 def} if
    
      /HPwmEOP {HPwmDuplex 0 eq {true}{HPwmDuplex 1 eq HPwmOdd eq dup not {erasepage}if
        true setglobal /HPwmOdd HPwmOdd not def false setglobal}ifelse} bind def
    
      /HPWaterMark {
      0 setgray 1 setlinewidth true setstrokeadjust 0 setlinejoin 0 setlinecap [] 0 setdash
      0 0 HPwmPgWidth HPwmPgHeight rectstroke
      userdict /HPwmText known HPwmOn and
        {HPwmPgWidth 2 div HPwmPgHeight 2 div translate
         HPwmAngle rotate /HPwmFont HPwmSize selectfont
         HPwmText stringwidth 2 div neg exch 2 div neg exch HPwmSize .25 mul sub moveto
         HPwmText false charpath userdict /HPwmStyle1 known
           {gsave 1 setgray HPwmStyle1 HPwmScale div HPwmStyle add setlinewidth stroke grestore} if
         0 setgray HPwmStyle setlinewidth stroke
         HPwmLocation not {true setglobal HPwm /HPwmOn false put false setglobal} if
        } if
      } bind def
      end
    
      <<
      /BeginPage {userdict begin
        6 mod dup
        3 idiv HPwmPgHeight HPwmScale mul mul HPwmX1 add
        exch dup 3 idiv 3 mul sub HPwmPgWidth HPwmScale mul mul HPwmY1 add
        translate
        90 rotate HPwmScale HPwmScale scale
        HPwm begin true setglobal
          /HPwmMatrix matrix currentmatrix def
        false setglobal end
        end } bind
     
      /EndPage {userdict begin
        HPwm begin HPwmMatrix setmatrix
        2 eq {6 mod 0 ne {HPwmEOP}{false}ifelse}{HPWaterMark 6 mod 5 eq {HPwmEOP}{false}ifelse} ifelse end
        end } bind
      >> setpagedevice
    
    /setpagedevice {userdict begin dup /PageSize known {/HPwmPgWidth exch /PageSize get aload pop /HPwmPgHeight exch def def
      HPwmCTM <</PageSize [HPwmShWidth HPwmShHeight] /ImagingBBox null>>
      userdict /HPwmSPD known {HPwmSPD}{setpagedevice} ifelse}if end} bind def

#ExtractedKey: HPNup SixUpL/6 (Landscape)
ps_sixupl=
    % Copyright (c) Hewlett-Packard Co 1997
      userdict begin
      userdict /HPwmPgWidth known not
        {/HPwmPgWidth currentpagedevice /PageSize get aload pop /HPwmPgHeight exch def def} if
      /HPwmShWidth currentpagedevice /PageSize get aload pop /HPwmShHeight exch def def
    
      /HPwmCTM {
        /HPwmScale HPwmShWidth 32 sub 2 div HPwmPgHeight div dup HPwmShHeight 32 sub 3 div 
          HPwmPgWidth div dup 3 1 roll lt {pop} {exch pop} ifelse def
        /HPwmX1 HPwmShWidth HPwmPgHeight HPwmScale mul 2 mul sub 2 div def
        /HPwmY1 HPwmShHeight HPwmPgWidth HPwmScale mul 3 mul sub 2 div HPwmPgWidth HPwmScale mul add def
      } bind def HPwmCTM
    
      true setglobal /HPwm 5 dict dup begin /HPwmOn true def /HPwmOdd true def end def false setglobal
    
      /restore {/PageSV where {pop dup PageSV eq 
        {restore HPwm begin HPwmMatrix setmatrix end}{restore}ifelse}{restore}ifelse} bind def
    
      userdict /HPwmAngle known not {/HPwmAngle 45 def} if
      userdict /HPwmSize known not {/HPwmSize 48 def} if
      userdict /HPwmLocation known not {/HPwmLocation true def} if
      userdict /HPwmStyle known not {/HPwmStyle .48 def} if
      userdict /HPwmDuplex known not {/HPwmDuplex 0 def} if
    
      /HPwmEOP {HPwmDuplex 0 eq {true}{HPwmDuplex 1 eq HPwmOdd eq dup not {erasepage}if
        true setglobal /HPwmOdd HPwmOdd not def false setglobal}ifelse} bind def
    
      /HPWaterMark {
      0 setgray 1 setlinewidth true setstrokeadjust 0 setlinejoin 0 setlinecap [] 0 setdash
      0 0 HPwmPgWidth HPwmPgHeight rectstroke
      userdict /HPwmText known HPwmOn and
        {HPwmPgWidth 2 div HPwmPgHeight 2 div translate
         HPwmAngle 90 add rotate /HPwmFont HPwmSize selectfont
         HPwmText stringwidth 2 div neg exch 2 div neg exch HPwmSize .25 mul sub moveto
         HPwmText false charpath userdict /HPwmStyle1 known
           {gsave 1 setgray HPwmStyle1 HPwmScale div HPwmStyle add setlinewidth stroke grestore} if
         0 setgray HPwmStyle setlinewidth stroke
         HPwmLocation not {true setglobal HPwm /HPwmOn false put false setglobal} if
        } if
      } bind def
      end
    
      <<
      /BeginPage {userdict begin
        6 mod dup
        dup 2 idiv 2 mul sub HPwmPgHeight HPwmScale mul mul HPwmX1 add
        exch 2 idiv 2 exch sub HPwmPgWidth HPwmScale mul mul HPwmY1 add
        translate
        -90 rotate HPwmScale HPwmScale scale
        HPwm begin true setglobal
          /HPwmMatrix matrix currentmatrix def
        false setglobal end
        end } bind
     
      /EndPage {userdict begin
        HPwm begin HPwmMatrix setmatrix
        2 eq {6 mod 0 ne {HPwmEOP}{false}ifelse}{HPWaterMark 6 mod 5 eq {HPwmEOP}{false}ifelse} ifelse end
        end } bind
      >> setpagedevice
    
    /setpagedevice {userdict begin dup /PageSize known {/HPwmPgWidth exch /PageSize get aload pop /HPwmPgHeight exch def def
      HPwmCTM <</PageSize [HPwmShWidth HPwmShHeight] /ImagingBBox null>>
      userdict /HPwmSPD known {HPwmSPD}{setpagedevice} ifelse}if end} bind def

#ExtractedKey: HPNup NineUp/9 (Portrait)
ps_nineuo=
    % Copyright (c) Hewlett-Packard Co 1997
      userdict begin
      userdict /HPwmPgWidth known not
        {/HPwmPgWidth currentpagedevice /PageSize get aload pop /HPwmPgHeight exch def def} if
      /HPwmShWidth currentpagedevice /PageSize get aload pop /HPwmShHeight exch def def
    
      /HPwmCTM {
        /HPwmScale HPwmShWidth 32 sub 3 div HPwmPgWidth div dup HPwmShHeight 32 sub 3 div 
          HPwmPgHeight div dup 3 1 roll lt {pop} {exch pop} ifelse def
        /HPwmX1 HPwmShWidth HPwmPgWidth HPwmScale mul 3 mul sub 2 div def
        /HPwmY1 HPwmShHeight HPwmPgHeight HPwmScale mul 3 mul sub 2 div def
      } bind def HPwmCTM
    
      true setglobal /HPwm 5 dict dup begin /HPwmOn true def /HPwmOdd true def end def false setglobal
    
      /restore {/PageSV where {pop dup PageSV eq 
        {restore HPwm begin HPwmMatrix setmatrix end}{restore}ifelse}{restore}ifelse} bind def
    
      userdict /HPwmAngle known not {/HPwmAngle 45 def} if
      userdict /HPwmSize known not {/HPwmSize 48 def} if
      userdict /HPwmLocation known not {/HPwmLocation true def} if
      userdict /HPwmStyle known not {/HPwmStyle .48 def} if
      userdict /HPwmDuplex known not {/HPwmDuplex 0 def} if
    
      /HPwmEOP {HPwmDuplex 0 eq {true}{HPwmDuplex 1 eq HPwmOdd eq dup not {erasepage}if
        true setglobal /HPwmOdd HPwmOdd not def false setglobal}ifelse} bind def
    
      /HPWaterMark {
      0 setgray 1 setlinewidth true setstrokeadjust 0 setlinejoin 0 setlinecap [] 0 setdash
      0 0 HPwmPgWidth HPwmPgHeight rectstroke
      userdict /HPwmText known HPwmOn and
        {HPwmPgWidth 2 div HPwmPgHeight 2 div translate
         HPwmAngle rotate /HPwmFont HPwmSize selectfont
         HPwmText stringwidth 2 div neg exch 2 div neg exch HPwmSize .25 mul sub moveto
         HPwmText false charpath userdict /HPwmStyle1 known
           {gsave 1 setgray HPwmStyle1 HPwmScale div HPwmStyle add setlinewidth stroke grestore} if
         0 setgray HPwmStyle setlinewidth stroke
         HPwmLocation not {true setglobal HPwm /HPwmOn false put false setglobal} if
        } if
      } bind def
      end
    
      <<
      /BeginPage {userdict begin
        9 mod dup
        dup 3 idiv 3 mul sub HPwmPgWidth HPwmScale mul mul HPwmX1 add
        exch 3 idiv 2 exch sub HPwmPgHeight HPwmScale mul mul HPwmY1 add
        translate
        HPwmScale HPwmScale scale
        HPwm begin true setglobal
          /HPwmMatrix matrix currentmatrix def
        false setglobal end
        end } bind
     
      /EndPage {userdict begin
        HPwm begin HPwmMatrix setmatrix
        2 eq {9 mod 0 ne {HPwmEOP}{false}ifelse}{HPWaterMark 9 mod 8 eq {HPwmEOP}{false}ifelse} ifelse end
        end } bind
      >> setpagedevice
    
    /setpagedevice {userdict begin dup /PageSize known {/HPwmPgWidth exch /PageSize get aload pop /HPwmPgHeight exch def def
      HPwmCTM <</PageSize [HPwmShWidth HPwmShHeight] /ImagingBBox null>>
      userdict /HPwmSPD known {HPwmSPD}{setpagedevice} ifelse}if end} bind def

#ExtractedKey: HPNup NineUpL/9 (Landscape)
ps_nineupl=
    % Copyright (c) Hewlett-Packard Co 1997
      userdict begin
      userdict /HPwmPgWidth known not
        {/HPwmPgWidth currentpagedevice /PageSize get aload pop /HPwmPgHeight exch def def} if
      /HPwmShWidth currentpagedevice /PageSize get aload pop /HPwmShHeight exch def def
    
      /HPwmCTM {
        /HPwmScale HPwmShWidth 32 sub 3 div HPwmPgWidth div dup HPwmShHeight 32 sub 3 div 
          HPwmPgHeight div dup 3 1 roll lt {pop} {exch pop} ifelse def
        /HPwmX1 HPwmShWidth HPwmPgWidth HPwmScale mul 3 mul sub 2 div def
        /HPwmY1 HPwmShHeight HPwmPgHeight HPwmScale mul 3 mul sub 2 div def
      } bind def HPwmCTM
    
      true setglobal /HPwm 5 dict dup begin /HPwmOn true def /HPwmOdd true def end def false setglobal
    
      /restore {/PageSV where {pop dup PageSV eq 
        {restore HPwm begin HPwmMatrix setmatrix end}{restore}ifelse}{restore}ifelse} bind def
    
      userdict /HPwmAngle known not {/HPwmAngle 45 def} if
      userdict /HPwmSize known not {/HPwmSize 48 def} if
      userdict /HPwmLocation known not {/HPwmLocation true def} if
      userdict /HPwmStyle known not {/HPwmStyle .48 def} if
      userdict /HPwmDuplex known not {/HPwmDuplex 0 def} if
    
      /HPwmEOP {HPwmDuplex 0 eq {true}{HPwmDuplex 1 eq HPwmOdd eq dup not {erasepage}if
        true setglobal /HPwmOdd HPwmOdd not def false setglobal}ifelse} bind def
    
      /HPWaterMark {
      0 setgray 1 setlinewidth true setstrokeadjust 0 setlinejoin 0 setlinecap [] 0 setdash
      0 0 HPwmPgWidth HPwmPgHeight rectstroke
      userdict /HPwmText known HPwmOn and
        {HPwmPgWidth 2 div HPwmPgHeight 2 div translate
         HPwmAngle 90 add rotate /HPwmFont HPwmSize selectfont
         HPwmText stringwidth 2 div neg exch 2 div neg exch HPwmSize .25 mul sub moveto
         HPwmText false charpath userdict /HPwmStyle1 known
           {gsave 1 setgray HPwmStyle1 HPwmScale div HPwmStyle add setlinewidth stroke grestore} if
         0 setgray HPwmStyle setlinewidth stroke
         HPwmLocation not {true setglobal HPwm /HPwmOn false put false setglobal} if
        } if
      } bind def
      end
    
      <<
      /BeginPage {userdict begin
        9 mod dup
        3 idiv HPwmPgWidth HPwmScale mul mul HPwmX1 add
        exch dup 3 idiv 3 mul sub HPwmPgHeight HPwmScale mul mul HPwmY1 add
        translate
        HPwmScale HPwmScale scale
        HPwm begin true setglobal
          /HPwmMatrix matrix currentmatrix def
        false setglobal end
        end } bind
     
      /EndPage {userdict begin
        HPwm begin HPwmMatrix setmatrix
        2 eq {9 mod 0 ne {HPwmEOP}{false}ifelse}{HPWaterMark 9 mod 8 eq {HPwmEOP}{false}ifelse} ifelse end
        end } bind
      >> setpagedevice
    
    /setpagedevice {userdict begin dup /PageSize known {/HPwmPgWidth exch /PageSize get aload pop /HPwmPgHeight exch def def
      HPwmCTM <</PageSize [HPwmShWidth HPwmShHeight] /ImagingBBox null>>
      userdict /HPwmSPD known {HPwmSPD}{setpagedevice} ifelse}if end} bind def

#ExtractedKey: HPNup SixteenUp/16 (Portrait)
ps_sixteenup=
    % Copyright (c) Hewlett-Packard Co 1997
      userdict begin
      userdict /HPwmPgWidth known not
        {/HPwmPgWidth currentpagedevice /PageSize get aload pop /HPwmPgHeight exch def def} if
      /HPwmShWidth currentpagedevice /PageSize get aload pop /HPwmShHeight exch def def
    
      /HPwmCTM {
        /HPwmScale HPwmShWidth 32 sub 4 div HPwmPgWidth div dup HPwmShHeight 32 sub 4 div 
          HPwmPgHeight div dup 3 1 roll lt {pop} {exch pop} ifelse def
        /HPwmX1 HPwmShWidth HPwmPgWidth HPwmScale mul 4 mul sub 2 div def
        /HPwmY1 HPwmShHeight HPwmPgHeight HPwmScale mul 4 mul sub 2 div def
      } bind def HPwmCTM
    
      true setglobal /HPwm 5 dict dup begin /HPwmOn true def /HPwmOdd true def end def false setglobal
    
      /restore {/PageSV where {pop dup PageSV eq 
        {restore HPwm begin HPwmMatrix setmatrix end}{restore}ifelse}{restore}ifelse} bind def
    
      userdict /HPwmAngle known not {/HPwmAngle 45 def} if
      userdict /HPwmSize known not {/HPwmSize 48 def} if
      userdict /HPwmLocation known not {/HPwmLocation true def} if
      userdict /HPwmStyle known not {/HPwmStyle .48 def} if
      userdict /HPwmDuplex known not {/HPwmDuplex 0 def} if
    
      /HPwmEOP {HPwmDuplex 0 eq {true}{HPwmDuplex 1 eq HPwmOdd eq dup not {erasepage}if
        true setglobal /HPwmOdd HPwmOdd not def false setglobal}ifelse} bind def
    
      /HPWaterMark {
      0 setgray 1 setlinewidth true setstrokeadjust 0 setlinejoin 0 setlinecap [] 0 setdash
      0 0 HPwmPgWidth HPwmPgHeight rectstroke
      userdict /HPwmText known HPwmOn and
        {HPwmPgWidth 2 div HPwmPgHeight 2 div translate
         HPwmAngle rotate /HPwmFont HPwmSize selectfont
         HPwmText stringwidth 2 div neg exch 2 div neg exch HPwmSize .25 mul sub moveto
         HPwmText false charpath userdict /HPwmStyle1 known
           {gsave 1 setgray HPwmStyle1 HPwmScale div HPwmStyle add setlinewidth stroke grestore} if
         0 setgray HPwmStyle setlinewidth stroke
         HPwmLocation not {true setglobal HPwm /HPwmOn false put false setglobal} if
        } if
      } bind def
      end
    
      <<
      /BeginPage {userdict begin
        16 mod dup
        dup 4 idiv 4 mul sub HPwmPgWidth HPwmScale mul mul HPwmX1 add
        exch 4 idiv 3 exch sub HPwmPgHeight HPwmScale mul mul HPwmY1 add
        translate
        HPwmScale HPwmScale scale
        HPwm begin true setglobal
          /HPwmMatrix matrix currentmatrix def
        false setglobal end
        end } bind
     
      /EndPage {userdict begin
        HPwm begin HPwmMatrix setmatrix
        2 eq {16 mod 0 ne {HPwmEOP}{false}ifelse}{HPWaterMark 16 mod 15 eq {HPwmEOP}{false}ifelse} ifelse end
        end } bind
      >> setpagedevice
    
    /setpagedevice {userdict begin dup /PageSize known {/HPwmPgWidth exch /PageSize get aload pop /HPwmPgHeight exch def def
      HPwmCTM <</PageSize [HPwmShWidth HPwmShHeight] /ImagingBBox null>>
      userdict /HPwmSPD known {HPwmSPD}{setpagedevice} ifelse}if end} bind def

#ExtractedKey: HPNup SixteenUpL/16 (Landscape)
ps_sixteenupl=
    % Copyright (c) Hewlett-Packard Co 1997
      userdict begin
      userdict /HPwmPgWidth known not
        {/HPwmPgWidth currentpagedevice /PageSize get aload pop /HPwmPgHeight exch def def} if
      /HPwmShWidth currentpagedevice /PageSize get aload pop /HPwmShHeight exch def def
    
      /HPwmCTM {
        /HPwmScale HPwmShWidth 32 sub 4 div HPwmPgWidth div dup HPwmShHeight 32 sub 4 div 
          HPwmPgHeight div dup 3 1 roll lt {pop} {exch pop} ifelse def
        /HPwmX1 HPwmShWidth HPwmPgWidth HPwmScale mul 4 mul sub 2 div def
        /HPwmY1 HPwmShHeight HPwmPgHeight HPwmScale mul 4 mul sub 2 div def
      } bind def HPwmCTM
    
      true setglobal /HPwm 5 dict dup begin /HPwmOn true def /HPwmOdd true def end def false setglobal
    
      /restore {/PageSV where {pop dup PageSV eq 
        {restore HPwm begin HPwmMatrix setmatrix end}{restore}ifelse}{restore}ifelse} bind def
    
      userdict /HPwmAngle known not {/HPwmAngle 45 def} if
      userdict /HPwmSize known not {/HPwmSize 48 def} if
      userdict /HPwmLocation known not {/HPwmLocation true def} if
      userdict /HPwmStyle known not {/HPwmStyle .48 def} if
      userdict /HPwmDuplex known not {/HPwmDuplex 0 def} if
    
      /HPwmEOP {HPwmDuplex 0 eq {true}{HPwmDuplex 1 eq HPwmOdd eq dup not {erasepage}if
        true setglobal /HPwmOdd HPwmOdd not def false setglobal}ifelse} bind def
    
      /HPWaterMark {
      0 setgray 1 setlinewidth true setstrokeadjust 0 setlinejoin 0 setlinecap [] 0 setdash
      0 0 HPwmPgWidth HPwmPgHeight rectstroke
      userdict /HPwmText known HPwmOn and
        {HPwmPgWidth 2 div HPwmPgHeight 2 div translate
         HPwmAngle 90 add rotate /HPwmFont HPwmSize selectfont
         HPwmText stringwidth 2 div neg exch 2 div neg exch HPwmSize .25 mul sub moveto
         HPwmText false charpath userdict /HPwmStyle1 known
           {gsave 1 setgray HPwmStyle1 HPwmScale div HPwmStyle add setlinewidth stroke grestore} if
         0 setgray HPwmStyle setlinewidth stroke
         HPwmLocation not {true setglobal HPwm /HPwmOn false put false setglobal} if
        } if
      } bind def
      end
    
      <<
      /BeginPage {userdict begin
        16 mod dup
        4 idiv HPwmPgWidth HPwmScale mul mul HPwmX1 add
        exch dup 4 idiv 4 mul sub HPwmPgHeight HPwmScale mul mul HPwmY1 add
        translate
        HPwmScale HPwmScale scale
        HPwm begin true setglobal
          /HPwmMatrix matrix currentmatrix def
        false setglobal end
        end } bind
     
      /EndPage {userdict begin
        HPwm begin HPwmMatrix setmatrix
        2 eq {16 mod 0 ne {HPwmEOP}{false}ifelse}{HPWaterMark 16 mod 15 eq {HPwmEOP}{false}ifelse} ifelse end
        end } bind
      >> setpagedevice
    
    /setpagedevice {userdict begin dup /PageSize known {/HPwmPgWidth exch /PageSize get aload pop /HPwmPgHeight exch def def
      HPwmCTM <</PageSize [HPwmShWidth HPwmShHeight] /ImagingBBox null>>
      userdict /HPwmSPD known {HPwmSPD}{setpagedevice} ifelse}if end} bind def

#ExtractedKey: HPwmText CompanyConfidential/Company Confidential
#ExtractedKey: HPwmText CompanyProprietary/Company Proprietary
#ExtractedKey: HPwmText CompanyPrivate/Company Private
#ExtractedKey: HPwmText Confidential/Confidential
#ExtractedKey: HPwmText Copy/Copy
#ExtractedKey: HPwmText Copyright/Copyright
#ExtractedKey: HPwmText Draft/Draft
#ExtractedKey: HPwmText FileCopy/File Copy
#ExtractedKey: HPwmText Final/Final
#ExtractedKey: HPwmText ForInternalUse/For Internal Use Only
#ExtractedKey: HPwmText Preliminary/Preliminary
#ExtractedKey: HPwmText Proof/Proof
#ExtractedKey: HPwmText ReviewCopy/Review Copy
#ExtractedKey: HPwmText Sample/Sample
#ExtractedKey: HPwmText TopSecret/Top Secret
#ExtractedKey: HPwmText Urgent/Urgent
wmtest=Company Confidential
ps_wmtext=
    userdict /HPwmText (\%s{wmtest}) put

#ExtractedKey: HPwmFont CourierB/Courier Bold
#ExtractedKey: HPwmFont TimesB/Times Bold
#ExtractedKey: HPwmFont HelveticaB/Helvetica Bold
wmfont=Courier-Bold
ps_wmfont=
      /\%s{wmfont} findfont dup length dict begin
        {1 index /FID ne {def} {pop pop} ifelse} forall
        /Encoding ISOLatin1Encoding def currentdict 
      end
      /HPwmFont exch definefont pop

#ExtractedKey: HPwmFontSize pt24/24 Points
#ExtractedKey: HPwmFontSize pt30/30 Points
#ExtractedKey: HPwmFontSize pt36/36 Points
#ExtractedKey: HPwmFontSize pt42/42 Points
#ExtractedKey: HPwmFontSize pt48/48 Points
#ExtractedKey: HPwmFontSize pt54/54 Points
#ExtractedKey: HPwmFontSize pt60/60 Points
#ExtractedKey: HPwmFontSize pt66/66 Points
#ExtractedKey: HPwmFontSize pt72/72 Points
#ExtractedKey: HPwmFontSize pt78/78 Points
#ExtractedKey: HPwmFontSize pt84/84 Points
#ExtractedKey: HPwmFontSize pt90/90 Points
wmsize=24
ps_wmsize=
    userdict /HPwmSize \%d{wmsize} put

#ExtractedKey: HPwmTextAngle Deg90/90 Degrees
#ExtractedKey: HPwmTextAngle Deg75/75 Degrees
#ExtractedKey: HPwmTextAngle Deg60/60 Degrees
#ExtractedKey: HPwmTextAngle Deg45/45 Degrees
#ExtractedKey: HPwmTextAngle Deg30/30 Degrees
#ExtractedKey: HPwmTextAngle Deg15/15 Degrees
#ExtractedKey: HPwmTextAngle Deg0/0 Degrees
#ExtractedKey: HPwmTextAngle DegN15/-15 Degrees
#ExtractedKey: HPwmTextAngle DegN30/-30 Degrees
#ExtractedKey: HPwmTextAngle DegN45/-45 Degrees
#ExtractedKey: HPwmTextAngle DegN60/-60 Degrees
#ExtractedKey: HPwmTextAngle DegN75/-75 Degrees
#ExtractedKey: HPwmTextAngle DegN90/-90 Degrees
wmangle=90
ps_wmangle=
    userdict /HPwmAngle \%d{wmangle} put

#ExtractedKey: HPwmTextStyle Narrow/Narrow Outline
ps_wmtextstylenarrow=
    userdict /HPwmStyle .24 put

#ExtractedKey: HPwmTextStyle Medium/Medium Outline
ps_wmtextstylemedium=
    userdict /HPwmStyle .48 put

#ExtractedKey: HPwmTextStyle Wide/Wide Outline
ps_wmtextstylewide=
    userdict /HPwmStyle .96 put

#ExtractedKey: HPwmTextStyle Halo/Wide Halo Outline
ps_wmtextstylehalo=
    userdict /HPwmStyle .96 put userdict /HPwmStyle1 .84 put

#ExtractedKey: HPwmLocation True/All Pages
ps_wmallpages=
    userdict /HPwmLocation true put

#ExtractedKey: HPwmLocation False/First Page Only
ps_wmfirstpage=
    userdict /HPwmLocation false put

#ExtractedKey: HPCollate True/On (turn off in application)
collate=true
ps_collate=<</Collate \%s{collate}>> setpagedevice

#ExtractedKey: HPCollate False/Off
# ps_collateoff=
    <</Collate false>> setpagedevice

#ExtractedKey: Smoothing True/On
ps_smoothing=[ smoothingon ]
ps_smoothingon=
      << /PostRenderingEnhance true /PostRenderingEnhanceDetails << /REValue 2 /Type 8 >>
      >> setpagedevice

#ExtractedKey: Smoothing False/Off
ps_smoothingoff=
      << /PostRenderingEnhance true /PostRenderingEnhanceDetails << /REValue 0 /Type 8 >>
      >> setpagedevice

# smoothing: ( true | false )
smoothing=true
ps_smoothing=
   << /PostRenderingEnhance true /PostRenderingEnhanceDetails << /REValue 2 /Type 8 >>
    >> setpagedevice
ps_nosmoothing=
   << /PostRenderingEnhance true /PostRenderingEnhanceDetails << /REValue 0 /Type 8 >>
    >> setpagedevice

#
# Paper size selection ...
#
ps_paper=[ \%s{paper} ]
ps_papersize=[ \%s{papersize} ]
ps_pagesize=[ \%s{pagesize} ]

#ExtractedKey: PageSize Letter/Letter
ps_letter=<</PageSize [612 792] /ImagingBBox null>> setpagedevice
#ExtractedKey: PageSize Executive/Executive
ps_executive=<</PageSize [522 756] /ImagingBBox null>> setpagedevice
#ExtractedKey: PageSize Legal/Legal
ps_legal=<</PageSize [612 1008] /ImagingBBox null>> setpagedevice
#ExtractedKey: PageSize A4/A4
ps_a4=<</PageSize [595 842] /ImagingBBox null>> setpagedevice
#ExtractedKey: PageSize A5/A5
ps_a5=<</PageSize [420 595] /ImagingBBox null>> setpagedevice
#ExtractedKey: PageSize B5/B5 (JIS)
ps_b5=<</PageSize [516 729] /ImagingBBox null>> setpagedevice
#ExtractedKey: PageSize w612h935/Executive (JIS)
ps_w612h935=<</PageSize [612 935] /ImagingBBox null>> setpagedevice
#ExtractedKey: PageSize w558h774/16K
ps_w558h774=<</PageSize [558 774] /ImagingBBox null>> setpagedevice
#ExtractedKey: PageSize Env10/Envelope #10
ps_env10=<</PageSize [297 684] /ImagingBBox null>> setpagedevice
#ExtractedKey: PageSize EnvMonarch/Envelope Monarch
ps_envmonarch=<</PageSize [279 540] /ImagingBBox null>> setpagedevice
#ExtractedKey: PageSize EnvDL/Envelope DL
ps_envdl=<</PageSize [312 624] /ImagingBBox null>> setpagedevice
#ExtractedKey: PageSize EnvC5/Envelope C5
ps_envc5=<</PageSize [459 649] /ImagingBBox null>> setpagedevice
#ExtractedKey: PageSize EnvISOB5/Envelope B5
ps_envb5=<</PageSize [499 709] /ImagingBBox null>> setpagedevice

#
# inputslot ...
#
ps_tray=[ \%s{tray} ]
ps_inputslot=[ \%s{inputslot} ]
	
#ExtractedKey: InputSlot Upper/ Tray 1
ps_upper=[ tray1 ]
ps_tray1=<</ManualFeed false /MediaPosition 3>> setpagedevice
#ExtractedKey: InputSlot ManualFeed/ Tray 1 (Manual)
ps_manualfeed=[ manual ]
ps_manual=<</ManualFeed true /MediaPosition 3>> setpagedevice
#ExtractedKey: InputSlot Middle/ Tray 2
ps_middle=[ tray2 ]
ps_tray2=<</ManualFeed false /MediaPosition 0>> setpagedevice
#ExtractedKey: InputSlot Lower/ Tray 3
ps_lower=[ tray3 ]
ps_tray3=currentpagedevice /InputAttributes get 1 known
      {<</ManualFeed false /MediaPosition 1>> setpagedevice}
      {currentpagedevice /InputAttributes get 5 known
        {<</ManualFeed false /MediaPosition 5>> setpagedevice}if}ifelse
#ExtractedKey: InputSlot LargeCapacity/ Tray 4
ps_large=[ tray4 ]
ps_largecapacity=[ tray4 ]
ps_tray4=currentpagedevice /InputAttributes get 4 known
      {<</ManualFeed false /MediaPosition 4>> setpagedevice}
      {currentpagedevice /InputAttributes get 1 known
        {<</ManualFeed false /MediaPosition 5>> setpagedevice}
        {<</ManualFeed false /MediaPosition 6>> setpagedevice}ifelse}ifelse

#ExtractedKey: InputSlot Tray5/ Tray 5
ps_tray5=currentpagedevice /InputAttributes get 1 known
      {<</ManualFeed false /MediaPosition 6>> setpagedevice}
      {<</ManualFeed false /MediaPosition 7>> setpagedevice}ifelse

#ExtractedKey: InputSlot Tray6/ Tray 6
ps_tray6=currentpagedevice /InputAttributes get 1 known
      {<</ManualFeed false /MediaPosition 7>> setpagedevice}
      {<</ManualFeed false /MediaPosition 8>> setpagedevice}ifelse

#ExtractedKey: InputSlot Tray7/ Tray 7
ps_tray7=currentpagedevice /InputAttributes get 1 known
      {<</ManualFeed false /MediaPosition 8>> setpagedevice}
      {<</ManualFeed false /MediaPosition 9>> setpagedevice}ifelse

#ExtractedKey: InputSlot Tray8/ Tray 8
ps_tray8=
    currentpagedevice /InputAttributes get 1 known
      {<</ManualFeed false /MediaPosition 9>> setpagedevice}
      {<</ManualFeed false /MediaPosition 10>> setpagedevice}ifelse

#ExtractedKey: InputSlot Tray9/ Tray 9
ps_tray9=
    currentpagedevice /InputAttributes get 1 known
      {<</ManualFeed false /MediaPosition 10>> setpagedevice}
      {<</ManualFeed false /MediaPosition 11>> setpagedevice}ifelse

#ExtractedKey: InputSlot Tray10/ Tray 10
ps_tray10=
    currentpagedevice /InputAttributes get 1 known
      {<</ManualFeed false /MediaPosition 11>> setpagedevice}
      {<</ManualFeed false /MediaPosition 12>> setpagedevice}ifelse

#ExtractedKey: InputSlot Envelope/ Envelope Feeder
ps_envelope=
    <</ManualFeed false /MediaPosition 2>> setpagedevice

#
# Media type ...
#
#ExtractedKey: InputSlot Plain/Plain
ps_plain=<</ManualFeed false /MediaType (Plain)>> setpagedevice

#ExtractedKey: InputSlot Preprinted/Preprinted
ps_preprinted=<</ManualFeed false /MediaType (Preprinted)>> setpagedevice

#ExtractedKey: InputSlot Letterhead/Letterhead
ps_letterhead=<</ManualFeed false /MediaType (Letterhead)>> setpagedevice

#ExtractedKey: InputSlot Transparency/Transparency
ps_transparancy=<</ManualFeed false /MediaType (Transparency)>> setpagedevice

#ExtractedKey: InputSlot Prepunched/Prepunched
ps_prepunched=<</ManualFeed false /MediaType (Prepunched)>> setpagedevice

#ExtractedKey: InputSlot Labels/Labels
ps_labels=<</ManualFeed false /MediaType (Labels)>> setpagedevice

#ExtractedKey: InputSlot Bond/Bond
ps_bond=<</ManualFeed false /MediaType (Bond)>> setpagedevice

#ExtractedKey: InputSlot Recycled/Recycled
ps_recycled=<</ManualFeed false /MediaType (Recycled)>> setpagedevice

#ExtractedKey: InputSlot Color/Color
ps_mediacolor=<</ManualFeed false /MediaType (Color)>> setpagedevice

#ExtractedKey: InputSlot Cardstock/Card Stock
ps_cardstock=<</ManualFeed false /MediaType (Card Stock)>> setpagedevice

#ExtractedKey: InputSlot Rough/Rough
ps_rough=<</ManualFeed false /MediaType (Rough)>> setpagedevice

#ExtractedKey: HPPaperPolicy PromptUser/Prompt User
ps_promptuser=<</DeferredMediaSelection true>> setpagedevice

#ExtractedKey: HPPaperPolicy NearestSizeAdjust/Nearest Size and Scale
ps_nearestsizeadjust=<</DeferredMediaSelection false /Policies << /PageSize 3 >> >> setpagedevice
#ExtractedKey: HPPaperPolicy NearestSizeNoAdjust/Nearest Size and Crop
ps_nearestsizenoadjust=<</DeferredMediaSelection false /Policies << /PageSize 5 >> >> setpagedevice

#ExtractedKey: HPPaperPolicy Letter/Letter
ps_policyletter=
    userdict begin
      /HPppX1 0 def
      /HPppY1 0 def
      /HPppScale 1 def
    
      <</DeferredMediaSelection true
        /BeginPage {pop userdict begin HPppX1 HPppY1 translate HPppScale HPppScale scale end} bind>> setpagedevice
    
      /HPwmSPD {setpagedevice} bind def
      /setpagedevice {userdict begin dup /PageSize known {/HPwmPgWidth exch /PageSize get aload pop /HPwmPgHeight exch def def
          /HPppScale 612 HPwmPgWidth div dup 792 HPwmPgHeight div dup 3 1 roll lt {pop} {exch pop} ifelse def
          HPppScale 1 gt {/HPppScale 1 def}if
          /HPppX1 612 HPwmPgWidth HPppScale mul sub 2 div def
          /HPppY1 792 HPwmPgHeight HPppScale mul sub 2 div def
          <</PageSize [612 792] /ImagingBBox null>> setpagedevice}{setpagedevice}ifelse end} bind def
    end

#ExtractedKey: HPPaperPolicy A4/A4
ps_policya4=
    userdict begin
      /HPppX1 0 def
      /HPppY1 0 def
      /HPppScale 1 def
    
      <</DeferredMediaSelection true
        /BeginPage {pop userdict begin HPppX1 HPppY1 translate HPppScale HPppScale scale end} bind>> setpagedevice
    
      /HPwmSPD {setpagedevice} bind def
      /setpagedevice {userdict begin dup /PageSize known {/HPwmPgWidth exch /PageSize get aload pop /HPwmPgHeight exch def def
          /HPppScale 595 HPwmPgWidth div dup 842 HPwmPgHeight div dup 3 1 roll lt {pop} {exch pop} ifelse def
          HPppScale 1 gt {/HPppScale 1 def}if
          /HPppX1 595 HPwmPgWidth HPppScale mul sub 2 div def
          /HPppY1 842 HPwmPgHeight HPppScale mul sub 2 div def
          <</PageSize [595 842] /ImagingBBox null>> setpagedevice}{setpagedevice}ifelse end} bind def
    end

#ExtractedKey: HPScalePatterns Scale/On
ps_scalepatterns=
    /GDIBWPatternDict 18 dict def
    /dtransform {GDIBWPatternDict /Width known {currentpagedevice /HWResolution get 0 get
    150 div mul exch currentpagedevice /HWResolution get 0 get 150 div mul exch dtransform}{dtransform}ifelse} bind def

#ExtractedKey: HPHalftone Enhanced/Enhanced
ps_halftoneenhanced=
       << /Install {
         currentpagedevice /HWResolution get
         dup 0 get 600 eq exch 1 get 600 eq and
         { /EnhancedColorRendering600 } { /EnhancedColorRendering } ifelse
         /ColorRendering findresource setcolorrendering
         /EnhancedHalftone /Halftone findresource sethalftone
         { } settransfer false setstrokeadjust
       }
       >> setpagedevice
       currentpagedevice /HWResolution get dup 0 get 600 eq exch 1 get 600 eq and
       {
           << /PostRenderingEnhance true
                /PostRenderingEnhanceDetails << /REValue 0 /Type 8 >>
           >> setpagedevice
       } if
       /setscreen { pop pop pop } def
       /setcolorscreen { pop pop pop pop pop pop pop pop pop pop pop pop } def
       /sethalftone { pop } def 


#ExtractedKey: HPHalftone Standard/Standard
ps_halftonestandard=
       << /Install {
         currentpagedevice /HWResolution get
         dup 0 get 600 eq exch 1 get 600 eq and dup
         currentpagedevice /PostRenderingEnhance get
         currentpagedevice /PostRenderingEnhanceDetails get /REValue get 0 ne and
         { {/DefaultColorRenderingRE600} {/DefaultColorRenderingRE} ifelse}
         { {/DefaultColorRendering600} {/DefaultColorRendering} ifelse} ifelse
         /ColorRendering findresource setcolorrendering
         { /DefaultHalftone600 } {/DefaultHalftone} ifelse
         /Halftone findresource sethalftone
         {} settransfer false setstrokeadjust
       } >> setpagedevice
       currentpagedevice /HWResolution get dup 0 get 600 eq exch 1 get 600 eq and
       {
         << /PostRenderingEnhance true /PostRenderingEnhanceDetails
         << /REValue 0 /Type 8 >> >> setpagedevice
       } if


#
# Duplex control ..
#

#ExtractedKey: Duplex None/Off (1-Sided)
ps_simplex=<</Duplex false>> setpagedevice

#ExtractedKey: Duplex DuplexNoTumble/Flip on Long Edge (Standard)
ps_duplex=<</Duplex true /Tumble false>> setpagedevice

#ExtractedKey: Duplex DuplexTumble/Flip on Short Edge
ps_duplexshortedge=[ sduplex ]
ps_sduplex=<</Duplex true /Tumble true>> setpagedevice

ps_duplex=<</Duplex true>> setpagedevice
ps_shortedge=<</Tumble true>> setpagedevice
ps_tumble=[ shortedge ]

#
# Take PCL from generic section ....
#
#!End of [ hp4050 ]



##### This is the end of the standard ifhp.conf file.
##### Add your local files after this
##### If you want to override some entries, simply change the names to
##### something different, i.e. hp4 hp4.old
##### Here is a script to do this and then append your local file to the
##### end of the ifhp.conf file:
#####
##### #!/bin/sh
##### for i in $* ; do
#####   perl -spi.bak -e 's/ $i / $i.orig /g' ifhp.conf
##### done
##### 
##### sed -n -e '1,/XXX END XXX/p' ifhp.conf >ifhp.conf.new
##### sed '1,/XXX END XXX/d' ifhp.old >> ifhp.conf.new
#####
##### You can probably improve on this.
#####
#### XXX END XXX #####
