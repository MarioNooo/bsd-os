Software Package:       
	ntp

Release/Version:
	4.0.98a

Retrieved from:
	http://www.eecis.udel.edu/~ntp

Bug reports:
	This software package is maintained by both BSDI and the
	software contributor.  Please send any bug reports to both
	support@BSDI.COM and mills@udel.edu.

Comments:

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Modifications to this version made by BSDI:


Ntpdate could core dump because the buffer management routines thought
they had more free buffers than they actually did.

Index: libntp/recvbuff.c
===================================================================
RCS file: /master/contrib/ntp-4.0.98a/libntp/recvbuff.c,v
retrieving revision 1.1.1.1
diff -c -r1.1.1.1 recvbuff.c
*** libntp/recvbuff.c	1999/10/18 21:42:25	1.1.1.1
--- libntp/recvbuff.c	1999/10/20 17:52:20
***************
*** 111,117 ****
  	}
  
  	fulllist = 0;
! 	free_recvbufs = total_recvbufs = RECV_INIT;
  	full_recvbufs = lowater_adds = 0;
  
  #if defined(HAVE_IO_COMPLETION_PORT)
--- 111,117 ----
  	}
  
  	fulllist = 0;
! 	free_recvbufs = total_recvbufs = nbufs;
  	full_recvbufs = lowater_adds = 0;
  
  #if defined(HAVE_IO_COMPLETION_PORT)


Surpress an annoying debug message.

Index: libntp/syssignal.c
===================================================================
RCS file: /master/contrib/ntp-4.0.98a/libntp/syssignal.c,v
retrieving revision 1.1.1.1
diff -c -r1.1.1.1 syssignal.c
*** libntp/syssignal.c	1999/10/18 21:42:23	1.1.1.1
--- libntp/syssignal.c	1999/10/20 18:29:40
***************
*** 47,53 ****
--- 47,57 ----
  
  		n = sigaction(sig, &vec, &ovec);
  		if (n == -1 && errno == EINTR) continue;
+ #ifdef	SA_RESTART
+ 		if (ovec.sa_flags && ovec.sa_flags != SA_RESTART)
+ #else
  		if (ovec.sa_flags)
+ #endif
  			msyslog(LOG_DEBUG, "signal_no_reset: signal %d had flags %x",
  				sig, ovec.sa_flags);
  		break;
Index: libntp/systime.c
===================================================================
RCS file: /master/contrib/ntp-4.0.98a/libntp/systime.c,v
retrieving revision 1.1.1.1
diff -c -r1.1.1.1 systime.c
*** libntp/systime.c	1999/10/18 21:42:24	1.1.1.1
--- libntp/systime.c	1999/11/12 01:38:01
***************
*** 287,293 ****
  		}
  	}
  	if (ntp_set_tod(&timetv, (struct timezone *)0) != 0) {
! 		msyslog(LOG_ERR, "Can't set time of day: %m");
  		return (0);
  	}
  	sys_residual = 0;
--- 287,294 ----
  		}
  	}
  	if (ntp_set_tod(&timetv, (struct timezone *)0) != 0) {
! 		msyslog(errno == EPERM ? LOG_INFO : LOG_ERR,
! 		    "Can't set time of day: %m");
  		return (0);
  	}
  	sys_residual = 0;
Index: ntpdate/ntpdate.c
===================================================================
RCS file: /master/contrib/ntp-4.0.98a/ntpdate/ntpdate.c,v
retrieving revision 1.1.1.1
diff -c -r1.1.1.1 ntpdate.c
*** ntpdate/ntpdate.c	1999/10/18 21:43:00	1.1.1.1
--- ntpdate/ntpdate.c	1999/11/12 01:43:31
***************
*** 142,150 ****
   */
  int sys_samples = DEFSAMPLES;	/* number of samples/server */
  u_long sys_timeout = DEFTIMEOUT; /* timeout time, in TIMER_HZ units */
! struct server **sys_servers;	/* the server list */
  int sys_numservers = 0; 	/* number of servers to poll */
- int sys_maxservers = 0; 	/* max number of servers to deal with */
  int sys_authenticate = 0;	/* true when authenticating */
  u_int32 sys_authkey = 0;	/* set to authentication key in use */
  u_long sys_authdelay = 0;	/* authentication delay */
--- 142,149 ----
   */
  int sys_samples = DEFSAMPLES;	/* number of samples/server */
  u_long sys_timeout = DEFTIMEOUT; /* timeout time, in TIMER_HZ units */
! struct server *sys_servers;	/* the server list */
  int sys_numservers = 0; 	/* number of servers to poll */
  int sys_authenticate = 0;	/* true when authenticating */
  u_int32 sys_authkey = 0;	/* set to authentication key in use */
  u_long sys_authdelay = 0;	/* authentication delay */
***************
*** 256,262 ****
     * Systemwide parameters and flags
     */
    sys_numservers = 0;	  /* number of servers to poll */
-   sys_maxservers = 0;	  /* max number of servers to deal with */
    sys_authenticate = 0;   /* true when authenticating */
    sys_authkey = 0;	   /* set to authentication key in use */
    sys_authdelay = 0;   /* authentication delay */
--- 255,260 ----
***************
*** 472,484 ****
  	/*
  	 * Add servers we are going to be polling
  	 */
- 	sys_maxservers = argc - ntp_optind;
  #ifdef HAVE_NETINFO
! 	if ((netinfoservers = getnetinfoservers()))
! 		sys_maxservers += netinfoservers->ni_namelist_len;
  #endif
- 	sys_servers = (struct server **)
- 		emalloc(sys_maxservers * sizeof(struct server *));
  
  	for ( ; ntp_optind < argc; ntp_optind++)
  		addserver(argv[ntp_optind]);
--- 470,478 ----
  	/*
  	 * Add servers we are going to be polling
  	 */
  #ifdef HAVE_NETINFO
! 	inetinfoservers = getnetinfoservers();
  #endif
  
  	for ( ; ntp_optind < argc; ntp_optind++)
  		addserver(argv[ntp_optind]);
***************
*** 1025,1032 ****
  	 * NTP_MAXLIST of them.
  	 */
  	nlist = 0;	/* none yet */
! 	for (n = 0; n < sys_numservers; n++) {
! 		server = sys_servers[n];
  		if (server->delay == 0)
  			continue;	/* no data */
  		if (server->stratum > NTP_INFIN)
--- 1019,1025 ----
  	 * NTP_MAXLIST of them.
  	 */
  	nlist = 0;	/* none yet */
! 	for (server = sys_servers; server != NULL; server = server->next_server) {
  		if (server->delay == 0)
  			continue;	/* no data */
  		if (server->stratum > NTP_INFIN)
***************
*** 1201,1218 ****
  static int
  clock_adjust(void)
  {
! 	register int i;
! 	register struct server *server;
  	s_fp absoffset;
  	int dostep;
  
! 	for (i = 0; i < sys_numservers; i++)
! 		clock_filter(sys_servers[i]);
  	server = clock_select();
  
  	if (debug || simple_query) {
! 		for (i = 0; i < sys_numservers; i++)
! 			printserver(sys_servers[i], stdout);
  	}
  
  	if (server == 0) {
--- 1194,1210 ----
  static int
  clock_adjust(void)
  {
! 	register struct server *sp, *server;
  	s_fp absoffset;
  	int dostep;
  
! 	for (sp = sys_servers; sp != NULL; sp = sp->next_server)
! 		clock_filter(sp);
  	server = clock_select();
  
  	if (debug || simple_query) {
! 		for (sp = sys_servers; sp != NULL; sp = sp->next_server)
! 			printserver(sp, stdout);
  	}
  
  	if (server == 0) {
***************
*** 1275,1295 ****
  {
  	register struct server *server;
  	u_int32 netnum;
- 	static int toomany = 0;
- 
- 	if (sys_numservers >= sys_maxservers) {
- 		if (!toomany) {
- 			/*
- 			 * This is actually a `can't happen' now.    Leave
- 			 * the error message in anyway, though
- 			 */
- 			toomany = 1;
- 			msyslog(LOG_ERR,
- 				"too many servers (> %d) specified, remainder not used",
- 				sys_maxservers);
- 		}
- 		return;
- 	}
  
  	if (!getnetnum(serv, &netnum)) {
  		msyslog(LOG_ERR, "can't find host %s\n", serv);
--- 1267,1272 ----
***************
*** 1303,1310 ****
  	server->srcadr.sin_addr.s_addr = netnum;
  	server->srcadr.sin_port = htons(NTP_PORT);
  
! 	sys_servers[sys_numservers++] = server;
! 	server->event_time = sys_numservers;
  }
  
  
--- 1280,1296 ----
  	server->srcadr.sin_addr.s_addr = netnum;
  	server->srcadr.sin_port = htons(NTP_PORT);
  
! 	server->event_time = ++sys_numservers;
! 	if (sys_servers == NULL)
! 		sys_servers = server;
! 	else {
! 		struct server *sp;
! 
! 		for (sp = sys_servers; sp->next_server != NULL;
! 		     sp = sp->next_server) {
! 			sp->next_server = server;
! 		}
! 	}
  }
  
  
***************
*** 1316,1333 ****
  	struct sockaddr_in *addr
  	)
  {
- 	register int i;
  	register u_int32 netnum;
  
  	if (htons(addr->sin_port) != NTP_PORT)
  		return 0;
  	netnum = addr->sin_addr.s_addr;
  
! 	for (i = 0; i < sys_numservers; i++) {
! 		if (netnum == sys_servers[i]->srcadr.sin_addr.s_addr)
! 			return sys_servers[i];
  	}
! 	return 0;
  }
  
  
--- 1302,1348 ----
  	struct sockaddr_in *addr
  	)
  {
  	register u_int32 netnum;
+ 	struct server *server;
+ 	struct server *mc_server;
  
+ 	mc_server = NULL;
  	if (htons(addr->sin_port) != NTP_PORT)
  		return 0;
  	netnum = addr->sin_addr.s_addr;
  
! 	for (server = sys_servers; server != NULL; 
! 	     server = server->next_server) {
! 		register u_int32 servnum;
! 		
! 		servnum = server->srcadr.sin_addr.s_addr;
! 		if (netnum == servnum)
! 			return server;
! 		if (IN_MULTICAST(ntohl(servnum)))
! 			mc_server = server;
! 	}
! 
! 	if (mc_server != NULL) {	
! 		struct server *sp;
! 
! 		if (mc_server->event_time != 0) {
! 			mc_server->event_time = 0;
! 			complete_servers++;
! 		}
! 		server = (struct server *)emalloc(sizeof(struct server));
! 		memset((char *)server, 0, sizeof(struct server));
! 
! 		server->srcadr.sin_family = AF_INET;
! 		server->srcadr.sin_addr.s_addr = netnum;
! 		server->srcadr.sin_port = htons(NTP_PORT);
! 
! 		server->event_time = ++sys_numservers;
! 		for (sp = sys_servers; sp->next_server != NULL;
! 		     sp = sp->next_server) ;
! 		sp->next_server = server;
! 		transmit(server);
  	}
! 	return NULL;
  }
  
  
***************
*** 1337,1343 ****
  void
  timer(void)
  {
! 	register int i;
  
  	/*
  	 * Bump the current idea of the time
--- 1352,1358 ----
  void
  timer(void)
  {
! 	struct server *server;
  
  	/*
  	 * Bump the current idea of the time
***************
*** 1349,1358 ****
  	 * who's event timers have expired.  Give these to
  	 * the transmit routine.
  	 */
! 	for (i = 0; i < sys_numservers; i++) {
! 		if (sys_servers[i]->event_time != 0
! 			&& sys_servers[i]->event_time <= current_time)
! 			transmit(sys_servers[i]);
  	}
  }
  
--- 1364,1374 ----
  	 * who's event timers have expired.  Give these to
  	 * the transmit routine.
  	 */
! 	for (server = sys_servers; server != NULL; 
! 	     server = server->next_server) {
! 		if (server->event_time != 0
! 		    && server->event_time <= current_time)
! 			transmit(server);
  	}
  }
  
***************
*** 1826,1832 ****
  		isneg = 0;
  
  	if (ftmp.l_ui >= 3) {		/* Step it and slew - we might win */
! 		n = step_systime(ts);
  		if (!n)
  			return n;
  		if (isneg)
--- 1842,1849 ----
  		isneg = 0;
  
  	if (ftmp.l_ui >= 3) {		/* Step it and slew - we might win */
! 		LFPTOD(ts, dtemp);
! 		n = step_systime(dtemp);
  		if (!n)
  			return n;
  		if (isneg)
Index: ntpdate/ntpdate.c
===================================================================
RCS file: /master/contrib/ntp-4.0.98a/ntpdate/ntpdate.c,v
retrieving revision 1.2
diff -c -r1.2 ntpdate.c
*** ntpdate/ntpdate.c	1999/11/12 01:49:44	1.2
--- ntpdate/ntpdate.c	1999/11/19 18:12:40
***************
*** 1287,1295 ****
  		struct server *sp;
  
  		for (sp = sys_servers; sp->next_server != NULL;
! 		     sp = sp->next_server) {
! 			sp->next_server = server;
! 		}
  	}
  }
  
--- 1287,1294 ----
  		struct server *sp;
  
  		for (sp = sys_servers; sp->next_server != NULL;
! 		     sp = sp->next_server) ;
! 		sp->next_server = server;
  	}
  }
  
