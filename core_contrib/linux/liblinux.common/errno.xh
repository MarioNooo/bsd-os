/*	BSDI errno.xh,v 1.2 2000/12/08 04:12:05 donn Exp	*/

/*
 * Errno template.
 */

%{
/*
 * We don't want the internal errno definition
 * to conflict with the BSD/OS one.
 */
#undef errno

#include <errno.h>
%}

cookie int errno_t {
	EAGAIN			11;
	EDEADLK			35;
	ENAMETOOLONG		36;
	ENOLCK			37;
	ENOSYS			38;
	ENOTEMPTY		39;
	ELOOP			40;
	ENOMSG			42;
	EIDRM			43;
	EREMOTE			66;
	EUSERS			87;
	ENOTSOCK		88;
	EDESTADDRREQ		89;
	EMSGSIZE		90;
	EPROTOTYPE		91;
	ENOPROTOOPT		92;
	EPROTONOSUPPORT		93;
	ESOCKTNOSUPPORT		94;
	EOPNOTSUPP		95;
	EPFNOSUPPORT		96;
	EAFNOSUPPORT		97;
	EADDRINUSE		98;
	EADDRNOTAVAIL		99;
	ENETDOWN		100;
	ENETUNREACH		101;
	ENETRESET		102;
	ECONNABORTED		103;
	ECONNRESET		104;
	ENOBUFS			105;
	EISCONN			106;
	ENOTCONN		107;
	ESHUTDOWN		108;
	ETOOMANYREFS		109;
	ETIMEDOUT		110;
	ECONNREFUSED		111;
	EHOSTDOWN		112;
	EHOSTUNREACH		113;
	EALREADY		114;
	EINPROGRESS		115;
	ESTALE			116;
	EDQUOT			122;

	LINUX_ECHRNG		44;
	LINUX_EL2NSYNC		45;
	LINUX_EL3HLT		46;
	LINUX_EL3RST		47;
	LINUX_ELNRNG		48;
	LINUX_EUNATCH		49;
	LINUX_ENOCSI		50;
	LINUX_EL2HLT		51;
	LINUX_EBADE		52;
	LINUX_EBADR		53;
	LINUX_EXFULL		54;
	LINUX_ENOANO		55;
	LINUX_EBADRQC		56;
	LINUX_EBADSLT		57;
	LINUX_EBFONT		59;
	LINUX_ENOSTR		60;
	LINUX_ENODATA		61;
	LINUX_ETIME		62;
	LINUX_ENOSR		63;
	LINUX_ENONET		64;
	LINUX_ENOPKG		65;
	LINUX_ENOLINK		67;
	LINUX_EADV		68;
	LINUX_ESRMNT		69;
	LINUX_ECOMM		70;
	LINUX_EPROTO		71;
	LINUX_EMULTIHOP		72;
	LINUX_EDOTDOT		73;
	LINUX_EBADMSG		74;
	LINUX_EOVERFLOW		75;
	LINUX_ENOTUNIQ		76;
	LINUX_EBADFD		77;
	LINUX_EREMCHG		78;
	LINUX_ELIBACC		79;
	LINUX_ELIBBAD		80;
	LINUX_ELIBSCN		81;
	LINUX_ELIBMAX		82;
	LINUX_ELIBEXEC		83;
	LINUX_EILSEQ		84;
	LINUX_ERESTART		85;
	LINUX_ESTRPIPE		86;
	LINUX_EUCLEAN		117;
	LINUX_ENOTNAM		118;
	LINUX_ENAVAIL		119;
	LINUX_EISNAM		120;
	LINUX_EREMOTEIO		121;
	LINUX_ENOMEDIUM		123;
	LINUX_EMEDIUMTYPE	124;

	out(n) {
		int f;

		/*
		 * Try to do something reasonable with BSD errno codes that
		 * have no equivalent under Linux.
		 */
		switch (n) {
		case EPROCLIM:
			f = LINUX_EAGAIN;
			break;
		case EBADRPC:
		case ERPCMISMATCH:
		case EPROGUNAVAIL:
		case EPROGMISMATCH:
		case EPROCUNAVAIL:
			f = LINUX_EREMOTEIO;
			break;
		case EFTYPE:
			f = EINVAL;
			break;
		case EAUTH:
		case ENEEDAUTH:
			f = EPERM;
			break;
		case EIPSEC:
			f = EIO;
			break;
		default:
			f = n;
			break;
		}

		return (f);
	}
};
