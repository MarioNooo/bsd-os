Software Package:       
	dhcp

Release/Version:
	3.0b2pl18 + buffer overflow patches for CERT VU#284857

Retrieved from:
	 ftp://ftp.isc.org/isc/dhcp

Bug reports:
	This software package is maintained by the software contributor,
	not BSDI.  Please send any bug reports to both support@BSDI.COM
	and dhcp-bugs@isc.org

Comments:

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Modifications to this version made by BSDI:

Added the file "makefile" to do man page formatting and provide the 
standard BSDI targets.

Added site.conf entries to set paths appropriately

Added support for BSD/OS's 802.11 framework, includes a new
file "dhcp/common/ieee802_11.c".

Support for BSD/OS's 802.1Q (VLAN) and AIF drivers, includes
a new file "dhcp/server/aif.c"

Enable USERLAND_FILTER so we check whether it's an UDP packet before
complaining about it's contents..

diff -c client/scripts/bsdos.orig client/scripts/bsdos
*** client/scripts/bsdos.orig	Fri Mar  2 08:55:05 2001
--- client/scripts/bsdos	Fri Mar  2 08:56:36 2001
***************
*** 165,171 ****
    sleep 1
    if [ "$new_routers" != "" ]; then
      set $new_routers
!     if ping -q -c 1 -w 1 $1; then
        if [ x$new_ip_address != x$alias_ip_address ] && \
  			[ x$alias_ip_address != x ]; then
  	ifconfig $interface inet alias $alias_ip_address $alias_subnet_arg
--- 165,171 ----
    sleep 1
    if [ "$new_routers" != "" ]; then
      set $new_routers
!     if ping -q -c 1 $1; then
        if [ x$new_ip_address != x$alias_ip_address ] && \
  			[ x$alias_ip_address != x ]; then
  	ifconfig $interface inet alias $alias_ip_address $alias_subnet_arg
diff -c common/Makefile.dist.orig common/Makefile.dist
*** common/Makefile.dist.orig	Fri Mar  2 15:41:41 2001
--- common/Makefile.dist	Fri Mar  2 08:57:21 2001
***************
*** 5,15 ****
  SRC    = raw.c parse.c nit.c icmp.c dispatch.c conflex.c upf.c bpf.c socket.c \
  	 lpf.c dlpi.c packet.c tr.c ethernet.c memory.c print.c options.c \
  	 inet.c tree.c tables.c alloc.c fddi.c ctrace.c \
! 	 dns.c resolv.c execute.c discover.c comapi.c
  OBJ    = raw.o parse.o nit.o icmp.o dispatch.o conflex.o upf.o bpf.o socket.o \
  	 lpf.o dlpi.o packet.o tr.o ethernet.o memory.o print.o options.o \
  	 inet.o tree.o tables.o alloc.o fddi.o ctrace.o \
! 	 dns.o resolv.o execute.o discover.o comapi.o
  MAN    = dhcp-options.5 dhcp-contrib.5 dhcp-eval.5
  
  DEBUG  = -g
--- 5,15 ----
  SRC    = raw.c parse.c nit.c icmp.c dispatch.c conflex.c upf.c bpf.c socket.c \
  	 lpf.c dlpi.c packet.c tr.c ethernet.c memory.c print.c options.c \
  	 inet.c tree.c tables.c alloc.c fddi.c ctrace.c \
! 	 dns.c resolv.c execute.c discover.c comapi.c ieee802_11.c
  OBJ    = raw.o parse.o nit.o icmp.o dispatch.o conflex.o upf.o bpf.o socket.o \
  	 lpf.o dlpi.o packet.o tr.o ethernet.o memory.o print.o options.o \
  	 inet.o tree.o tables.o alloc.o fddi.o ctrace.o \
! 	 dns.o resolv.o execute.o discover.o comapi.o ieee802_11.o
  MAN    = dhcp-options.5 dhcp-contrib.5 dhcp-eval.5
  
  DEBUG  = -g
diff -c common/bpf.c.orig common/bpf.c
*** common/bpf.c.orig	Thu Dec 28 16:13:07 2000
--- common/bpf.c	Sat Sep 22 02:46:21 2001
***************
*** 130,135 ****
--- 130,140 ----
  		log_fatal ("Can't attach interface %s to bpf device %s: %m",
  		       info -> name, filename);
  
+ 	if (ioctl (sock, BIOCGDLT, &b) == 0 && b == DLT_IEEE802_11)
+ 		info->use_802_11 = 1;
+ 	else
+ 		info->use_802_11 = 0;
+ 
  	return sock;
  }
  #endif /* USE_BPF_SEND || USE_BPF_RECEIVE */
***************
*** 180,207 ****
  
  #if defined (USE_BPF_RECEIVE) || defined (USE_LPF_RECEIVE)
  /* Packet filter program...
!    XXX Changes to the filter program may require changes to the constant
!    offsets used in if_register_send to patch the BPF program! XXX */
  
  struct bpf_insn dhcp_bpf_filter [] = {
  	/* Make sure this is an IP packet... */
  	BPF_STMT (BPF_LD + BPF_H + BPF_ABS, 12),
  	BPF_JUMP (BPF_JMP + BPF_JEQ + BPF_K, ETHERTYPE_IP, 0, 8),
  
  	/* Make sure it's a UDP packet... */
! 	BPF_STMT (BPF_LD + BPF_B + BPF_ABS, 23),
  	BPF_JUMP (BPF_JMP + BPF_JEQ + BPF_K, IPPROTO_UDP, 0, 6),
  
  	/* Make sure this isn't a fragment... */
! 	BPF_STMT(BPF_LD + BPF_H + BPF_ABS, 20),
  	BPF_JUMP(BPF_JMP + BPF_JSET + BPF_K, 0x1fff, 4, 0),
  
  	/* Get the IP header length... */
! 	BPF_STMT (BPF_LDX + BPF_B + BPF_MSH, 14),
  
  	/* Make sure it's to the right port... */
! 	BPF_STMT (BPF_LD + BPF_H + BPF_IND, 16),
  	BPF_JUMP (BPF_JMP + BPF_JEQ + BPF_K, 67, 0, 1),             /* patch */
  
  	/* If we passed all the tests, ask for the whole packet. */
  	BPF_STMT(BPF_RET+BPF_K, (u_int)-1),
--- 185,279 ----
  
  #if defined (USE_BPF_RECEIVE) || defined (USE_LPF_RECEIVE)
  /* Packet filter program...
!    XXX Adding or deleting instructions to the filter program may
!    XXX require changes to the BPF_FILTER_PORT_OFF constant offset
!    XXX (used in if_register_send to patch the BPF program)!
!    XXX */
! 
! #ifndef	ETHERTYPE_8021Q
! #define	BPF_FILTER_PORT_OFF	8
! #else	/* ETHERTYPE_8021Q */
! #define	BPF_FILTER_PORT_OFF	20
! #endif	/* ETHERTYPE_8021Q */
  
  struct bpf_insn dhcp_bpf_filter [] = {
+ 
  	/* Make sure this is an IP packet... */
  	BPF_STMT (BPF_LD + BPF_H + BPF_ABS, 12),
+ 
+ #ifdef	ETHERTYPE_8021Q
+ 
+ 	/* First, check for an 802.1Q packet */
+ 	BPF_JUMP (BPF_JMP + BPF_JEQ + BPF_K, ETHERTYPE_8021Q, 0, 11),
+ 
+ 		/* Check the real protocol type */
+ 		BPF_STMT (BPF_LD + BPF_H + BPF_ABS, 16),
+ 		BPF_JUMP (BPF_JMP + BPF_JEQ + BPF_K, ETHERTYPE_IP, 0, 18),
+ 
+ 		/* Make sure it's a UDP packet... */
+ 		BPF_STMT (BPF_LD + BPF_B + BPF_ABS, 27),
+ 		BPF_JUMP (BPF_JMP + BPF_JEQ + BPF_K, IPPROTO_UDP, 0, 16),
+ 
+ 		/* Make sure this isn't a fragment... */
+ 		BPF_STMT (BPF_LD + BPF_H + BPF_ABS, 24),
+ 		BPF_JUMP (BPF_JMP + BPF_JSET + BPF_K, 0x1fff, 14, 0),
+ 
+ 		/* Get the IP header length, plus 4 bytes VLAN tag... */
+ 		BPF_STMT (BPF_LD + BPF_IMM, 4),
+ 		BPF_STMT (BPF_LDX + BPF_B + BPF_MSH, 18),
+ 		BPF_STMT (BPF_ALU + BPF_ADD + BPF_X, 0),
+ 		BPF_STMT (BPF_MISC + BPF_TAX, 0),
+ 		BPF_STMT (BPF_JMP + BPF_JA, 6),
+ 
+ #endif	/* ETHERTYPE_8021Q */
+ 
+ 	/* Normal ethernet header, make sure this is an IP packet */
  	BPF_JUMP (BPF_JMP + BPF_JEQ + BPF_K, ETHERTYPE_IP, 0, 8),
  
+ 		/* Make sure it's a UDP packet... */
+ 		BPF_STMT (BPF_LD + BPF_B + BPF_ABS, 23),
+ 		BPF_JUMP (BPF_JMP + BPF_JEQ + BPF_K, IPPROTO_UDP, 0, 6),
+ 
+ 		/* Make sure this isn't a fragment... */
+ 		BPF_STMT (BPF_LD + BPF_H + BPF_ABS, 20),
+ 		BPF_JUMP (BPF_JMP + BPF_JSET + BPF_K, 0x1fff, 4, 0),
+ 
+ 		/* Get the IP header length... */
+ 		BPF_STMT (BPF_LDX + BPF_B + BPF_MSH, 14),
+ 
+ 
+ 	/* Make sure it's to the right port... */
+ 	BPF_STMT (BPF_LD + BPF_H + BPF_IND, 16),
+ 	BPF_JUMP (BPF_JMP + BPF_JEQ + BPF_K, 67, 0, 1),             /* patch */
+ 
+ 	/* If we passed all the tests, ask for the whole packet. */
+ 	BPF_STMT (BPF_RET+BPF_K, (u_int)-1),
+ 
+ 	/* Otherwise, drop it. */
+ 	BPF_STMT (BPF_RET+BPF_K, 0),
+ };
+ 
+ struct bpf_insn dhcp_bpf_filter_11 [] = {
+ #if 0
+ 	/* Make sure this is an IP packet... */
+ 	BPF_STMT (BPF_LD + BPF_H + BPF_ABS, 0),
+ 	BPF_JUMP (BPF_JMP + BPF_JEQ + BPF_K, 8, 0, 8),
+ 
  	/* Make sure it's a UDP packet... */
! 	BPF_STMT (BPF_LD + BPF_B + BPF_ABS, 23+24),
  	BPF_JUMP (BPF_JMP + BPF_JEQ + BPF_K, IPPROTO_UDP, 0, 6),
  
  	/* Make sure this isn't a fragment... */
! 	BPF_STMT(BPF_LD + BPF_H + BPF_ABS, 20+24),
  	BPF_JUMP(BPF_JMP + BPF_JSET + BPF_K, 0x1fff, 4, 0),
  
  	/* Get the IP header length... */
! 	BPF_STMT (BPF_LDX + BPF_B + BPF_MSH, 14+16),
  
  	/* Make sure it's to the right port... */
! 	BPF_STMT (BPF_LD + BPF_H + BPF_IND, 16+24),
  	BPF_JUMP (BPF_JMP + BPF_JEQ + BPF_K, 67, 0, 1),             /* patch */
+ #endif
  
  	/* If we passed all the tests, ask for the whole packet. */
  	BPF_STMT(BPF_RET+BPF_K, (u_int)-1),
***************
*** 215,220 ****
--- 287,293 ----
  #endif
  
  int dhcp_bpf_filter_len = sizeof dhcp_bpf_filter / sizeof (struct bpf_insn);
+ int dhcp_bpf_filter_11_len = sizeof dhcp_bpf_filter_11 / sizeof (struct bpf_insn);
  #if defined (HAVE_TR_SUPPORT)
  struct bpf_insn dhcp_bpf_tr_filter [] = {
          /* accept all token ring packets due to variable length header */
***************
*** 313,326 ****
  			bpf_fddi_filter[7].k += 10;
  		}
  		p.bf_insns = bpf_fddi_filter;
! 	} else
  #endif /* DEC_FDDI */
  	p.bf_insns = dhcp_bpf_filter;
  
!         /* Patch the server port into the BPF  program...
! 	   XXX changes to filter program may require changes
! 	   to the insn number(s) used below! XXX */
! 	dhcp_bpf_filter [8].k = ntohs (local_port);
  
  	if (ioctl (info -> rfdesc, BIOCSETF, &p) < 0)
  		log_fatal ("Can't install packet filter program: %m");
--- 386,405 ----
  			bpf_fddi_filter[7].k += 10;
  		}
  		p.bf_insns = bpf_fddi_filter;
! 	} else 
  #endif /* DEC_FDDI */
  	p.bf_insns = dhcp_bpf_filter;
  
! 	if (info->use_802_11) {
! 		p.bf_len = dhcp_bpf_filter_11_len;
! 		p.bf_insns = dhcp_bpf_filter_11;
! 	}
! 	else {
!         	/* Patch the server port into the BPF  program...
! 	   	XXX changes to filter program may require changes
! 	   	to the insn number(s) used below! XXX */
! 		dhcp_bpf_filter [BPF_FILTER_PORT_OFF].k = ntohs (local_port);
! 	}
  
  	if (ioctl (info -> rfdesc, BIOCSETF, &p) < 0)
  		log_fatal ("Can't install packet filter program: %m");
diff -c common/ethernet.c.orig common/ethernet.c
*** common/ethernet.c.orig	Thu Mar 23 17:22:20 2000
--- common/ethernet.c	Fri Mar  2 09:16:18 2001
***************
*** 90,107 ****
       unsigned bufix;
       struct hardware *from;
  {
    struct ether_header eh;
  
    memcpy (&eh, buf + bufix, ETHER_HEADER_SIZE);
  
  #ifdef USERLAND_FILTER
!   if (ntohs (eh.ether_type) != ETHERTYPE_IP)
  	  return -1;
  #endif
    memcpy (&from -> hbuf [1], eh.ether_shost, sizeof (eh.ether_shost));
    from -> hbuf [0] = ARPHRD_ETHER;
    from -> hlen = (sizeof eh.ether_shost) + 1;
  
!   return ETHER_HEADER_SIZE;
  }
  #endif /* PACKET_DECODING */
--- 90,140 ----
       unsigned bufix;
       struct hardware *from;
  {
+ #ifndef ETHERTYPE_8021Q
    struct ether_header eh;
+ #else
+   union {
+     struct ether_header u_eh;
+     struct ether_8021q_header u_eh1q;
+   } ehu;
+ #define eh ehu.u_eh
+ #define eh1q ehu.u_eh1q
+   int tci, vid;
+ #endif
+   int hlen, type;
  
    memcpy (&eh, buf + bufix, ETHER_HEADER_SIZE);
  
+   type = ntohs (eh.ether_type);
+   hlen = sizeof(eh);
+ 
+ #ifdef ETHERTYPE_8021Q
+   if (type == ETHERTYPE_8021Q) {
+ 	/* 
+ 	 * Grab the VLAN tag info.  Then do some sanity
+ 	 * checking before accepting the packet.
+ 	 */
+ 
+ 	memcpy ((u_char *)&eh1q + ETHER_HEADER_SIZE,
+ 	    buf + bufix + ETHER_HEADER_SIZE, sizeof(eh1q) - ETHER_HEADER_SIZE);
+ 	tci = ntohs (eh1q.evlq_tci);
+ 	if (EVLQ_CFIOFTCI(tci))
+ 		return -1;
+ 	vid = EVLQ_VIDOFTCI(tci);
+ 	if (vid == EVLQ_VID_RESV)
+ 		return -1;
+ 	type = ntohs (eh1q.evlq_proto);
+ 	hlen = sizeof(eh1q);
+   }
+ #endif
+ 
  #ifdef USERLAND_FILTER
!   if (type != ETHERTYPE_IP)
  	  return -1;
  #endif
    memcpy (&from -> hbuf [1], eh.ether_shost, sizeof (eh.ether_shost));
    from -> hbuf [0] = ARPHRD_ETHER;
    from -> hlen = (sizeof eh.ether_shost) + 1;
  
!   return hlen;
  }
  #endif /* PACKET_DECODING */
diff -c common/packet.c.orig common/packet.c
*** common/packet.c.orig	Sun Oct 15 12:54:29 2000
--- common/packet.c	Sat Sep 22 02:43:09 2001
***************
*** 129,134 ****
--- 129,137 ----
  		     assemble_fddi_header (interface, buf, bufix, to);
  	else
  #endif
+ 	if (interface->use_802_11)
+ 		assemble_ieee802_11_header (interface, buf, bufix, to);
+ 	else
  		assemble_ethernet_header (interface, buf, bufix, to);
  
  }
***************
*** 214,219 ****
--- 217,225 ----
  		     return decode_fddi_header (interface, buf, bufix, from);
  	else
  #endif
+ 	if (interface->use_802_11)
+ 		return decode_ieee802_11_header (interface, buf, bufix, from);
+ 	else
  		return decode_ethernet_header (interface, buf, bufix, from);
  }
diff -c includes/cf/bsdos.h.orig includes/cf/bsdos.h
*** includes/cf/bsdos.h.orig	Fri Mar  2 15:42:43 2001
--- includes/cf/bsdos.h	Fri Mar  2 09:17:24 2001
***************
*** 60,65 ****
--- 60,69 ----
  #include <net/if_dl.h>
  #define INADDR_LOOPBACK	((u_int32_t)0x7f000001)
  
+ #ifdef ETHERTYPE_8021Q
+ #include <net/if_vlan.h>
+ #endif
+ 
  /* Varargs stuff... */
  #include <stdarg.h>
  #define VA_DOTDOTDOT ...
diff -c includes/netinet/if_ether.h.orig includes/netinet/if_ether.h
*** includes/netinet/if_ether.h.orig	Fri Mar  2 15:42:43 2001
--- includes/netinet/if_ether.h	Fri Mar  2 10:34:08 2001
***************
*** 43,48 ****
--- 43,50 ----
  	u_int8_t ether_addr_octet[6];
  };
  
+ #if !defined(__bsdi__) || (_BSDI_VERSION < 200005)
+ 
  /*
   * Structure of a 10Mb/s Ethernet header.
   */
***************
*** 71,75 ****
--- 73,78 ----
  
  #define	ETHERMTU	1500
  #define	ETHERMIN	(60-14)
+ #endif /* !defined(__bsdi__) || (_BSDI_VERSION < 200005) */
  
  #define ETHER_HEADER_SIZE (ETHER_ADDR_LEN * 2 + sizeof (u_int16_t))
diff -c server/Makefile.dist.orig server/Makefile.dist
*** server/Makefile.dist.orig	Fri Mar  2 10:35:19 2001
--- server/Makefile.dist	Fri Mar  2 10:35:08 2001
***************
*** 25,30 ****
--- 25,32 ----
  	 omapi.o mdb.o stables.o salloc.o ddns.o
  PROG   = dhcpd
  MAN    = dhcpd.8 dhcpd.conf.5 dhcpd.leases.5
+ SRCS   += aif.c
+ OBJS   += aif.o
  
  DEBUG  = -g
  INCLUDES = -I$(TOP) $(BINDINC) -I$(TOP)/includes
diff -c server/dhcp.c.orig server/dhcp.c
*** server/dhcp.c.orig	Fri Mar  2 10:38:25 2001
--- server/dhcp.c	Fri Mar  2 10:38:06 2001
***************
*** 2422,2427 ****
--- 2422,2435 ----
  	/* Hang the packet off the lease state. */
  	packet_reference (&lease -> state -> packet, packet, MDL);
  
+ #if defined(__bsdi__)
+ 	/*
+ 	 * Ugly, but we don't have the interface type handy.
+ 	 */
+ 	if (memcmp (packet -> interface -> name, "aif", 3) == 0)
+ 		aif_add(packet, lease);
+ #endif
+ 
  	/* If this is a DHCPOFFER, ping the lease address before actually
  	   sending the offer. */
  	if (offer == DHCPOFFER && !(lease -> flags & STATIC_LEASE) &&
diff -c -r1.4 Makefile.conf
*** Makefile.conf	2001/03/06 23:02:56	1.4
--- Makefile.conf	2001/09/19 00:45:04
***************
*** 174,179 ****
--- 174,180 ----
  ##--bsdos-4.1--
  #CF = cf/bsdos.h
  #SCRIPT=bsdos
+ #COPTS = -DUSERLAND_FILTER 
  ##--bsdos-4.1--
  
  ## OpenBSD
*** includes/dhcpd.h.orig	Fri Jun 22 01:57:40 2001
--- includes/dhcpd.h	Sat Sep 22 02:40:18 2001
***************
*** 781,786 ****
--- 781,788 ----
  	int dlpi_sap_length;
  	struct hardware dlpi_broadcast_addr;
  # endif /* DLPI_SEND || DLPI_RECEIVE */
+ 
+ 	int	use_802_11;		/* XXX kludge around HTYPE_* */
  };
  
  struct hardware_link {
