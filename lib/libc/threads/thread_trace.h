/*-
 * Copyright (c) 1996 Berkeley Software Design, Inc. All rights reserved.
 * The Berkeley Software Design Inc. software License Agreement specifies
 * the terms and conditions for redistribution.
 *
 *      BSDI thread_trace.h,v 1.4 1999/10/04 15:51:41 jch Exp
 */

#ifndef _THREAD_TRACE_H
#define _THREAD_TRACE_H

/*
 *	Wraparound thread trace buffer.
 *
 *	To enable tracing globally add '-DKTR' to the +CFLAGS definition in
 * 	the Makefile.inc in this directory.
 *
 *	This tracing is intended to be lightweight enough to run in a
 *	production environment (if need be). It is used much like
 *	printf, however for each trace call (actually inline via a
 *	macro) only a trace entry (5 words) is updated (the time, a
 *	pointer to the printf style string, and two parameter words).
 *
 *  Usage:
 *    Unconditional traces:
 *	TR(fmt, p1, p2)		- Simple trace entry
 *
 *  Notes:
 *	'fmt' is a pointer to a character string, usually generated by the
 *	compiler (as in "xxxx"). Only the pointer is stored, if the string
 *	is not constant then the result when the buffer is formatted may
 *	not be what is expected.
 *
 *	'p1' and 'p2' may be any small (4 bytes or less) data type, they
 *	are cast into an unsigned long.
 *
 *	The trace buffer can be inspected by hand with gdb, by using the
 *	tdump script for gdb, or by running the tdump program (this is the
 *	preferred method).
 */

/* Requires sys/types.h and sys/time.h */
#include <sys/types.h>
#include <sys/time.h>

struct pttr_entry {
	struct	timeval pttr_tv;
	char	*pttr_desc;
	u_long	pttr_parm1;
	u_long	pttr_parm2;
};

#ifdef KTR
extern struct pttr_entry pttr_buf[];
extern volatile int pttr_idx;
extern int pttr_mask;
extern int pttr_size;
extern int pttr_size_mask;

#ifdef NEVER
#define _TR(_desc, _p1, _p2) { \
	volatile struct pttr_entry *_ktrptr;			\
	int _idx;						\
	_idx = pttr_idx;						\
	_ktrptr = &pttr_buf[_idx];                               \
	pttr_idx = (_idx + 1) & (pttr_size_mask);                 \
	_ktrptr->pttr_tv.tv_sec = 0;				\
	_ktrptr->pttr_tv.tv_usec = 0;				\
	_ktrptr->pttr_desc = (_desc);				\
	_ktrptr->pttr_parm1 = (u_long)(_p1);			\
	_ktrptr->pttr_parm2 = (u_long)(_p2);			\
}

#define	TR(_desc, _p1, _p2) _TR(_desc, _p1, _p2)
#endif

#define	TR(_desc, _p1, _p2) \
	_thread_trace(_desc, _p1, _p2)
#else	/* KTR */
#define	TR(_desc, _p1, _p2)
#endif	/* KTR */
#endif /* ifndef _THREAD_TRACE_H */
