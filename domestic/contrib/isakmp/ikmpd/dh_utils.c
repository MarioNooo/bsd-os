/* 
 * Id: dh_utils.c,v 1.2 1997/04/12 01:02:05 dharkins Exp
 * Source: /nfs/cscbz/cryptocvs/isakmp/ikmpd/dh_utils.c,v
 */
/*
 *  Copyright Cisco Systems, Incorporated
 *
 *  Cisco Systems grants permission for redistribution and use in source 
 *  and binary forms, with or without modification, provided that the 
 *  following conditions are met:
 *     1. Redistribution of source code must retain the above copyright
 *        notice, this list of conditions, and the following disclaimer
 *        in all source files.
 *     2. Redistribution in binary form must retain the above copyright
 *        notice, this list of conditions, and the following disclaimer
 *        in the documentation and/or other materials provided with the
 *        distribution.
 *
 *  "DISCLAIMER OF LIABILITY
 *  
 *  THIS SOFTWARE IS PROVIDED BY CISCO SYSTEMS, INC. ("CISCO")  ``AS IS'' 
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 *  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 *  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL CISCO BE LIABLE FOR ANY DIRECT, 
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 *  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 *  SUCH DAMAGE."
 */
#ifndef MULTINET
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#else
#include <types.h>
#endif /* MULTINET */
#include <netinet/in.h>
#include "isakmp.h"
#include "isadb.h"
#include "protocol.h"

#define GROUP_MAX_DEFINES 2

/*
 * dh_utils.c -- placeholder for routines to generate (and validate?)
 *	MODP groups for use with Diffie-Hellman
 */

/*
 * to add new default groups, define their value, add them to their sub-group
 * (modp or elliptical curve), and add an entry in def_oakley_groups[].
 */

static unsigned char def1_p[96] =
     { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
       0xc9, 0x0f, 0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34,
       0xc4, 0xc6, 0x62, 0x8b, 0x80, 0xdc, 0x1c, 0xd1,
       0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67, 0xcc, 0x74,
       0x02, 0x0b, 0xbe, 0xa6, 0x3b, 0x13, 0x9b, 0x22,
       0x51, 0x4a, 0x08, 0x79, 0x8e, 0x34, 0x04, 0xdd,
       0xef, 0x95, 0x19, 0xb3, 0xcd, 0x3a, 0x43, 0x1b,
       0x30, 0x2b, 0x0a, 0x6d, 0xf2, 0x5f, 0x14, 0x37,
       0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51, 0xc2, 0x45,
       0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
       0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x3a, 0x36, 0x20,
       0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
     };

static unsigned char def1_g[96] =
     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02
     };

static unsigned char DH_g[64] =
     { 0xc9, 0x07, 0x86, 0xbf, 0x92, 0x6c, 0x1e, 0x51,
       0xa5, 0xb6, 0xe6, 0xe1, 0x9d, 0x0b, 0xc6, 0x50,
       0xab, 0x49, 0x77, 0xe6, 0x3c, 0xc7, 0x32, 0x1c,
       0x3f, 0x24, 0xb3, 0x2d, 0xd6, 0x22, 0x40, 0x01,
       0x32, 0x19, 0x34, 0x35, 0x15, 0xdf, 0xa5, 0x63,
       0x33, 0xe1, 0x35, 0xc1, 0x7e, 0x98, 0xf1, 0x92,
       0x0f, 0xc5, 0x6c, 0xf4, 0x3f, 0x73, 0x4e, 0xf6,
       0x9d, 0x9d, 0xf5, 0xd0, 0xd6, 0x06, 0x9a, 0x3c};
 
static unsigned char DH_p[64] =
     { 0xff, 0xe2, 0x14, 0x9a, 0xfd, 0xcd, 0x25, 0x47,
       0x1c, 0xaf, 0x1a, 0x7c, 0xd4, 0xeb, 0xdd, 0xf8,
       0xc0, 0x88, 0x66, 0xbe, 0xf2, 0x61, 0xb6, 0xe5,
       0x1f, 0x2b, 0xf0, 0x5c, 0xb4, 0x94, 0x9d, 0xa9,
       0x30, 0x85, 0xe4, 0xe4, 0xed, 0x4d, 0x4d, 0xcb,
       0x2a, 0xe4, 0x7e, 0x5f, 0x6e, 0xef, 0x39, 0xf9,
       0xb5, 0xb6, 0xca, 0x25, 0x5f, 0xcf, 0x3b, 0x2f,
       0x70, 0x8b, 0xa0, 0x64, 0x72, 0xa8, 0x49, 0xfb};

static unsigned char def2_p[128] =
     { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
       0xc9, 0x0f, 0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34,
       0xc4, 0xc6, 0x62, 0x8b, 0x80, 0xdc, 0x1c, 0xd1,
       0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67, 0xcc, 0x74,
       0x02, 0x0b, 0xbe, 0xa6, 0x3b, 0x13, 0x9b, 0x22,
       0x51, 0x4a, 0x08, 0x79, 0x8e, 0x34, 0x04, 0xdd,
       0xef, 0x95, 0x19, 0xb3, 0xcd, 0x3a, 0x43, 0x1b,
       0x30, 0x2b, 0x0a, 0x6d, 0xf2, 0x5f, 0x14, 0x37,
       0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51, 0xc2, 0x45,
       0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
       0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x37, 0xed, 0x6b,
       0x0b, 0xff, 0x5c, 0xb6, 0xf4, 0x06, 0xb7, 0xed,
       0xee, 0x38, 0x6b, 0xfb, 0x5a, 0x89, 0x9f, 0xa5,
       0xae, 0x9f, 0x24, 0x11, 0x7c, 0x4b, 0x1f, 0xe6,
       0x49, 0x28, 0x66, 0x51, 0xec, 0xe6, 0x53, 0x81,
       0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
     };

static unsigned char def2_g[128] =
     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02
     };

struct ecp_groups {
	unsigned short prime_len;
	unsigned char *p;
	unsigned short cp1_len;
	unsigned char *curve_p1;
	unsigned short cp2_len;
	unsigned char *curve_p2;
	unsigned short gen1_len;
	unsigned char *g1;
	unsigned short gen2_len;
	unsigned char *g2;
}; /* need to define something here... */

struct modp_groups {
	unsigned char *p;
	unsigned short p_len;
	unsigned char *g;
	unsigned short g_len;
} def_modp_groups[] = {
	{ def1_p, 96, def1_g, 96 },
	{ def2_p, 128, def2_g, 128 },
	{ DH_p, 64, DH_g, 64 }		/* this group is for illustration */
}					/* only. Don't use it-- too weak  */;

/*
 * set the prime and generator to be the indx'th entry in the list of
 * modp groups.
 */
int dh_modp_set (int modp_indx, unsigned char **p, unsigned short *plen,
                unsigned char **g, unsigned short *glen)
{
    if(modp_indx < 0)
        return(1);
    *glen = def_modp_groups[modp_indx].g_len;
    *g = (unsigned char *) malloc (*glen * sizeof(unsigned char));
    if(*g == NULL){
	LOG((ERR, "Out Of Memory"));
	return(1);
    }
    bcopy((char *)def_modp_groups[modp_indx].g, (char *)*g, *glen);
 
    *plen = def_modp_groups[modp_indx].p_len;
    *p = (unsigned char *) malloc (*plen * sizeof(unsigned char));
    if(*p == NULL){
	LOG((ERR, "Out Of Memory"));
	return(1);
    }
    bcopy((char *)def_modp_groups[modp_indx].p, (char *)*p, *plen);
    return(0);
}

/*
 * get the specified MODP group into a SA. Make the DH buffers.
 */
int dh_modp_find (struct dh_stuff *dh, int indx)
{
    if(dh->group.modp.gen_len || dh->group.modp.prime_len)
	return(1);
    if(dh_modp_set(indx, &dh->group.modp.p, &dh->group.modp.prime_len,
		       &dh->group.modp.g, &dh->group.modp.gen_len)){
	return(1);
    }

    dh->DH_priv_val = (unsigned char *) malloc (dh->group.modp.prime_len);
    if(dh->DH_priv_val == NULL){
	LOG((ERR, "Out Of Memory: DH priv val"));
	return(1);
    }
    dh->DH_pub_val = (unsigned char *) malloc (dh->group.modp.prime_len);
    if(dh->DH_pub_val == NULL){
	LOG((ERR, "Out Of Memory: DH pub val"));
	free(dh->DH_priv_val);
	return(1);
    }
    dh->his_DH_pub_val = (unsigned char *) malloc (dh->group.modp.prime_len);
    if(dh->his_DH_pub_val == NULL){
	LOG((ERR, "Out Of Memory: other DH pub val"));
	free(dh->DH_priv_val);
	free(dh->DH_pub_val);
	return(1);
    }
    dh->g_to_xy = (unsigned char *) malloc (dh->group.modp.prime_len);
    if(dh->g_to_xy == NULL){
	LOG((ERR, "Out Of Memory: g^xy"));
	free(dh->DH_priv_val);
	free(dh->DH_pub_val);
	free(dh->his_DH_pub_val);
	return(1);
    }
    dh->dh_len = dh->group.modp.prime_len;
    return(0);
}

/*
 * the default Oakley Groups can be either modp or elliptical curves.
 * This structure is a top-level index into each sub-group and an index
 * into that sub-group's defined groups.
 */
struct oakley_groups {
	int (*group_finder)(struct dh_stuff *dh, int indx);
	int type;
} def_oakley_groups[] = {
	{ dh_modp_find, 0 },	/* default group 1 */
	{ dh_modp_find, 1 } 
};
/* this too is for illustration only. 
	{ dh_ecp_find, 0 },	define other default groups by the
	{ dh_modp_find, 1 },	routine in which they're found and
	{ dh_modp_find, 2 },	the index into that type's array of
	{ dh_ecp_find, 1 }	defaults. Simple, right?
*/

/*
 * DH groups are identified by Oakley as simple numbers. The oakley_groups
 * array arranges them according to type and index into type. E.g., If group
 * 5 is an ECP group, then the 5th entry of oakley_groups specifies the
 * 2nd (starting with 0) in the ECP groups (as above). dh_ecp_find() will 
 * stuff the specifics of that group into the SA.
 */
int dh_group_find (int group_desc, struct dh_stuff *dh)
{
    if((group_desc > GROUP_MAX_DEFINES) || (group_desc < 1))
	return(1);
    return(def_oakley_groups[group_desc-1].group_finder(
		dh, 
		def_oakley_groups[group_desc-1].type));
}

