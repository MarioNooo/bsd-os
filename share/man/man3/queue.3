.\" Copyright (c) 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"	@(#)queue.3	8.3 (Berkeley) 8/20/94
.\"
.\" The NI (normal introduction) macro takes 2 arguments:
.\"	+ The name of the structure, e.g., LIST_HEAD
.\"	+ The name of the entry macro, e.g., LIST_ENTRY
.de NI
A
.Fa \\$1
structure is declared as follows:
.Bd -literal -offset indent
\\$1(HEADNAME, TYPE);
.Ed
.sp
where
.Fa HEADNAME
is the name of the structure to be defined, and
.Fa TYPE
is the type of the elements to be linked into the list.
A structure representing the head of the list,
or a pointer to the head of the list can later be declared as follows:
.Bd -literal -offset indent
struct HEADNAME head;
struct HEADNAME *headp;
.Ed
.sp
where the names
.Li head
and
.Li headp
are user selectable.
.Pp
In the macro arguments,
.Fa TYPE
is the name of a user defined structure,
that must contain a field named
.Fa NAME ,
of type
.Li \\$2 .
..
.\"
.\"
.Dd "August 20, 1994"
.Dt QUEUE 3
.Os BSD 4
.Sh NAME
.Nm queue
.Nd "implementations of simple list queues, tail queues, and circular queues"
.Sh DESCRIPTION
These macros define and operate on three types of data structures:
lists, tail queues, and circular queues.
All three structures support the following functionality:
.Bl -enum -compact -offset indent
.It
Insertion of a new entry at the head of the list.
.It
Insertion of a new entry after any element in the list.
.It
Insertion of a new entry before any element in the list.
.It
Removal of any entry in the list.
.It
Forward traversal through the list.
.El
.Pp
Lists are the simplest of the three data structures and support
only the above functionality.
.Pp
Tail queues add the following functionality:
.Bl -enum -compact -offset indent
.It
Entries can be added at the end of a list.
.It
They may be traversed backwards, from tail to head.
.El
.Pp
However:
.Bl -enum -compact -offset indent
.It
All list insertions and removals must specify the head of the list.
.It
Each head entry requires two pointers rather than one.
.It
Reverse traversal is 50% slower than circular queues.
.It
Code size is about 15% greater and operations run about 20% slower
than lists.
.El
.Pp
Circular queues add the following functionality:
.Bl -enum -compact -offset indent
.It
Entries can be added at the end of a list.
.It
They may be traversed backwards, from tail to head.
.El
.Pp
However:
.Bl -enum -compact -offset indent
.It
All list insertions and removals must specify the head of the list.
.It
Each head entry requires two pointers rather than one.
.It
The termination condition for traversal is more complex.
.It
Code size is about 40% greater and operations run about 45% slower
than lists.
.El
.Sh LIST SYNOPSIS
.Fd #include <stddef.h>
.Fd #include <sys/queue.h>
.sp
.Fn LIST_END "LIST_HEAD *headp" ;
.br
.Fn LIST_ENTRY "TYPE" ;
.br
.Fn LIST_FIRST "LIST_HEAD *headp" ;
.br
.Fn LIST_HEAD "HEADNAME" "TYPE" ;
.br
.Fn LIST_INIT "LIST_HEAD *headp" ;
.br
.Fn LIST_INSERT_AFTER "LIST_ENTRY *listelm" "TYPE *elm" "LIST_ENTRY NAME" ;
.br
.Fn LIST_INSERT_BEFORE "LIST_ENTRY *listelm" "TYPE *elm" "LIST_ENTRY NAME" ;
.br
.Fn LIST_INSERT_HEAD "LIST_HEAD *headp" "TYPE *elm" "LIST_ENTRY NAME" ;
.br
.Fn LIST_NEXT "TYPE *elm" "LIST_ENTRY NAME" ;
.br
.Fn LIST_REMOVE "TYPE *elm" "LIST_ENTRY NAME" ;
.Pp
A list is headed by a structure defined by the
.Nm LIST_HEAD
macro.
This structure contains a single pointer to the first element
on the list.
The elements are doubly linked so that an arbitrary element can be
removed without traversing the list.
New elements can be added to the list after or before an existing
element or at the head of the list.
.NI LIST_HEAD LIST_ENTRY
.Pp
The
.Nm LIST_END
macro returns the pointer value indicating the end of the list.
Note that the parameter to the
.Nm LIST_END
macro that points to the head of the list is unused and may be specified as
.Nm NULL .
The
.Nm LIST_END
macro has a parameter only to keep it consistent with the
.Nm CIRCLEQ_END
macro.
.Pp
The
.Nm LIST_ENTRY
macro declares a structure that connects the elements in
the list.
.Pp
The
.Nm LIST_FIRST
macro returns a pointer to the first element of the list.
When this pointer is the same as the pointer returned by the
.Nm LIST_END
macro the list is empty.
.Pp
The
.Nm LIST_INIT
macro initializes the list referenced by
.Fa headp .
.Pp
The
.Nm LIST_INSERT_HEAD
macro inserts the new element
.Fa elm
at the head of the list.
.Pp
The
.Nm LIST_INSERT_AFTER
macro inserts the new element
.Fa elm
after the element
.Fa listelm .
.Pp
The
.Nm LIST_INSERT_BEFORE
macro inserts the new element
.Fa elm
before the element
.Fa listelm .
.Pp
The
.Nm LIST_NEXT
macro returns a pointer to the next element in the list.
Upon reaching the end of the list this pointer will be the
same as the pointer returned by the
.Nm LIST_END
macro.
.Pp
The
.Nm LIST_REMOVE
macro removes the element
.Fa elm
from the list.
.Sh LIST EXAMPLE
.Bd -literal
LIST_HEAD(listhead, entry) head;
struct listhead *headp;				/* List head. */
struct entry {
	...
	LIST_ENTRY(entry) entries;		/* List. */
	...
} *n1, *n2, *np;

headp = &head;
LIST_INIT(headp);				/* Initialize the list. */

n1 = malloc(sizeof(struct entry));		/* Insert at head. */
LIST_INSERT_HEAD(headp, n1, entries);

n2 = malloc(sizeof(struct entry));		/* Insert after element. */
LIST_INSERT_AFTER(n1, n2, entries);

n2 = malloc(sizeof(struct entry));		/* Insert before element. */
LIST_INSERT_BEFORE(n1, n2, entries);
						/* Forward traversal. */
for (np = LIST_FIRST(headp); np != LIST_END(NULL);
    np = LIST_NEXT(np, entries))
	np-> ...
while (LIST_FIRST(headp) != LIST_END(NULL))	/* Empty list. */
	LIST_REMOVE(LIST_FIRST(headp), entries);
.Ed
.Sh TAIL QUEUE SYNOPSIS
.Fd #include <stddef.h>
.Fd #include <sys/queue.h>
.sp
.Fn TAILQ_END "TAILQ_HEAD *headp" ;
.br
.Fn TAILQ_ENTRY "TYPE" ;
.br
.Fn TAILQ_FIRST "TAILQ_HEAD *headp" ;
.br
.Fn TAILQ_HEAD "HEADNAME" "TYPE" ;
.br
.Fn TAILQ_INIT "TAILQ_HEAD *headp" ;
.br
.Fn TAILQ_INSERT_AFTER "TAILQ_HEAD *headp" "TYPE *listelm" "TYPE *elm" "TAILQ_ENTRY NAME" ;
.br
.Fn TAILQ_INSERT_BEFORE "TAILQ_HEAD *headp" "TYPE *listelm" "TYPE *elm" "TAILQ_ENTRY NAME" ;
.br
.Fn TAILQ_INSERT_HEAD "TAILQ_HEAD *headp" "TYPE *elm" "TAILQ_ENTRY NAME" ;
.br
.Fn TAILQ_INSERT_TAIL "TAILQ_HEAD *headp" "TYPE *elm" "TAILQ_ENTRY NAME" ;
.br
.Fn TAILQ_NEXT "TYPE *elm" "TAILQ_ENTRY NAME" ;
.br
.Fn TAILQ_PREV "TYPE *elm" "HEADNAME" "TAILQ_ENTRY NAME" ;
.br
.Fn TAILQ_LAST "TAILQ_HEAD *headp" "HEADNAME" ;
.br
.Fn TAILQ_REMOVE "TAILQ_HEAD *headp" "TYPE *elm" "TAILQ_ENTRY NAME" ;
.Pp
A tail queue is headed by a structure defined by the
.Nm TAILQ_HEAD
macro.
This structure contains a pair of pointers,
one to the first element in the tail queue and the other to
the last element in the tail queue.
The elements are doubly linked so that an arbitrary element can be
removed without traversing the tail queue.
New elements can be added to the tail queue after an existing element,
before an existing element, at the head of the tail queue, or at the
end of the tail queue.
.NI TAILQ_HEAD TAILQ_ENTRY
.Pp
The
.Nm TAILQ_END
macro returns the pointer value indicating the end of the tail queue.
Note that the parameter to the
.Nm TAILQ_END
macro that points to the head of the list is unused and may be specified as
.Nm NULL .
The
.Nm TAILQ_END
macro has a parameter only to keep it consistent with the
.Nm CIRCLEQ_END
macro.
.Pp
The
.Nm TAILQ_ENTRY
macro declares a structure that connects the elements in the tail queue.
.Pp
The
.Nm TAILQ_FIRST
macro returns a pointer to the first element of the tail queue.
When this pointer is the same as the pointer returned by the
.Nm TAILQ_END
macro the tail queue is empty.
.Pp
The
.Nm TAILQ_INIT
macro initializes the tail queue referenced by
.Fa headp .
.Pp
The
.Nm TAILQ_INSERT_AFTER
macro inserts the new element
.Fa elm
after the element
.Fa listelm .
.Pp
The
.Nm TAILQ_INSERT_BEFORE
macro inserts the new element
.Fa elm
before the element
.Fa listelm .
.Pp
The
.Nm TAILQ_INSERT_HEAD
macro inserts the new element
.Fa elm
at the head of the tail queue.
.Pp
The
.Nm TAILQ_INSERT_TAIL
macro inserts the new element
.Fa elm
at the end of the tail queue.
.Pp
The
.Nm TAILQ_LAST
macro returns a pointer to the last element of the tail queue.
When this pointer is the same as the pointer returned by the
.Nm TAILQ_END
macro the tail queue is empty.
.Pp
The
.Nm TAILQ_NEXT
macro returns a pointer to the next element in the tail queue.
Upon reaching the end of the tail queue this pointer will be the
same as the pointer returned by the
.Nm TAILQ_END
macro.
.Pp
The
.Nm TAILQ_PREV
macro returns a pointer to the previous element in the tail queue.
Upon reaching the end of the tail queue this pointer will be the
same as the pointer returned by the
.Nm TAILQ_END
macro.
.Pp
The
.Nm TAILQ_REMOVE
macro removes the element
.Fa elm
from the tail queue.
.Sh TAIL QUEUE EXAMPLE
.Bd -literal
TAILQ_HEAD(tailhead, entry) head;
struct tailhead *headp;		/* Tail queue head. */
struct entry {
	...
	TAILQ_ENTRY(entry) entries;	/* Tail queue. */
	...
} *n1, *n2, *np;

headp = &head;
TAILQ_INIT(headp);			/* Initialize the tailq. */

n1 = malloc(sizeof(struct entry));	/* Insert at head. */
TAILQ_INSERT_HEAD(headp, n1, entries);

n1 = malloc(sizeof(struct entry));	/* Insert at tail. */
TAILQ_INSERT_TAIL(headp, n1, entries);

n2 = malloc(sizeof(struct entry));	/* Insert after element. */
TAILQ_INSERT_AFTER(headp, n1, n2, entries);

n2 = malloc(sizeof(struct entry));	/* Insert before element. */
TAILQ_INSERT_BEFORE(headp, n1, n2, entries);
					/* Forward traversal. */
for (np = TAILQ_FIRST(headp); np != TAILQ_END(NULL);
    np = TAILQ_NEXT(np, entries))
	np-> ...
					/* Reverse traversal. */
for (np = TAILQ_LAST(headp, tailhead); np != TAILQ_END(NULL);
    np = TAILQ_PREV(np, tailhead, entries))
	np-> ...
					/* Empty list. */
while (TAILQ_FIRST(headp) != TAILQ_END(NULL))
	TAILQ_REMOVE(headp, TAILQ_FIRST(headp), entries);
.Ed
.Sh CIRCULAR QUEUE SYNOPSIS
.Fd #include <stddef.h>
.Fd #include <sys/queue.h>
.sp
.Fn CIRCLEQ_END "CIRCLEQ_HEAD *headp" ;
.br
.Fn CIRCLEQ_ENTRY "TYPE" ;
.br
.Fn CIRCLEQ_FIRST "CIRCLEQ_HEAD *headp" ;
.br
.Fn CIRCLEQ_HEAD "HEADNAME" "TYPE" ;
.br
.Fn CIRCLEQ_INIT "CIRCLEQ_HEAD *headp" ;
.br
.Fn CIRCLEQ_INSERT_AFTER "CIRCLEQ_HEAD *headp" "TYPE *listelm" "TYPE *elm" "CIRCLEQ_ENTRY NAME" ;
.br
.Fn CIRCLEQ_INSERT_BEFORE "CIRCLEQ_HEAD *headp" "TYPE *listelm" "TYPE *elm" "CIRCLEQ_ENTRY NAME" ;
.br
.Fn CIRCLEQ_INSERT_HEAD "CIRCLEQ_HEAD *headp" "TYPE *elm" "CIRCLEQ_ENTRY NAME" ;
.br
.Fn CIRCLEQ_INSERT_TAIL "CIRCLEQ_HEAD *headp" "TYPE *elm" "CIRCLEQ_ENTRY NAME" ;
.br
.Fn CIRCLEQ_NEXT "TYPE *elm" "CIRCLEQ_ENTRY NAME" ;
.br
.Fn CIRCLEQ_PREV "TYPE *elm" "CIRCLEQ_ENTRY NAME" ;
.br
.Fn CIRCLEQ_LAST "CIRCLEQ_HEAD *headp" ;
.br
.Fn CIRCLEQ_REMOVE "CIRCLEQ_HEAD *headp" "TYPE *elm" "CIRCLEQ_ENTRY NAME" ;
.Pp
A circular queue is headed by a structure defined by the
.Nm CIRCLEQ_HEAD
macro.
This structure contains a pair of pointers,
one to the first element in the circular queue and the other to the
last element in the circular queue.
The elements are doubly linked so that an arbitrary element can be
removed without traversing the queue.
New elements can be added to the queue after an existing element,
before an existing element, at the head of the queue, or at the end
of the queue.
.NI CIRCLEQ_HEAD CIRCLEQ_ENTRY
.Pp
The
.Nm CIRCLEQ_END
macro returns the pointer value indicating the end of the circle queue.
.Pp
The
.Nm CIRCLEQ_ENTRY
macro declares a structure that connects the elements in
the circular queue.
.Pp
The
.Nm CIRCLEQ_FIRST
macro returns a pointer to the first element of the circle queue.
When this pointer is the same as the pointer returned by the
.Nm CIRCLEQ_END
macro the circle queue is empty.
.Pp
The
.Nm CIRCLEQ_INIT
macro initializes the circular queue referenced by
.Fa headp .
.Pp
The
.Nm CIRCLEQ_INSERT_AFTER
macro inserts the new element
.Fa elm
after the element
.Fa listelm .
.Pp
The
.Nm CIRCLEQ_INSERT_BEFORE
macro inserts the new element
.Fa elm
before the element
.Fa listelm .
.Pp
The
.Nm CIRCLEQ_INSERT_HEAD
macro inserts the new element
.Fa elm
at the head of the circular queue.
.Pp
The
.Nm CIRCLEQ_INSERT_TAIL
macro inserts the new element
.Fa elm
at the end of the circular queue.
.Pp
The
.Nm CIRCLEQ_LAST
macro returns a pointer to the last element of the circle queue.
When this pointer is the same as the pointer returned by the
.Nm CIRCLEQ_END
macro the circle queue is empty.
.Pp
The
.Nm CIRCLEQ_NEXT
macro returns a pointer to the next element in the circle queue.
Upon reaching the end of the circle queue this pointer will be the
same as the pointer returned by the
.Nm CIRCLEQ_END
macro.
.Pp
The
.Nm CIRCLEQ_PREV
macro returns a pointer to the previous element in the circle queue.
Upon reaching the end of the circle queue this pointer will be the
same as the pointer returned by the
.Nm CIRCLEQ_END
macro.
.Pp
The
.Nm CIRCLEQ_REMOVE
macro removes the element
.Fa elm
from the circular queue.
.Sh CIRCULAR QUEUE EXAMPLE
.Bd -literal
CIRCLEQ_HEAD(circleq, entry) head;
struct circleq *headp;			/* Circular queue head. */
struct entry {
	...
	CIRCLEQ_ENTRY entries;		/* Circular queue. */
	...
} *n1, *n2, *np;

headp = &head;
CIRCLEQ_INIT(headp);			/* Initialize the circleq. */

n1 = malloc(sizeof(struct entry));	/* Insert at head. */
CIRCLEQ_INSERT_HEAD(headp, n1, entries);

n1 = malloc(sizeof(struct entry));	/* Insert at tail. */
CIRCLEQ_INSERT_TAIL(headp, n1, entries);

n2 = malloc(sizeof(struct entry));	/* Insert after element. */
CIRCLEQ_INSERT_AFTER(headp, n1, n2, entries);

n2 = malloc(sizeof(struct entry));	/* Insert before element. */
CIRCLEQ_INSERT_BEFORE(headp, n1, n2, entries);
					/* Forward traversal. */
for (np = CIRCLEQ_FIRST(headp); np != CIRCLEQ_END(headp);
    np = CIRCLEQ_NEXT(np, entries))
	np-> ...
					/* Reverse traversal. */
for (np = CIRCLEQ_LAST(headp); np != CIRCLEQ_END(headp);
    np = CIRCLEQ_PREV(np, entries))
	np-> ...
					/* Empty list. */
while (CIRCLEQ_FIRST(headp) != CIRCLEQ_END(headp))
	CIRCLEQ_REMOVE(headp, CIRCLEQ_FIRST(headp), entries);
.Ed
.Sh HISTORY
The
.Nm queue
functions first appeared in 4.4BSD.
