#!/bin/sh -
#
#	BSDI MAKEDEV,v 2.49 2003/09/04 18:45:44 prb Exp
#	from @(#)MAKEDEV     8.1 (Berkeley) 6/9/93
#

# Device "make" file.  Valid arguments:
#	ebsd		standard devices for minimal e/BSD flash system
#	floppystd	standard devices for floppy install
#	std		standard devices
#	local		configuration specific devices
#
# Tapes:
#	wt*	QIC-interfaced (e.g. not SCSI) 3M cartridge tape
#	st*	generic SCSI tape
#
# Disks:
#	wd*	"winchester" disk drives (ST506,IDE,ESDI,RLL,...)
#	fd*	"floppy" disk drives (3 1/2", 5 1/4")
#	sd*	generic SCSI fixed disks
#	sr*	generic SCSI removable disks
#	sp*	splice driver - concatenation and stripes
#	vnd*	vnode-disk driver
#	rd	ram-disk driver
#	dptr*	DPT HBA driver
#	cr*	Compaq Smart-2 Raid driver
#	amir*	AMI MegaRAID driver
#	aacr*	Adaptec RAID driver
#	dpti*	DPT I2O HBA driver
#	dc*	Disk On Chip 2000
#
# Terminal ports:
#	com*	standard PC COM ports		 (tty[01][0-9])
#			(tty* is alias for com*)
#	cy*	Cyclades Cyclom-Y serial cards	 (ttyy[0-3][a-p])
#		cy or cy0 first Cyclades board	 (ttyy0[a-p])
#		cy1 second Cyclades board	 (ttyy1[a-p])
#		cy2 third Cyclades board	 (ttyy2[a-p])
#		cy3 fourth Cyclades board	 (ttyy3[a-p])
#	digi*	various Digiboard products	 (tty[A-D][00-3f])
#		digi or digi0 or digi0.0	 (ttyA[00-0f])
#		digi0.1	ports 16-31		 (ttyA[10-1f])
#		digi0.3	ports 48-63		 (ttyA[30-3f])
#		digi1.0 second digi board	 (ttyB[00-0f])
#		digi3.0	fourth digi board	 (ttyD[00-0f])
#	ms*	MAXPEED SS-8/XU2, SS-4/XU2, etc. (tty[h-o][0-7])
#	rc*	SDL Communications RISCom/8	 (tty[a-f][0-7])
#	rp*	Comtrol RocketPort cards	 (tty[RSTU][0-31]
#		rp0 first RocketPort card	 (ttyR[0-31])
#		rp1 second RocketPort card	 (ttyS[0-31])
#		rp2 third RocketPort card	 (ttyT[0-31])
#		rp3 forth RocketPort card	 (ttyU[0-31])
#		rp0.4 first card with 4 ports	 (ttyR[0-3])
#	si*	Specialix SLXOS serial adapter	 (tty[ab][0-31])
#						 (tty[ab][0-31]_xp)
#						 (si_control)
#	stl*	Stallion Technologies cards      (tty[E-H][00-64]
#		stl0 1st Stallion dumb card      (ttyE[00-64])
#		stl1 2nd Stallion dumb card      (ttyF[00-64])
#		stl2 3rd Stallion dumb card      (ttyG[00-64])
#		stl3 4th Stallion dumb card      (ttyH[00-64])
#		stli0 1st Stallion smart card    (ttyI[00-64])
#		stli1 2nd Stallion smart card    (ttyJ[00-64])
#		stli2 3rd Stallion smart card    (ttyK[00-64])
#		stli3 4th Stallion smart card    (ttyL[00-64])
#		Stallion control devices         (stliomem[0-7])
#
# Pseudo terminals:
#	pty*	set of 16 master and slave pseudo terminals
#
# Printers:
#	lp*	standard PC LPT ports
#
# Call units:
#
# Special purpose devices:
#	conskbd*	PC display console (and virtual screens)
#	bpf*		Berkeley packet filter
#	sg*		SCSI generic, any SCSI device not tape or disk
#	tun*		Network Tunnel Interface
#	vio*		Wind River Virtual IOs
#

# Mknod(1) treats 01 as an octal number, so we strip leading 0's
# from unit numbers.  Do it in one place.
getunit()
{
	echo `expr $1 : '[a-z]*0*\(..*\)'`
}

PATH=$PATH:/sbin:/usr/sbin
umask 077
for i
do
case $i in

ebsd)
	# Standard devices
	mknod console		c 0 0
	mknod drum		c 4 0	; chmod 640 drum ; chgrp kmem drum
	mknod kmem		c 2 1	; chmod 640 kmem ; chgrp kmem kmem
	mknod mem		c 2 0	; chmod 640 mem  ; chgrp kmem mem
	mknod null		c 2 2	; chmod 666 null
	mknod zero		c 2 12	; chmod 666 zero
	mknod tty		c 1 0	; chmod 666 tty
	mknod klog		c 7 0	; chmod 600 klog
	mknod stdin		c 15 0	; chmod 666 stdin
	mknod stdout		c 15 1	; chmod 666 stdout
	mknod stderr		c 15 2	; chmod 666 stderr

	# VGA and Keyboard
	mknod iomem		c 2 13	; chmod 600 iomem
	mknod vga		c 16 0	; chmod 600 vga
	mknod kbd		c 17 0	; chmod 600 kbd
	mknod pcaux0		c 13 0	; chmod 600 pcaux0

	# Power Management and PCCARD services
	sh $0 apm cs

	# Ram disk and standard com ports
	sh $0 rd0
	sh $0 com0 com1

	# WindView instrumentation interface
	mknod evtlog		c 68 0  ; chmod 666 evtlog

	;;

floppystd)
	# Standard devices
	mknod console		c 0 0
	mknod drum		c 4 0	; chmod 640 drum ; chgrp kmem drum
	mknod kmem		c 2 1	; chmod 640 kmem ; chgrp kmem kmem
	mknod mem		c 2 0	; chmod 640 mem  ; chgrp kmem mem
	mknod null		c 2 2	; chmod 666 null
	mknod zero		c 2 12	; chmod 666 zero
	mknod tty		c 1 0	; chmod 666 tty
	mknod klog		c 7 0	; chmod 600 klog
	mknod stdin		c 15 0	; chmod 666 stdin
	mknod stdout		c 15 1	; chmod 666 stdout
	mknod stderr		c 15 2	; chmod 666 stderr

	# VGA and Keyboard
	mknod iomem		c 2 13	; chmod 600 iomem
	mknod vga		c 16 0	; chmod 600 vga
	mknod kbd		c 17 0	; chmod 600 kbd
	mknod pcaux0		c 13 0	; chmod 600 pcaux0
	
	# Parallel printer 
	mknod lp0		c 20 0	; chmod 600 lp0
	mknod lp1		c 20 1	; chmod 600 lp1
	mknod lp2		c 20 2	; chmod 600 lp2

	# Power Management and PCCARD services
	sh $0 apm cs

	# Recursively make standard disks, tapes, etc.
	sh $0 fd0 fd1 wd0 wd1 wd2 wd3 sd0 sd1 sd2 sd3 sr0 sr1 sr2 sr3 rd0
	sh $0 sp0 sp1 sp2 sp3
	sh $0 dptr0 dpti0
	sh $0 cr0 cr1
	sh $0 amir0
	sh $0 aacr0
	sh $0 st0 st1
	sh $0 com0 com1 pty0
	sh $0 conskbd0 bpf0
	sh $0 sg0 sg1
	;;

std)
	# Recursively make all the devices on the std floppy
	sh $0 floppystd

	# More ptys
	sh $0 pty1 pty2 pty3

	# Vnode disk interface
	sh $0 vnd0 vnd1

	# com ports for PCCARDs and multiport cards
	sh $0 com2 com3 com4 com5 com6 com7 com8 com9
	sh $0 com10 com11 com12 com13 com14 com15 com16 com17 com18 com19

	# Add all the other regular devs
	mkdir fd > /dev/null 2>&1
	(cd fd && eval `echo "" | awk ' BEGIN { \
		for (i = 0; i < 256; i++) \
			printf("mknod %d c 15 %d;", i, i)}'`)
	chown -R root.wheel fd
	chmod 555 fd
	chmod 666 fd/*

	# mouse multiplexor
	mknod mouse0		c 72 0  ; chmod 600 mouse0

	# mouse multiplexor
	mknod keyboard0		c 71 0  ; chmod 600 keyboard0

	# Sound drivers (OSS creates its own devs but uses mixer0 to probe)
	# mknod mixer0		c 66 0	; chmod 666 mixer0

	# Brooktree video
	mknod bktr0	c 48 0; chmod 660 bktr0
	mknod tuner0	c 48 1; chmod 660 tuner0

	# WindView instrumentation interface
	mknod evtlog		c 68 0  ; chmod 666 evtlog

	;;

stli*)
	if [ $i = "stli" ] ; then
		i=stli0 
	fi
	unit=`expr $i : 'stli\([^.]*\)'`
	case $unit in
	0) name=I;;
	1) name=J;;
	2) name=K;;
	3) name=L;;
	*) echo bad unit for stli in: $i;;
	esac
	case $i in
	stli[0123])
		subunit=0; first=0; line=0;;
	stli[0123].[0123])
		subunit=`expr $i : 'stli[0123].\(.*\)'`
		line=`expr $subunit \* 16`
		;;
	*)	echo bad subunit for stli in: $i
		unit=-1;;
	esac
	case $unit in
	0|1|2|3)
		umask 0
		for j in 0 1 2 3 4 5 6 7 8 9 a b c d e f 
		do
			mknod tty$name$subunit$j c 41 $unit $line
			line=`expr $line + 1`
		done
		umask 077
		;;
	esac
	if [ ! -c stliomem${unit} ]; then
		mknod stliomem${unit} c 41 16 ${unit}
	fi
	;;

stl*)
	if [ $i = "stl" ] ; then
		i=stl0 
	fi
	unit=`expr $i : 'stl\([^.]*\)'`
	case $unit in
	0) name=E;;
	1) name=F;;
	2) name=G;;
	3) name=H;;
	*) echo bad unit for stl in: $i;;
	esac
	case $i in
	stl[0123])
		subunit=0; first=0; line=0;;
	stl[0123].[0123])
		subunit=`expr $i : 'stl[0123].\(.*\)'`
		line=`expr $subunit \* 16`
		;;
	*)	echo bad subunit for stl in: $i
		unit=-1;;
	esac
	case $unit in
	0|1|2|3)
		umask 0
		for j in 0 1 2 3 4 5 6 7 8 9 a b c d e f 
		do
			mknod tty$name$subunit$j c 40 $unit $line
			line=`expr $line + 1`
		done
		umask 077
		;;
	esac
	;;

st*)
	umask 0
	unit=`getunit $i`
	chr=19
	# SCSI density codes for QIC tape (incomplete)
	# XXX block devices currently unsupported
	qic11=4; qic24=5; qic120=15; qic150=16; qic525=17
	dds=19; ddsII=36
	fixed=512;	# High bit indicates fixed length records
	mknod rst${unit} c $chr $unit 0
	mknod nrst${unit} c $chr $unit 1
	mknod rst${unit}_f8mm c $chr $unit  $fixed
	mknod nrst${unit}_f8mm c $chr $unit `expr $fixed + 1`
	mknod rst${unit}_fixed c $chr $unit  $fixed
	mknod nrst${unit}_fixed c $chr $unit `expr $fixed + 1`
	mknod rst${unit}_dds c $chr $unit `expr $dds \* 2`
	mknod nrst${unit}_dds c $chr $unit `expr $dds \* 2 + 1`
	mknod rst${unit}_fdds c $chr $unit `expr $dds \* 2 + $fixed`
	mknod nrst${unit}_fdds c $chr $unit `expr $dds \* 2 + $fixed + 1`
	mknod rst${unit}_ddsII c $chr $unit `expr $ddsII \* 2`
	mknod nrst${unit}_ddsII c $chr $unit `expr $ddsII \* 2 + 1`
	mknod rst${unit}_fddsII c $chr $unit `expr $ddsII \* 2 + $fixed`
	mknod nrst${unit}_fddsII c $chr $unit `expr $ddsII \* 2 + $fixed + 1`
	mknod rst${unit}_q11 c $chr $unit `expr $qic11 \* 2`
	mknod nrst${unit}_q11 c $chr $unit `expr $qic11 \* 2 + 1`
	mknod rst${unit}_q24 c $chr $unit `expr $qic24 \* 2`
	mknod nrst${unit}_q24 c $chr $unit `expr $qic24 \* 2 + 1`
	mknod rst${unit}_q120 c $chr $unit `expr $qic120 \* 2`
	mknod nrst${unit}_q120 c $chr $unit `expr $qic120 \* 2 + 1`
	mknod rst${unit}_q150 c $chr $unit `expr $qic150 \* 2`
	mknod nrst${unit}_q150 c $chr $unit `expr $qic150 \* 2 + 1`
	mknod rst${unit}_q525 c $chr $unit `expr $qic525 \* 2`
	mknod nrst${unit}_q525 c $chr $unit `expr $qic525 \* 2 + 1`
	umask 077
	;;

dpti*)
        umask 2 ; unit=`expr $i : 'dpti*\(.*\)'`
        name=dpti; maj=59
        case $unit in
                [0-9] | [0-9][0-9])
                mknod ${name}${unit}    b $maj $unit 0
                mknod r${name}${unit}   c $maj $unit 0
                chmod 640 ${name}${unit} r${name}${unit}
                ;;
        *)
        echo bad unit for disk in: $i
        ;;
        esac
        umask 77
        ;;

dptr*)
        umask 2 ; unit=`expr $i : 'dptr*\(.*\)'`
        name=dptr; maj=38
        case $unit in
                [0-9] | [0-9][0-9])
                mknod ${name}${unit}    b $maj $unit 0
                mknod r${name}${unit}   c $maj $unit 0
                chmod 640 ${name}${unit} r${name}${unit}
                ;;
        *)
        echo bad unit for disk in: $i
        ;;
        esac
        umask 77
        ;;

fd*|wd*|sd*|sr*|sp*|vnd*|rd*|cr*|amir*|dc*|aacr*)
	umask 002
	unit=`getunit $i`
	case $i in
	fd*) name=fd; maj=9;;
	wd*) name=wd; maj=3;;
	sd*) name=sd; maj=18;;
	sr*) name=sr; maj=34;;
	cr*) name=cr; maj=46;;
	dc*) name=dc; maj=47;;
	amir*) name=amir; maj=58;;
	aacr*) name=aacr; maj=67;;
	vnd*) name=vnd; maj=42
	    rm -f vnd
	    mknod vnd c 42 1023 0
	    chmod 0600 vnd;;
	rd*) name=rd; maj=44;;
	sp*) name=sp; maj=37
	    rm -f splice
	    mknod splice c 37 1023 0
	    chmod 0600 splice;;
	esac
	case $unit in
	[0-9] | [0-9][0-9])
		mknod ${name}${unit}a	b $maj $unit 0
		mknod ${name}${unit}b	b $maj $unit 1
		mknod ${name}${unit}c	b $maj $unit 2
		mknod ${name}${unit}d	b $maj $unit 3
		mknod ${name}${unit}e	b $maj $unit 4
		mknod ${name}${unit}f	b $maj $unit 5
		mknod ${name}${unit}g	b $maj $unit 6
		mknod ${name}${unit}h	b $maj $unit 7
		mknod r${name}${unit}a	c $maj $unit 0
		mknod r${name}${unit}b	c $maj $unit 1
		mknod r${name}${unit}c	c $maj $unit 2
		mknod r${name}${unit}d	c $maj $unit 3
		mknod r${name}${unit}e	c $maj $unit 4
		mknod r${name}${unit}f	c $maj $unit 5
		mknod r${name}${unit}g	c $maj $unit 6
		mknod r${name}${unit}h	c $maj $unit 7
		chgrp operator ${name}${unit}[a-h] r${name}${unit}[a-h]
		if [ $name = fd ]; then
			chmod 666 ${name}${unit}[a-h] r${name}${unit}[a-h]
			rm -f floppy${unit}
			ln ${name}${unit}c floppy${unit}
			rm -f rfloppy${unit}
			ln r${name}${unit}c rfloppy${unit}
			rm -f fd${unit}
			ln ${name}${unit}c fd${unit}
			rm -f rfd${unit}
			ln r${name}${unit}c rfd${unit}
			cpart=2
			mknod rfd${unit}_1440_3.5  c $maj $unit `expr $cpart + 32`
			mknod rfd${unit}_720_3.5   c $maj $unit `expr $cpart + 56`
			mknod rfd${unit}_1200_5.25 c $maj $unit `expr $cpart + 16`
			mknod rfd${unit}_720_5.25  c $maj $unit `expr $cpart + 40`
			mknod rfd${unit}_360_5.25  c $maj $unit `expr $cpart + 48`
			chgrp operator rfd${unit}_*
			chmod 666 rfd${unit}_*
		else
			chmod 640 ${name}${unit}[a-h] r${name}${unit}[a-h]
		fi
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 077
	;;

com*|tty*)
	unit=`getunit $i`
	case $unit in
	[0-9])
		mknod tty0${unit} c 8 $unit
		;;
	[0123][0-9])
		mknod tty${unit} c 8 $unit
		;;
	*)
		echo bad unit for com in: $i
		;;
	esac
	;;

pty*)
	unit=`getunit $i`
	case $unit in
	0) offset=0 name=p;;
	1) offset=16 name=q;;
	2) offset=32 name=r;;
	3) offset=48 name=s;;
	4) offset=64 name=t;;
	5) offset=80 name=u;;
	6) offset=96 name=v;;
	7) offset=112 name=w;;
	8) offset=128 name=x;;
	9) offset=144 name=y;;
	10) offset=160 name=z;;
	11) offset=176 name=P;;
	12) offset=192 name=Q;;
	13) offset=208 name=R;;
	14) offset=224 name=S;;
	15) offset=240 name=T;;
	*) echo bad unit for pty in: $i;;
	esac
	case $unit in
	0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15)
		umask 0
		eval `echo $offset $name | awk ' { b=$1; n=$2 } END {
			for (i = 0; i < 16; i++)
				printf("mknod tty%s%x c 5 %d; \
					mknod pty%s%x c 6 %d; ", \
					n, i, b+i, n, i, b+i); }'`
		umask 077
		;;
	esac
	;;

conskbd*)
	unit=`getunit $i`
	name=conskbd
	chr=12
	case $unit in
	0)
		umask 077
		mknod ${name}${unit}	c $chr $unit
		for i in 2 3 4 5 6 7 8
		do
			if [ ! -f ttyc${i} ] ; then
				mknod ttyc${i} c ${chr} `expr ${i} - 1`
			fi
		done
		;;
	*)
		echo bad unit for $name in: $1
		;;
	esac
	;;

bpf*)
	name=bpf
	chr=14
	base=`getunit $i`
	case $base in
	f|0)
		units="0 1 2 3 4 5 6 7 8 9"
		;;
	1)
		units="10 11 12 13 14 15 16 17 18 19"
		;;
	2)
		units="20 21 22 23 24 25 26 27 28 29"
		;;
	*)
		echo bad unit for $name in: $1
		;;
	esac
	for unit in $units
	do
		mknod ${name}${unit}	c $chr $unit
		chmod 440 ${name}${unit}
		chgrp kmem ${name}${unit}
	done
	;;

sg*)
	name=sg
	chr=39
	unit=`getunit $i`
	mknod ${name}${unit} c $chr $unit 0
	chmod 0600 ${name}${unit}
	;;

tun*)
	name=tun
	chr=45
	unit=`getunit $i`
	mknod ${name}${unit} c $chr $unit
	chmod 0600 ${name}${unit}
	;;
	
rc*)
	unit=`getunit $i`
	case $unit in
	0) offset=0  name=a;;
	1) offset=8  name=b;;
	2) offset=16 name=e;;
	3) offset=24 name=f;;
	4) offset=32 name=g;;
	*) echo bad unit for rc in: $i;;
	esac
	case $unit in
	0|1|2|3|4|5)
		umask 0
		eval `echo $offset $name | awk ' { b=$1; n=$2 } END {
			for (i = 0; i < 8; i++)
				printf("mknod tty%s%x c 11 %d; ", \
					n, i, b+i); }'`
		umask 077
		;;
	esac
	;;

rp*)
	if [ $i = "rp" ] ; then
		i=rp0 
	fi
	unit=`expr $i : 'rp\([^.]*\)'`
	case $unit in
	0) name=R;;
	1) name=S;;
	2) name=T;;
	3) name=U;;
	*) echo bad unit for rp in: $i;;
	esac
	case $i in
	rp[0123])
		line=0 ; count=32;;
	rp[0123].[0-9]*)
		line=0; count=`expr $i : 'rp[0123].\(.*\)'`;;
	*)	echo bad count for rp in: $i
		unit=-1;;
	esac
	case $unit in
	0|1|2|3)
		umask 0
		for j in `jot $count 0`
		do
			mknod tty$name$j c 35 $unit $line
			line=`expr $line + 1`
		done
		umask 077
		;;
	esac
	;;

digi*)
	if [ $i = "digi" ] ; then
		i=digi0 
	fi
	unit=`expr $i : 'digi\([^.]*\)'`
	case $unit in
	0) name=A;;
	1) name=B;;
	2) name=C;;
	3) name=D;;
	*) echo bad unit for digi in: $i;;
	esac
	case $i in
	digi[0123])
		subunit=0; first=0; line=0;;
	digi[0123].[0123])
		subunit=`expr $i : 'digi[0123].\(.*\)'`
		line=`expr $subunit \* 16`
		;;
	*)	echo bad subunit for digi in: $i
		unit=-1;;
	esac
	case $unit in
	0|1|2|3)
		umask 0
		for j in 0 1 2 3 4 5 6 7 8 9 a b c d e f 
		do
			mknod tty$name$subunit$j c 26 $unit $line
			line=`expr $line + 1`
		done
		umask 077
		;;
	esac
	;;

cy*)
	if [ $i = "cy" ] ; then
		i=cy0 
	fi
	case $i in
	cy0)
		unit=0;;
	cy1)
		unit=1;;
	cy2)
		unit=2;;
	cy3)
		unit=3;;
	*)	echo bad unit for cy in: $i
		unit=-1;;
	esac
	case $unit in
	0|1|2|3)
		umask 0
		line=0
		for j in a b c d e f g h i j k l m n o p q r s t u v w x y z z1 z2 z3 z4 z5 z6
		do
			mknod ttyy${unit}${j} c 36 $unit $line
			line=`expr $line + 1`
		done
		umask 077
		;;
	esac
	;;

si*)
	unit=`expr $i : 'si\([^.]*\)'`
	case $unit in
	0) name=a;;
	1) name=b;;
	*) echo bad unit for si in: $i;;
	esac
	dev=`echo $i | sed 's/_xp$//'`
	case $dev in
	si[01])		subunit=0; first=0; last=31;;
	si[01].[0-3])	subunit=`expr $dev : 'si[01].\(.*\)'`
			first=`expr $subunit \* 8`
			last=`expr $first + 7`
			subunit=$first;;
	*)		echo bad subunit for si in: $i
			unit=-1;;
	esac
	case $i in
	*_xp)	xp="_xp"; first=`expr $first + 64`
		last=`expr $last + 64`;;
	esac
	case $unit in
	0|1)
		if [ ! -c si_control ]; then
			mknod si_control c 27 0 128
		fi
		umask 0
		eval `echo $unit $name $subunit $first $last $xp | \
		awk ' { b=$1; n=$2; subunit=$3; first=$4; last=$5; xp=$6 } END {
			s=subunit;
			for (i=first; i <= last; i++)
				printf("mknod tty%s%d%s c 27 %d %d; ", \
					n, s++, xp, b, i); }'`
		umask 077
		;;
	esac
	;;

ms*)
	unit=`expr $i : 'ms\(.*\)'`
	case $unit in
	0) name=h;;
	1) name=i;;
	2) name=j;;
	3) name=k;;
	4) name=l;;
	5) name=m;;
	6) name=n;;
	7) name=o;;
	*) echo bad unit for ms in: $i;;
	esac
	case $unit in
	0|1|2|3|4|5|6|7)
		umask 0
		eval `echo $unit $name | awk ' { b=$1; n=$2 } END {
			for (i = 0; i < 8; i++)
				printf("mknod tty%s%x c 24 %d %d; ", \
					n, i, b, i); }'`
		umask 077
		;;
	esac
	;;

apm)
	mknod apm		c 50 0 0; chmod 660 apm
	;;

cs)
	mknod cs		c 51 0 0; chmod 660 cs
	;;

pccard | pcmcia | wildboar)
	mknod rmc0a	c 53 0 0;
	mknod rmc1a	c 53 1 0;
	mknod rmc2a	c 53 2 0;
	mknod rmc3a	c 53 3 0;
	mknod mc0a	b 53 0 0;
	mknod mc1a	b 53 1 0;
	mknod mc2a	b 53 2 0;
	mknod mc3a	b 53 3 0;
	;;

local)
	umask 0
	sh MAKEDEV.local
	;;

vio*)
	umask 0
	mkdir vio
	viomajor=69
	eval `echo $viomajor | awk ' { major=$1 } END {
		for (minor = 0; minor < 63; minor++)
			printf("mknod vio/%d c %d %d; \
			        chmod 666 vio/%d;",   \
				minor, major, minor, minor ); }'`
	umask 077
	;;

*)
	echo "MAKEDEV: $i: no such device."
	;;
esac
done
